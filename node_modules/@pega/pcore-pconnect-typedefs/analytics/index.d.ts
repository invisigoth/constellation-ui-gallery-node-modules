import '../globals';
/**
 * Retrieves the list of data objects in the current application.
 * @param {boolean} useCache whether to use session cache or not.
 * @function getDataPageObjects
 * @returns {Promise} Resolves to a response containing data objects corresponding to data pages.
 */
export declare function getDataPageObjects(useCache?: boolean): any;
/**
 * Retrieves the list of data objects in the current application.
 * @function getDataObjects
 * @returns {Promise} Resolves to a response containing data objects corresponding to data types and case types.
 *
 * @example  <caption>In this example, the API returns a Promise that resolves to a response containing the list of data objects.</caption>
 * PCore.getAnalyticsUtils().getDataObjects().then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output:[{
 * //   classID: "OPB1HW-MyApp-Work-MyCase",
 * //   defaultListViewData: "D_MyCaseList",
 * //   (other properties like: description, name, links)
 * // }]
 */
export declare function getDataObjects(): any;
/**
 * Retrieves the default columns for a table displaying case data.
 * @function getDefaultColumns
 * @param {object} payload A payload object that will specify the report to retrieve the columns from for use as the "default fields" of a data entity.
 * @param {string} payload.reportName The name of the report in which the default columns are configured.
 * @param {string} payload.className The class of the report in which the default columns are configured
 * @returns {Promise} Resolves to a response containing info for the default columns.
 *
 * @example  <caption>In the example below, the API returns a Promise that resolves to a response containing information for the default columns.</caption>
 * const payload = { className: "OZ1CUU-MyApp-Work-MyCase", reportName: "DataTableEditorReport" };
 * PCore.getAnalyticsUtils().getDefaultColumns(payload).then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output:[
 * //   { pyFieldName: "pzInsKey" },
 * //   { pyFieldName: "pyID" },
 * //   { pyFieldName: "columnName" }
 * // ]
 */
export declare function getDefaultColumns(payload: any): any;
/**
 * This API retrieves the columns configured on the RD which is bound to the given data view.
 * @function getFieldsForDataSource
 * @param {string} dataViewName - dataViewName name
 * @param {boolean} skipStoreCheck - The flag that determines if the fields of the given data view must be fetched from the rule store or from the browser cache.
 * Set skipStoreCheck to true if the fields of the given data view must be fetched from the browser cache.
 * Set skipStoreCheck to false if the fields of the given data view must be fetched from the rule store.
 * If the fields are not found in the rule store, it is fetched from the browser cache.
 * @param {string} contextName name of the context.
 * @returns {object} list of columns configured on RD bound on the data view
 *
 * @example  <caption>In the example below, the API returns a Promise that resolves to a response containing list of RD columns.</caption>
 * const dataViewName = "D_MyCaseList"
 * PCore.getAnalyticsUtils().getFieldsForDataSource(dataViewName, false, 'app/Primary_1');
 * //The response of this api will be like shown below.
  {
    "data": [
      { pyFieldName: "pzInsKey" },
      { pyFieldName: "pyID" },
      { pyFieldName: "columnName" }
    ]
  }
 */
export declare function getFieldsForDataSource(dataViewName: string, skipStoreCheck: boolean, contextName: string): any;
/**
 * Retrieves the the primary fields for the given dataview
 * @function getPrimaryFieldsForDataSource
 * @param {string} dataViewName - dataViewName name
 * @param {string} dataViewClassName - class name
 * If Primary Fields are not found, defaults to listing Fields
 * @returns {object} list of primary fields or fields
 *
 */
export declare function getPrimaryFieldsForDataSource(dataViewName?: string, dataViewClassName?: string): any;
/**
 * This API obtains the metadata of a data view as a Promise and caches the response in session storage.
 * @function getDataViewMetadata
 * @param {string} dataViewName - dataViewName name
 * @param {boolean} skipStoreCheck - The flag that determines if the metadata of the given data view must be fetched from the rule store or from the metadata API
 * Note:
 * - The default value is false.
 * - Set `skipStoreCheck` to true if the metadata of the given data view must be fetched from the /metadata API call
 * - Set `skipStoreCheck` to false if the metadata of the given data view must be fetched from rules store. if its not found on that then fetch it from /metadata API call

 * @returns {object} metadata object for the given dataView
 *
 * @example  <caption>In the example below, the API returns the metadata of the data view whose name is 'D_BugList'.</caption>
 *
 * const dataViewName = "D_BugList"
 * PCore.getAnalyticsUtils().getDataViewMetadata(dataViewName);
 *
 * //The response of this api will be like shown below.
 {
  "data" : {
    "classID": "PegaProjMgmt-Work-Bug",
    "className": "Bug",
    "structure": "List",
    "isQueryable": true,
    "fields": [
        {
        "description": "operator who manager assigns work to",
        "fieldID": "pyAssignedOperator",
        "fieldType": "Identifier",
        "isReadOnly": false,
        "name": "Assigned To",
        "dataType": "Identifier"
        },
        {
        "description": "This property is used to identify the work object's parent
        Backlog and should include the pyID of that work object. In the future,
        it will be derived from the user's data input into UserStoryIDEntry or
        based upon the context of the creation of the item.",
        "displayAs": "pxTextInput",
        "fieldID": "BacklogID",
        "fieldType": "Text (single line)",
        "isReadOnly": false,
        "name": "Backlog ID",
        "maxLength": 32,
        "dataType": "Text"
        }
    ]
  }
}
*
*/
export declare function getDataViewMetadata(dataViewName: string, skipStoreCheck: boolean, associationFilter: any): Promise<{
    data: any;
}>;
/**
 * Retrieves all available insight IDs.
 * @function getInsightIDs
 * @returns {Promise} Resolves to a response containing a list of insights with the related information.
 *
 * @example  <caption>In this example, the API returns a Promise that resolves to a response containing a list of insight with the related information</caption>
 * PCore.getAnalyticsUtils().getInsightIDs().then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output: {
 * //   pyInsights: [{
 * //     pyID: "124e9385-a623-4c55-ba8e-5af8cbd0ae64",
 * //     pyName: "Saved Insight"
 * //     pyCreateDateTime: "20200630T183653.784 GMT",
 * //     pyCreateOperator: "user@pega.com",
 * //     pyUpdateDateTime: "20200630T183656.330 GMT",
 * //     pyUpdateOperator: "user@pega.com",
 * //     pxObjClass: "PegaBI-API-Insight"
 * //   }]
 * // }
 */
export declare function getInsightIDs(): any;
/**
 * Retrieves the metadata related to the given insight ID.
 * @function getInsightByID
 * @param {string} insightID The unique ID for the insight you are trying to retrieve.
 * @returns {Promise} Resolves to a response containing the metadata for the given insight.
 *
 * @example  <caption>In the example below, the API returns a Promise that resolves to a response containing the metadata for the specified insight.</caption>
 * const insightID = "124e9385-a623-4c55-ba8e-5af8cbd0ae64";
 * PCore.getAnalyticsUtils().getInsightByID(insightID).then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output: {
 * //   pyInsights: [{
 * //     pyContent: "[stringified insight metadata json]",
 * //     pyName: "Insight Name",
 * //     pyPermissions: [{
 * //       pyAccessCategory: "Rule-Access-Role-Name",
 * //       pyAccessType: "view",
 * //       pyAccessValue: "TestApp:Users"
 * //     }]
 * //   }]
 * // }
 */
export declare function getInsightByID(insightID: string): any;
/**
 * Creates a new insight rule containing the provided metadata.
 * @function createInsight
 * @param {object} insightObject The metadata you want to store in an insight rule.
 * @returns {Promise} Resolves to a response containing the ID for the new insight.
 *
 * @example  <caption>The API creates a new insight rule and returns a Promise that resolves to a response containing top-level info for the insight.</caption>
 * const insightObject = {
 *   pyContent: "[stringified insight metadata json]",
 *   pyName: "Insight Name",
 *   pyPermissions: [{
 *     pyAccessCategory: "Rule-Access-Role-Name",
 *     pyAccessType: "view", // or "edit"
 *     pyAccessValue: "TestApp:Users"
 *   }]
 * };
 * PCore.getAnalyticsUtils().createInsight(insightObject).then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output: {
 * //   pyID: "124e9385-a623-4c55-ba8e-5af8cbd0ae64",
 * //   pyName: "Insight Name",
 * //   pyCreateDateTime: "20200630T183653.784 GMT",
 * //   pyCreateOperator: "user@pega.com",
 * //   pyUpdateDateTime: "20200630T183656.330 GMT",
 * //   pxObjClass: "PegaBI-API-Insight"
 * // }
 */
export declare function createInsight(insightObject: any): any;
/**
 * Update an existing insight rule.
 * @param {string} insightID The ID of the insight rule to update.
 * @param {object} insightObject The insight metadata to save.
 *
 * @example <caption>The API updates an existing insight rule and returns a Promise that resolves to a response containing top-level info for the insight.</caption>
 * const insightID = "124e9385-a623-4c55-ba8e-5af8cbd0ae64";
 * const insightObject = {
 *   pyContent: "[stringified insight metadata json]",
 *   pyName: "Insight Name",
 *   pyPermissions: [{
 *     pyAccessCategory: "Rule-Access-Role-Name",
 *     pyAccessType: "view", // or "edit"
 *     pyAccessValue: "TestApp:Users"
 *   }]
 * };
 * PCore.getAnalyticsUtils().updateInsight(insightID, insightObject).then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output: {
 * //   pyID: "124e9385-a623-4c55-ba8e-5af8cbd0ae64",
 * //   pyName: "Insight Name",
 * //   pyCreateDateTime: "20200630T183653.784 GMT",
 * //   pyCreateOperator: "user@pega.com",
 * //   pyUpdateDateTime: "20200630T183656.330 GMT",
 * //   pxObjClass: "PegaBI-API-Insight"
 * // }
 */
export declare function updateInsight(insightID: string, insightObject: any): any;
/**
 * Delete an existing insight rule.
 * @function deleteInsight
 * @param {string} insightID The ID of the insight rule to delete.
 * @returns {Promise} Resolves to a response containing the ID of the insight which was deleted.
 *
 * @example  <caption>In the example below, the API deletes an existing insight rule and returns a Promise that resolves to a response containing the ID</caption>
 * const insightID = "<some GUID>";
 * PCore.getAnalyticsUtils().deleteInsight(insightID).then(response => { console.log(response.data); }).catch(() => { ... });
 */
export declare function deleteInsight(insightID: string): any;
/**
 * Exports a table to an Excel file.
 * @function exportToExcel
 * @param {object} exportRequest A payload object to configure an export
 * @param {string} exportRequest.pyName Gives the exported table a name.
 * @param {string} exportRequest.pyMode The type of export to perform ("excel", etc.)
 * @param {string} exportRequest.pyClassName The class of the data to export.
 * @param {string} exportRequest.pyReportTitle The name of the file to export.
 * @param {string} exportRequest.pyContent A stringified JSON object containing table component <code>metadata</code> and <code>state</code>.
 * @returns {Promise} Resolves to a base64 response that is the Excel file.
 * @private
 *
 * @example  <caption>In the example below, the API returns a Promise that resolves to a base64 response (the Excel file).</caption>
 * const exportRequest = {
 *   pyName: "Export",
 *   pyMode: "excel",
 *   pyClassName: "@baseclass",
 *   pyReportTitle: "Insight1",
 *   pyContent: JSON.stringify({ metadata, state })
 * };
 * PCore.getAnalyticsUtils().exportToExcel(exportRequest).then(response => { ... }).catch(() => { ... });
 */
export declare function exportToExcel(exportRequest: any): any;
/**
 * Schedules a table insight as an Excel file.
 * @function scheduleInsight
 * @param {string} insightID The ID of the insight related to the schedule
 * @param {object} exportRequest A payload object to configure an export
 * @param {string} exportRequest.pyName Gives the exported table a name.
 * @param {string} exportRequest.pyMode The type of export to perform ("excel", etc.)
 * @param {string} exportRequest.pyClassName The class of the data to export.
 * @param {string} exportRequest.pyReportTitle The name of the file to export.
 * @param {string} exportRequest.pyContent A stringified JSON object containing table component <code>metadata</code> and <code>state</code>.
 * @private
 *
 * @example  <caption>In the example below, the API schedules an insight.</caption>
 * const exportRequest = {
 *   pyName: "Export",
 *   pyMode: "excel",
 *   pyClassName: "@baseclass",
 *   pyReportTitle: "Insight1",
 *   pyContent: JSON.stringify({ metadata, state })
 * };
 * PCore.getAnalyticsUtils().scheduleInsight(exportRequest).then(response => { ... }).catch(() => { ... });
 */
export declare const scheduleInsight: (insightID: string, exportRequest: any) => any;
/**
 * Updates a scheduled table insight
 * @function updateScheduledInsight
 * @param {string} insightID The ID of the insight related to the schedule
 * @param {string} scheduleID The ID of the schedule being updated
 * @param {object} exportRequest A payload object to configure an export
 * @param {string} exportRequest.pyName Gives the exported table a name.
 * @param {string} exportRequest.pyMode The type of export to perform ("excel", etc.)
 * @param {string} exportRequest.pyClassName The class of the data to export.
 * @param {string} exportRequest.pyReportTitle The name of the file to export.
 * @param {string} exportRequest.pyContent A stringified JSON object containing table component <code>metadata</code> and <code>state</code>.
 * @param {string} exportRequest.pyID Key for scheduled insight to update
 * @private
 *
 * @example  <caption>In the example below, the API updates a scheduled insight.</caption>
 * const exportRequest = {
 *   pyName: "Export",
 *   pyMode: "excel",
 *   pyClassName: "@baseclass",
 *   pyReportTitle: "Insight 1",
 *   pyContent: JSON.stringify({ metadata, state })
 *   pyID: 'W-8001'
 * };
 * PCore.getAnalyticsUtils().updateScheduledInsight(insightID, scheduleID, exportRequest).then(response => { ... }).catch(() => { ... });
 */
export declare const updateScheduledInsight: (insightID: string, scheduleID: string, exportRequest: any) => any;
/**
 * Deletes a scheduled table insight
 * @function deleteScheduledInsight
 * @param {string} insightID The ID of the insight related to the schedule
 * @param {string} scheduleID The ID of the schedule being deleted
 * @private
 *
 * @example  <caption>In the example below, the API deletes an insight.</caption>
 * PCore.getAnalyticsUtils().deleteScheduledInsight(insightId, scheduleID).then(response => { ... }).catch(() => { ... });
 */
export declare const deleteScheduledInsight: (insightID: string, scheduleID: string) => any;
/**
 * Translates a list of strings.
 * @function translateStrings
 * @param {Array} stringsToTranslate A list of strings to translate.
 * @returns {Promise} Resolves to a response containing a grouping of key/value pairs.
 *
 * @example  <caption>In the example below, the API returns a Promise that resolves to a response containing a grouping of key/value pairs. </caption>
 * const stringsToTranslate = ["Hello", "Thank you"];
 * PCore.getAnalyticsUtils().translateStrings(stringsToTranslate).then(response => { console.log(response.data); }).catch(() => { ... });
 * // console output: { Hello: "Hola", "Thank you": "Gracias" }
 */
export declare function translateStrings(stringsToTranslate: string): any;
declare const _default: {
    getDataObjects: typeof getDataObjects;
    getDataPageObjects: typeof getDataPageObjects;
    getDataViewMetadata: typeof getDataViewMetadata;
    getDefaultColumns: typeof getDefaultColumns;
    getFieldsForDataSource: typeof getFieldsForDataSource;
    getPrimaryFieldsForDataSource: typeof getPrimaryFieldsForDataSource;
    getInsightIDs: typeof getInsightIDs;
    getInsightByID: typeof getInsightByID;
    createInsight: typeof createInsight;
    updateInsight: typeof updateInsight;
    deleteInsight: typeof deleteInsight;
    exportToExcel: typeof exportToExcel;
    scheduleInsight: (insightID: string, exportRequest: any) => any;
    updateScheduledInsight: (insightID: string, scheduleID: string, exportRequest: any) => any;
    deleteScheduledInsight: (insightID: string, scheduleID: string) => any;
    translateStrings: typeof translateStrings;
};
export default _default;
