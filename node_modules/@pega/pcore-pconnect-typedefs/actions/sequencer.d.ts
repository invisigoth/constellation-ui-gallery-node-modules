/**
 * Provides the basic APIs to sequence different type of actions in the Constellation infrastructure.
 *
 * Actions are classified into 2 types blocking actions and deferred actions.
 *
 * For example: In an assignment, File Attachment is blocking action while finishAssignment is deferred action.
 * By using these apis, it is ensured that a deferred action is always fired when all blocking actions are completed.
 *
 */
declare class ActionsSequencer {
    MISSING_CONTEXT_PARAM: string;
    INVALID_CONTEXT_DETAILS: string;
    INVALID_CONTEXT_OPERATION: string;
    /**
     * Dispatches queued actions on completion of currently running  action.Called from deRegisterBlockingAction,handleDeferredActionCompletion
     * @param {string} context
     * For example: "app/modal_1"
     * @param {object} contextDataObject data object for respective context fetched from redux
     *
     * @function
     * @private
     */
    schedulePendingActionOnCompletion(context: any, contextDataObject: {
        context_data: {
            blocking_action_counter: number;
            deferred_action_queue: any;
            is_deferred_action_in_progress: boolean;
        };
    }): void;
    /**
     * executes or queues deferred actions in the context of a container
     * @example <caption>In this example, the API tries to execute or queue the specified deferred action in the context of the 'app/primary_1' container and returns a promise containing the status of the deferred action</caption>
     * PCore.getActionsSequencer().executeOrQueueDeferredAction({
     * type: theType
     * payload: {
     *  context: app/primary_1,
     * //include other payload properties
     * }
     * }).then(successCallback).catch(failureCallback);
     * @param {object} actionPayload The deferred action that must be executed or queued
     * @returns  {Promise<object>} A promise associated with the action
     * <ul>
     * <li> The promise resolves successfully when the deferred action has been either executed or queued.
     * <li> The promise rejects with an error message when the deferred action has been neither executed nor queued.
     * </ul>
     *
     * @function
     */
    executeOrQueueDeferredAction(actionPayload: {
        type?: string;
        payload: any;
    }): Promise<void>;
    /**
     * signals the completion of execution of the ongoing deferred action and schedules the next deferred action in queue for execution
     * @example <caption>In this example, the API tries to signal the completion of execution of the ongoing deferred action and returns a promise associated with the action.</caption>
     * PCore.getActionsSequencer().handleDeferredActionCompletion("app/primary_1").then(successCallback).catch(failureCallback);
     * @param {string} context  The name of the context where the API is being called
     * @returns {Promise<object>} A promise associated with the action
     * Note:
     * <ul>
     * <li> The promise resolves successfully when the execution of the deferred action has been completed.
     * <li> The promise rejects with an error message when the execution of the deferred action has not been completed.
     * </ul>
     *
     * @function
     */
    handleDeferredActionCompletion(context: string): Promise<void>;
    /**
     * Registers an ongoing blocking action in the context of a container
     * @example <caption>In this example, the API tries to register the ongoing blocking action in the context of the app/primary_1 container and returns a promise containing the registration status</caption>
     * PCore.getActionsSequencer().registerBlockingAction("app/primary_1").then(successCallback).catch(failureCallback);
     * @param {string} context The name of the context where the APi si being called.
     * @returns {Promise<object>} A promise containing the registration status  of the ongoing blocking action
     * @function
     * @public
     */
    registerBlockingAction(context: any): Promise<void>;
    /**
     * De-registers an ongoing  blocking action in the context of a container when the blocking action is completed
     * @example <caption>In this example , the API tries to de-register the ongoing blockng action in the context of the app/primary_1 container and returns a promise containing the de-registration status</caption>
     * PCore.getActionsSequencer().deRegisterBlockingAction("app/primary_1").then(successCallback).catch(failureCallback);
     * @param {string} context The name of the context where the API is being called.
     * @returns {Promise<object>} A promise containing the de-registration status  of the ongoing blocking action
     * @function
     * @public
     */
    deRegisterBlockingAction(context: any): Promise<void>;
    /**
     * cancels queued deferred actions when an error occurs
     * @example <caption>In this example, the API cancels queued deferred actions when an error occurs.</caption>
     * PCore.getActionsSequencer().cancelDeferredActionsOnError("app/primary_1");
     * @param {string} context The name of the context where the API is being called.
     * @function
     * @public
     */
    cancelDeferredActionsOnError(context: any): void;
}
declare const _default: ActionsSequencer;
export default _default;
