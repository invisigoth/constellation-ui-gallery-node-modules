declare const _default: BootstrapUtils;
export default _default;
declare class BootstrapUtils {
    createC11nEnv: (meta: any) => {
        getPConnect: () => import("../interpreter/c11n-env").C11nEnv;
    };
    getContextUtils: () => typeof ContextUtils;
    getRoutingManager: () => typeof RoutingManager;
    getComponentsRegistry: () => {
        register(componentName: any, component: any): void;
        registerLazyMap(componentName: any, component: any): void;
        registerCustomComponentLazyMap(componentName: any, component: any): void;
        getComponent(componentName: any): any;
        getLazyComponent(componentName: any): any;
        getCustomComponent(componentName: any): any;
        mergeComponentsMap(componentsMap?: {}): void;
        mergeOverrideMap(overrideMap?: {}): void;
        getOverrideMap(): any;
        getLazyMap(): any;
    };
    getStateManager: () => typeof StateManager;
    getActionCreators: () => typeof ActionCreators;
    getStreamObservable: () => typeof StreamObservable;
    getActionProcessor: () => typeof ActionProcessor;
    getActionHandler: () => {
        getHandler(actionName: string | number): any;
        registerHandler(actionName: string | number, handler: any): void;
    };
    renderApp: (translatedDXAPIResponse: any, domContainerID: any) => void;
    /** updates store with apiResponse
     * @public
     * @param {*} dxAPIResponse - uiResources response
     * @param {string} containerName - container name
     * @param {boolean} isPortal - is portal
     */
    public updateStoreWithUiRoot: (dxAPIResponse: any, containerName: string, isPortal: boolean) => Promise<void>;
    fetchEndPointResource: (endPoint: any, containerName: any, isPortal: any) => void;
    loadComponent: (componentConfig: any, domContainerID: any, additionalComponents: any) => Promise<void>;
    setStaticServerUrl: (staticUrl: any, appStaticUrl: any, b2sJWT: any) => void;
    loadView: (dxAPIResponse: any, domContainerID: any, additionalComponents?: any[]) => Promise<void>;
    /**
     * This is common method to initialize app shell and it gets invoked from pxBootstrapShell
     * @param {*} appRoutingTable - appRoutingTable
     * @param {*} actionsTargetModel -  actionsTargetModel
     * @param {*} servicesObj - servicesObj
     */
    initAppShell: (appRoutingTable: any, actionsTargetModel: any, servicesObj: any) => void;
    /**
     * This method on the bootstrap is used to initialize just the routing table - this is used in scenarios such as the constellation
     * bridge wherein actions targeting and service objects are not useful
     * @param {*} appRoutingTable - appRoutingTable
     *  @param {*} servicesObj - servicesObj
     */
    initRoutingTable: (appRoutingTable: any, servicesObj: any) => void;
    setAppAlias: (appAlias: any) => void;
    getHomeRestApi: (portalName: any) => string;
    /**
     * Returns the full path to the view endpoint
     * @param   {string} viewID - View Name passed in the queryparam
     * @param   {string} viewClass - View Name passed in the queryparam
     * @returns {string} Full path to the view endpoint
     */
    getViewRestApi: (viewID: string, viewClass: string) => string;
    /**
     * Renders RootContainer initially
     * @param {*} domContainerID - Container under which view must be loaded
     * @param {*} componentMetaData - componentMetaData of RootContainer
     * @param {*} additionalComponents - Additional components
     * @param {*} portalTarget - Optional, DOM element into which view will be loaded and used as cosmos portal target(usually a shadowdom element)
     * @param {*} styleSheetTarget - Optional, DOM element into which cosmos styles will be injected
     * @param {boolean} removeContainer - check to remove the container
     */
    loadRootComponent: (domContainerID: any, componentMetaData: any, additionalComponents: any, portalTarget: any, styleSheetTarget: any, removeContainer: boolean) => Promise<void>;
    /**
     * Loads the view under the given container after hitting the view endpoint and getting the view response.
     * @param {string}  viewName - View Name passed in the queryparam
     * @param {string}  portalName - Default portal, used for a fallback when the viewName can not be resolved
     * @param {string}  viewClass - View Name passed in the queryparam
     * @param {string}  containerName - container name
     */
    loadViewByName: (viewName: string, portalName: string, viewClass: string, containerName: string) => void;
    loadPortalView: (portalName: any, containerName: any) => void;
    configureForBrowserBookmark: (payload: any) => void;
    checkIfSemanticURL: () => boolean;
    /**
     * onPCoreReady API ensures that PCore is loaded and ready to use. This accepts a callback function,
     * that will be called once the application (PCore) infrastructure has established and is ready to perform its initial render.
     *
     * This API registers a callback that will be called once the application infrastructure has established the store and is ready to perform its initial render.
     *
     * @param {Function} callback callback function
     * @example <caption>Usage of onPCoreReady</caption>
     * Usage:
     * const render = function(){
     *  // logic to render and bootstrap your application.
     * };
     * onPCoreReady usage: onPCoreReady((args) => render(args));
     *
     * the callback function with render is called once the infrastructure is ready.
     */
    onPCoreReady: (callback: Function) => void;
    setFieldsDefaultConfigs: (config: any) => void;
    setGoogleMapsAPIKey: (googleMapsAPIKey: any) => void;
    setFetchDefaultHeaders: (headersObj: any) => void;
    setFetchAuthInfo: (authInfo: any) => void;
    getCaseApi: () => typeof CaseApis;
    getMashupApi: () => typeof MashupApis;
    enableAppRouting: (enableRouting: any) => void;
    initStore: () => void;
}
import * as ContextUtils from '../utils/context-utils';
import * as RoutingManager from '../router/routing-manager';
import * as StateManager from '../store/state/state-manager';
import * as ActionCreators from '../store/state/actions/action-creators';
import * as StreamObservable from '../observables/stream-observable';
import ActionProcessor from '../actions/processor';
import CaseApis from '../case/apis';
import MashupApis from '../mashup/apis';
