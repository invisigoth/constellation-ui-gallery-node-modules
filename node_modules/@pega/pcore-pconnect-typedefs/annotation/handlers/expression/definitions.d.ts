/**
 * A map of all expression elements to their properties. Note that
 * changes here may require changes in the Lexer and Parser.
 */
export declare const supportedGrammar: {
    '>': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    '>=': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    '<': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    '<=': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    '==': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    '!=': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    '!': {
        operatorType: string;
        precedence: number;
        evaluate: (right: any) => boolean;
    };
    '(': {
        operatorType: string;
    };
    ')': {
        operatorType: string;
    };
    '&&': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => string;
    };
    AND: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => string;
    };
    and: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => string;
    };
    '||': {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => string;
    };
    OR: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => string;
    };
    or: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => string;
    };
    CONTAINS: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    NOT_CONTAINS: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    STARTS_WITH: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    NOT_STARTS_WITH: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    ENDS_WITH: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    NOT_ENDS_WITH: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    IS_NULL: {
        operatorType: string;
        precedence: number;
        evaluate: (value: string) => boolean;
    };
    IS_NOT_NULL: {
        operatorType: string;
        precedence: number;
        evaluate: (value: string) => boolean;
    };
    IS_IN_LIST: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
    IS_NOT_IN_LIST: {
        operatorType: string;
        precedence: number;
        evaluate: (left: string, right: string) => boolean;
    };
};
/**
 * Expression handlers. Handles the different types of expression.
 */
declare const expressionHandlers: any;
/**
 * Handlers for all the types of operators that are supported.
 */
declare const OperatorHandlers: any;
/**
 * States in the evaluation of an expression.
 */
export declare const states: any;
export { OperatorHandlers, expressionHandlers };
