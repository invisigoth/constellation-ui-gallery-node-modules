import ValidationApi from '../validation/validation-api';
import ActionsApi from '../actions/api';
import ContainerManager from '../container/container-manager';
import CaseInfo from '../case/case-info';
import { Meta, Config } from './types';
export declare class C11nEnv {
    private readonly meta?;
    private readonly _isRoot;
    private readonly options;
    useCustomContext: boolean | undefined;
    _rawConfig: any;
    private readonly _isExpressionExist;
    private readonly _isWhenExist;
    private readonly _isValidatorExist;
    private readonly _pageReference;
    private readonly _referenceContext;
    private readonly _contextName;
    private readonly _stateProps;
    private _actions;
    private readonly _children;
    private readonly _additionalRegisteredProps;
    private _caseInfo;
    private readonly viewName;
    private readonly parentViewName;
    private _referenceList;
    private readonly _isInsideList;
    private _inheritedConfig;
    private readonly _localeRuleName;
    private readonly _containerTarget;
    private readonly xrayInfo;
    private readonly _readOnly;
    private _hasSuggestions;
    private readonly _isState;
    private readonly _type;
    private _actionsApi;
    constructor(config: Config);
    /**
     * Sets the xray info for xray tool.
     * @function setXRayInfo
     * @param {object} info xray info
     * @private
     */
    setXRayInfo(info: any): void;
    /**
     * Returns the xray info object.
     * @function getXRayInfo
     * @returns {object} xray info object.
     * @private
     */
    getXRayInfo(): any;
    /**
     * Returns the properties which are bound to state, in sense these properties
     * are reactive.
     * @function getStateProps
     *
     * @example
     * Sample:
     * {
     *   "FirstName": "test value"
     * }
     * @example <caption>getPConnect().getStateProps()</caption>
     * const props = getPConnect().getStateProps();
     *
     * @returns {object} the properties that are bound to the Redux state
     */
    getStateProps(): any;
    /**
     * Set the properties which are bound to state, in sense these properties
     * are reactive.
     * @example <caption>getPConnect().setStateProps({'datasourceMetadata':'@FIELD_META .Test'})</caption>
     * @param {object} propsObj object containing each prop name and its value
     * @private
     */
    setStateProps(propsObj: any): void;
    /**
     * Returns the metadata, this is raw, unresolved metadata
     * @returns {object} metadata
     * @private
     */
    getMetadata(): Meta;
    /**
     * Returns instance of CaseInfo class bound to redux store current container context
     * @function getCaseInfo
     * @returns {CaseInfo} Returns instance of the CaseInfo class
     */
    getCaseInfo(): CaseInfo;
    getListActions(): {
        insert: (payload: any, index: any, pageRef: any, options?: {}) => void;
        update: (payload: any, index: any, options: any) => void;
        updateProperty: (propertyName: string, value: string, options?: any) => void;
        deleteEntry: (index: any, pageRef: any) => void;
        reorder: (fromIndex: any, toIndex: any) => void;
        setSelectedRows: (payload: any, options?: {}) => Promise<unknown>;
        getSelectedRows: (withPayload?: boolean) => Promise<any>;
        clearSelectedRows: () => Promise<unknown>;
        setVisibility: (isVisible: any) => void;
        initDefaultPageInstructions: (property: any, propertyNames: any, uniqueField: any) => void;
        deleteAll: (property: any) => void;
        replacePage: (property: any, payload: any) => void;
    };
    getReferenceList(): string;
    isInsideList(): boolean;
    /**
     * <strong>For Advanced Use Only</strong><br>
     * Returns the component's complete metadata in its raw and unresolved format.
     * This API should only
     * be used in advanced use cases where a component needs the complete,
     * unresolved metadata. <strong>In most situations, the component should
     * only require getConfigProps() to get the resolved configuration metadata of
     * the component.</strong><br><br>
     * <strong>NOTE: the format and content of the metadata returned
     * may change as the DX API changes.</strong>
     *
     * @function getRawMetadata
     * @returns {object} The raw, unresolved metadata for the component
     * @public
     *
     * @example  <caption>In the example below, we see the raw, unresolved metadata for a simple "Table" component.</caption>
     *
     * {
     *   "type": "Table",
     *   "config": {
     *     "referenceList": "D_pyMyWorkList.pxResults",
     *     "rowClickAction": "openAssignment",
     *     "personalizationId": "pyMyWork-D_pyMyWorkList",
     *     "fields": [
     *       {
     *         "type": "Text",
     *         "config": { "label": "@L Priority", "formatType": "number", "value": "@P .pxUrgencyAssign" }
     *       },
     *       {
     *         "type": "Text",
     *         "config": { "label": "@L ID", "value": "@P .pxRefObjectInsName" }
     *       },
     *       {
     *         "type": "Text",
     *         "config": { "label": "@L Label", "value": "@P .pyLabel" }
     *       },
     *       {
     *         "type": "DateTime",
     *         "config": { "sortDirection": "DESC", "sortPriority": "1", "label": "@L Creation date/time", "value": "@P .pxCreateDateTime" }
     *       },
     *       {
     *         "type": "Text",
     *         "config": { "label": "@L Status", "value": "@P .pyAssignmentStatus" }
     *       }
     *     ]
     *   }
     * }
     *
     */
    getRawMetadata(): Meta;
    setReferenceList(ref: string): void;
    /**
     * Returns the component's configuration information
     * @function getComponentConfig
     * @example
     * example: {
     *    label: "@P .FirstName"
     * }
     *
     * @example <caption>getPConnect().getComponentConfig()</caption>
     * const config = getPConnect().getComponentConfig();
     * the value of config gets the configuration of the component.
     *
     * @returns {object} component configuration information
     * @private
     */
    getComponentConfig(): any;
    /**
     * Checks whether component has expression configured
     * or not.
     *
     * @function isExpressionExist
     * @returns {boolean} true or false
     * @private
     */
    isExpressionExist(): boolean;
    /**
     * Checks whether component has when configured
     * or not.
     * @function isWhenExist
     * @returns {boolean} true or false
     * @private
     */
    isWhenExist(): boolean;
    /**
     * This APIchecks if the componentis associated with a condition (such as an expression or when condition) and returns true if anyone of them exists.
     * @function isConditionExist
     * @example <caption> Usage of isConditionExist - getPConnect().isConditionExist()</caption>
     * Usage: const isConditionConfigured = getPConnect().isConditionExist();
     * value of isConditionConfigured will be true or false based on current component configuration.
     *
     * @returns {boolean} true or false
     * @public
     */
    isConditionExist(): boolean;
    /**
     * Checks whether current component is bound to state or not.
     * If component has any property reference, it will be treated
     * as bound to state.
     *
     * @function isBoundToState
     *
     * @example <caption>getPConnect().isBoundToState()</caption>
     * const isStateBound = getPConnect().isBoundToState();
     * In this example, the API returns a Boolean value which denotes if the current component is bound to a Redux State.
     *
     * @returns {boolean} True if bound to state
     */
    isBoundToState(): boolean;
    /**
     * Returns the data reference path of the store,
     * where the data value has been stored for current component.
     * @function getPageReference
     *
     * @example
     * For example:
     * @example <caption> While loading a portal(App level)</caption>
     * pageReference value is: "pyPortal"
     * @example <caption> Single component </caption>
     * For components like 'FirstName, LastName', pageReference value is: "caseInfo.content"
     * @example <caption> Embeded components which are under embedded view </caption>
     * For components like 'ZipCode, StreetName' which are under Address view, pageReference value is :"caseInfo.content.Address"
     *
     * @returns {string} pageReference path
     * @public
     */
    getPageReference(): string;
    getFullReference(): string;
    /**
     * this function returns the context name under which the component has rendered.
     *
     * @public
     * @function getContextName
     * @returns {string} context name
     *
     * @example <caption>Example for getContextName()</caption>
     * const context = getPConnect().getContextName();
     * //example output : returns => 'app/primary_1'
     *
     */
    getContextName(): string;
    /**
     * this function returns the Container name with which the component is associated
     *
     * @public
     * @function getContainerName
     * @returns {string} container name
     *
     * @example <caption>Example for getContainerName()</caption>
     * const { containerName = "primary" } = getPConnect().getContainerName();
     * //example output : returns => 'primary'
     *
     */
    getContainerName(): string;
    /**
     * this function returns the fully qualified target container name with which the component is associated
     *
     * @public
     * @function getTarget
     * @returns {string} target name
     *
     * @example <caption>Example for getTarget()</caption>
     * const target = getPConnect().getTarget();
     * // example output : returns => 'app/primary'
     */
    getTarget(): string | undefined;
    /**
     * This API obtains the name of the view under whichthe current component was rendered.This API returns the name of the viewas a string.
     * @public
     * @function    getCurrentView
     * @returns     {string}        view name
     * @example     <caption>Example for getCurrentView()</caption>
     * In this example, the API returns the name of the view under which the current component was rendered.
     * const viewName = getPConnect().getCurrentView();
     */
    getCurrentView(): string | undefined;
    /**
     * Populates suggestion props if config has value prop and redux store has field in suggestion context.
     *
     * @param {object} configObj configObj to which hasSuggestion props gets added
     * @function populateSuggestionProps
     * @example <caption>Usage: getPConnect().populateSuggestionProps({ label: 'label-name' })  </caption>
     * Example Usage:
     * const configProps = { label: 'label-name' }
     * getPConnect().populateSuggestionProps(configProps);
     *
     * After the above populateAdditionalProps function call, the configProps object value gets updated by suggestionProps
     * all the possible keys added to the configObject are:
     * configObject.hasSuggestions (string) - hasSuggestion value.
     *
     * @private
     */
    populateSuggestionProps(configObj?: any): void;
    /**
     * Returns the object with resolved component
     * configuration of the component.
     * @function getConfigProps
     *
     * @example
     * Example:
     * {
     *   label: "@P .FirstName"
     * }
     * output:
     * {
     *   label: "Hello Name"
     * }
     *
     * @example <caption>getPConnect().getConfigProps()</caption>
     * @param {object} destinationObject the object to which config props gets added.
     * const props = getPConnect().getConfigProps();
     *
     *
     * @returns {object} resolved component props.
     */
    getConfigProps(destinationObject?: any): any;
    /**
     * Returns the object with raw configuration of the
     * component along with inherited configuration and
     * additional registered props.
     *
     * @example <caption>getPConnect().getRawConfigProps()</caption>
     * const rawProps = getPConnect().getRawConfigProps();
     *
     * @returns {object} Raw component props.
     *
     * @private
     */
    getRawConfigProps(): any;
    /**
     * Returns the resolved props from the provided input props.
     * @function resolveConfigProps
     * @example
     * Example:
     * {
     *  label: "@P .FirstName"
     * }
     * output:
     * {
     *  label: "Hello Name"
     * }
     * @param {object} configProps Props meant to be resolved.
     * @param {object} destinationObject the object to which config props gets added.
     * @example <caption>getPConnect().resolveConfigProps()</caption>
     * const props = getPConnect().resolveConfigProps({ label: `@P .FirstName` });
     *
     * @returns {object} resolved props.
     * @public
     */
    resolveConfigProps(configProps: any, destinationObject?: any): any;
    /**
     * Returns the resolved props from the provided input props and registers them to configuration object which are used for component rendering.
     * When you call the getConfigProps API, the resolved properties are retured.
     *
     * @function registerAdditionalProps
     * @example
     * Example:
     * additionalMeta = {
     *  label: "@P .FirstName"
     * }
     * output:
     * {
     *   label: "Hello Name"
     * }
     * @param {object} additionalMeta Props meant to be resolved.
     * @example <caption>getPConnect().registerAdditionalProps()</caption>
     * const props = getPConnect().registerAdditionalProps({ label: `@P .FirstName` });
     * the props variable will be an object with 'label' value is field value entered for FirstName field.
     * Also this prop ('label') is registered in component configuration for further usage in re-renders.
     * In this example, the API resolves the FirstName property, obtains the first name value, and registers it to label.
     *
     * @returns {object} resolved props.
     * @public
     */
    registerAdditionalProps(additionalMeta?: {}): any;
    /**
     * This API deregisters the input properties passed from metaConfig.
     * When you call the getConfigProps API, the deregistered properties are not obtained.
     *
     * @param {Array.<string | number>} deRegisterKeys The props that needs to be deregistered.
     * @function deRegisterAdditionalProps
     * @example <caption>getPConnect().deRegisterAdditionalProps()</caption>
     * getPConnect().deRegisterAdditionalProps(['label']);
     * @returns {boolean} Returns True after unregistering
     * @public
     *
     */
    deRegisterAdditionalProps(deRegisterKeys?: any[]): boolean;
    /**
     * Populates any additional properties which are specific to component which are not part of component configuration.
     *
     * @function populateAdditionalProps
     * @param {object} configData an object which has props from configuration props data, this objects get populated with new additional properties.
     * @example <caption>Usage: getPConnect().populateAdditionalProps({ label: 'label-name' })  </caption>
     * Example Usage:
     * const configProps = { label: 'label-name' }
     * getPConnect().populateAdditionalProps(configProps);
     *
     * After the above populateAdditionalProps function call, the configProps object value gets updated based on type of the component
     * all the possible keys added to the configObject are:
     * configObject.pageMessages (string) - page messages are added for case_view template.
     * configObject.validatemessage (string) - this key is added for components which are editable and when there is any validation message to be shown.
     * configObject.infoMessage (string) - same as above for editable component which has a warning message to be shown.
     * configObject.status (string) - "error" or "warning" string values.
     * configObject.httpMessages (string) - If there are any top (app) level HTTP messages to be displayed
     * configObject.caseMessages (string) - If there are any cases level messages to be shown.
     * configObject.stages (object) - contains a particular stage info.
     * configObject.fieldMetadata (object) - this object contains the information about the extra configuration which is configured in PRPC.
     *
     * @public
     */
    populateAdditionalProps(configData: any): void;
    populateFieldMetadata(configData: any): void;
    /**
     * Returns the field model (single model object (or) Array of model objects) (or) null.
     * field model is the information like class it belongs to, editValidate, useValidate, maxLength, etc which are configured on the field.
     * Model becomes an array if the field belongs to more than one class, otherwise we get only one object.
     *
     * @param {string} propertyName property (field) name without dot.
     * @returns {object | Array | null} { classID: 'class-1', type: "text"} | {{ classID: 'class-1', type: "text"}, { classID: 'class-1', type: "text", editValidate: 'funcName'}}
     * @example <caption>Usage of getFieldMetadata</caption>
     * Ex: const firstNameMetaData = getPConnect().getFieldMetadata('FirstName');
     *
     * firstNameMetaData will receive the configured information on the field while configuring it.
     *
     * @private
     */
    getFieldMetadata(propertyName: string): any;
    /**
     * Returns the current page meta data.
     *
     * @param {string} contextPageReference context page reference.
     * @returns {object | Array | null} { classID: 'class-1', type: "text"} | {{ classID: 'class-1', type: "text"}, { classID: 'class-1', type: "text", editValidate: 'funcName'}}
     * @example <caption>Usage of getCurrentPageFieldMetadata</caption>
     * Ex: const firstNameMetaData = getPConnect().getCurrentPageFieldMetadata();
     *
     * firstNameMetaData will receive the configured information on the page while configuring it.
     *
     * @private
     */
    getCurrentPageFieldMetadata(contextPageReference?: string | null): any;
    /**
     * Returns the current field classId
     * @returns { string } "class-name"
     * @function getCurrentClassID
     * @example <caption>Usage of getCurrentClassID</caption>
     * Ex: const firstNameClassId = getPConnect().getCurrentClassID();
     *
     * firstNameClassId will receive the class id corresponding to the field.
     *
     * @public
     */
    getCurrentClassID(): string;
    /**
     * Returns case summary and isCaseWideAction function consist of below structure
     * @function getCaseSummary
     * @example
     * {
     * routedTo:"user@constellation.com"
     * urgency:"10"
     * caseID:"OPB1HW-SPACETRA-WORK RA-219"
     * name:"Request approval"
     * caseClass:"OPB1HW-SpaceTra-Work-RequestApproval"
     * ID:"ASSIGN-WORKLIST OPB1HW-SPACETRA-WORK RA-219!REQUEST_FLOW_0"
     * isCaseWideAction
     * }
     *
     * isCaseWideAction() function returns true is the action is a case action else false
     */
    getCaseSummary(): any;
    /**
     * Returns referencedUsers in view with the below structure
     *
     * @function getReferencedUser
     * @param {string} userId is userIdentifier of a user.
     * {
     * "baipc": {
     *   "UserName": "Chandra"
     *  }
     * }
     */
    getReferencedUser(userId: string): any;
    /**
     * Returns case stages consist of below structure
     * @function getCaseStages
     * @example
     * {
     * ID: "PRIM1"
     * entryTime: "20200520T093921.867 GMT"
     * links: {,…}
     * name: "Collect Info"
     * type: "Primary"
     * visited_status: "active"
     * }
     */
    getCaseStages(): any;
    getStageID(): any;
    /**
     * Gets the actions object that is used to configure a component’s event actions.
     * @function getActions
     * @example <caption>Example for getActions()</caption>
     * Example usage - const actions = getPConnect().getActions(); return <Currency value={value} label={label} {...actions} />;
     * // the API provides the currency component’s action-set.
     *
     * @returns {object} actions configured
     */
    getActions(): any;
    /**
     * Returns true if this C11nEnv is the root
     * @returns {boolean} True is this is the root
     * @private
     */
    isRoot(): boolean | undefined;
    /**
     * Checks and resolves any context related info.
     * like, any errors for properties and any validation
     * info for this component.
     * @param {object} target target object to update the context.
     * @private
     */
    resolveContextProps(target: {
        error: string;
        validatemessage: string;
    }): void;
    /**
     * Checks whether validators configured for this
     * component or not.
     * @returns {boolean} true or false
     * @private
     */
    isValidatorExist(): boolean;
    /**
     * Obtains an entry point to the {@link ValidationApi} object that contains APIs that handle validations on the field.
     * @function getValidationApi
     * @returns {ValidationApi} entry point to the {@link ValidationApi}
     *
     * @example <caption> Example for getValidationApi() </caption>
     * const validationApi = pConn.getValidationApi();
     * @public
     */
    getValidationApi(): ValidationApi;
    /**
     * Checks whether a component is editable, relies on value attribute
     *
     * @function isEditable
     * @example <caption> Example for isEditable() </caption>
     * const isEditable = pConn.isEditable();
     * where isEditable is the boolean that contains true/false
     * In this example, the API checks if a component can be edited and returns the resulting boolean value.
     *
     * @returns {boolean} true or false
     */
    isEditable(): boolean;
    /**
     * This API checks if the current component has children.
     *
     * @function hasChildren
     * @example <caption> Example for hasChildren - getPConnect().hasChildren() </caption>
     * Usage: const componentHasChildren = getPConnect().hasChildren();
     * componentHasChildren will be true or false indicating whether current component has children in the component configuration.
     *
     * @returns {boolean} true or false
     * @public
     */
    hasChildren(): boolean;
    /**
     * Returns whether the node is visible && has some visible children
     * (if it is of a type which require children).
     * @returns {boolean} whether the node should be visible.
     */
    getComputedVisibility(): boolean;
    /**
     * Returns the children iterator
     * @returns {object} iterator
     * @private
     */
    getChildrenIterato(): any;
    /**
     * This API assigns a new action(based on the event type and handler)to the list of the actions
     * associated with the current component.
     *
     * @function setAction
     * @example <caption> Example for setAction() </caption>
     * Example usage - setAction("onChange", changeHandler);
     * // this API associates the change handler to the onChange event type, and assigns the new action to the list of the actions associated with the current component.
     *
     * @param {string} eventType The type of the event that determines the new action to be added to the list of actions.
     * @param {Function} handler The function that must be associated with the event type.
     *
     * @public
     */
    setAction(eventType: string, handler: Function): void;
    /**
     * Returns the component name example Button.
     *
     * @function getComponentName
     * @example <caption>getPConnect().getComponentName()</caption>
     * const component = getPConnect().getComponentName();
     *
     * @returns {string} current component name.
     */
    getComponentName(): string;
    /**
     * Checks whether current component is refreshable
     * or not.
     * Example:
     * If section is configured with refresh this section
     * then section will be treated as refreshable.
     * @returns {boolean} true or false
     * @private
     */
    isComponentRefreshable(): boolean;
    /**
     * this function helps to obtain the data of the current context from store.
     * Here `data` may contain below information
     *  <ul>
     *    <li>caseInfo</li>
     *    <li>pulse</li>
     *    <li>pxRequestor</li>
     *    <li>Data Pages</li>
     *    <li>...</li>
     *  </ul>
     *
     * @public
     * @function getDataObject
     * @param {string} contextName - qualified context name e.g. app/primary_1
     * @returns {object} data object
     *
     * @example <caption> Example for getDataObject() </caption>
     * const data = pConn.getDataObject();
     * const { caseInfo, pulse } = data;
     *
     */
    getDataObject(contextName?: string): any;
    /**
     * Returns the resolved image path, it resolves the image with current
     * static service.
     *
     * @function getImagePath
     * @example <caption>getPConnect().getImagePath(imageName)</caption>
     * const imagePath = getPConnect().getImagePath("launcher.png");
     *  // output: imagePath -> https://service/image/launcher.png
     * @param {string} imageName image name
     * @returns {string} image path
     */
    /**
     * @param {string} imageName image name
     */
    getImagePath(imageName: string): string;
    skipRequiredValidation(): boolean;
    isBulkAction(): boolean;
    /**
     * Returns list of children for the current component.
     * And also resets the iterator to start-index.
     *
     * @function getChildren
     * @example <caption>Example usage of getPConnect().getChildren()</caption>
     * const children = getPConnect().getChildren()
     * the children variable will be receiving the list of children components of the current component.
     *
     * @returns {object} returns the list of children
     * @public
     */
    getChildren(): any | null;
    /**
     * This API set inherited prop and propagates the prop to all its children.
     *
     * @function setInheritedProp
     * @example <caption>getPConnect().setInheritedProp("displayMode", "DETAILS")</caption>
     *
     * @param {propName} propName name of the prop eq., displayMode
     * @param {*} value value to be set ew., LEFT
     *
     * @returns {void}
     */
    setInheritedProp(propName: string, value: any): void;
    /**
     * This API returns locale reference rule name this environment object is referencing for the field values.
     *
     * @function getLocaleRuleName
     * @example <caption>getPConnect().getLocaleRuleName()</caption>
     * const localeRuleName = getPConnect().getLocaleRuleName();
     * //Returns "VEHICLE-!VIEW!VEHICLEDETAILS", if the current environment object corresponds to a view named VehicleDetails in Work- class.
     * //The above is the name of localization rule which is 1-1 mapped to a View named VehicleDetails
     *
     * @returns {string} Returns the locale reference rule name.
     */
    getLocaleRuleName(): string;
    /**
     * Returns the localized value for a string.
     *
     * @function getLocalizedValue
     * @example <caption>getPConnect().getLocalizedValue("First Name", "fields","WORK-!VIEW!CANDIDATEINFO")</caption>
     * If the localization store looks like below.
     *
     * {
     *     "WORK-!VIEW!CANDIDATEINFO" : {
     *          "fields" : {
     *              "First Name" : "Primeiro nome",
     *              "Last Name"  : "Último nome"
     *           }
     *      }
     * }
     * The API returns "Primeiro nome" for a rule  "WORK-!VIEW!CANDIDATEINFO".
     *
     * @param   {string} rawString      raw string
     * @param   {string} localePath     locale path
     * @param   {string} localeRuleKey  (optional)Rule Key in the localization store
     * @returns {string} returns the localized value.
     */
    getLocalizedValue(rawString: string, localePath?: string, localeRuleKey?: string): string;
    /**
     * Returns the localized value for a paragraph rule
     * @private
     * @function getLocalizedParagraphValue
     *
     * @param {string} paragraphRuleName name of the paragraph rule
     * @returns {string} content of the paragraph rule
     */
    getLocalizedParagraphValue(paragraphRuleName: string): any;
    /**
     * Returns the localeRuleName for the given Localization rule keys.
     *
     * @example <caption>const ruleKey = getPConnect().getLocaleRuleName("Work-", "View","CandidateInfo")</caption>
     * Here the ruleKey will be  "Work-!View!CandidateInfo"
     *
     * @param   {string} localeClass    Localization rule class
     * @param   {string} localeContext  Localization rule context
     * @param   {string} localeName     Localization rule name
     * @returns {string} localeRuleKey
     * @private
     */
    getLocaleRuleNameFromKeys(localeClass: string, localeContext: string, localeName: string): string;
    /**
     * this function helps to resolve the property value from the state (Redux store).
     * @function getValue
     * @param {string} prop property whose data value is returned
     * @param {string} pageReference pageReference of parent view
     * @returns {string} property value from the state (Redux store).
     *
     * @example <caption>Example for .firstName property </caption>
     * const firstName = getPConnect().getValue('.firstName');
     * // here firstName variable contains the value retrieved from redux store.
     */
    getValue(prop: string, pageReference?: string): any;
    setInheritedConfig(rawConfig: any): void;
    /**
     * This function is used to retrieve props that are set on the parent metadata node within
     * the inheritedProps metadata structure. The purpose of inheritedProps is to allow cascading
     * of values in view metadata.
     *
     * In the following example, a label can be given to a view reference node in order to give a
     * unique label each place a view is included, allowing for better reuse.
     *
     * @function getInheritedProps
     * @returns {object} props object that was inherited from the parent
     * @public
     *
     * @example <caption>Getting a label from parent reference</caption>
     * // Parent reference metadata
     * {
     *   "type": "reference",
     *   "config": {
     *     "name": "Address",
     *     "inheritedProps": [
     *       {
     *         "prop": "label",
     *         "value": "@L Shipping address"
     *       }
     *     ]
     *   }
     * }
     *
     * // Child reusable Address view
     * {
     *   "name": "Address",
     *   "type": "View",
     *   "config": {
     *     "template": "OneColumn",
     *     "ruleClass": "Data-Address"
     *     "label": "Generic address"
     *   },
     *   "children": [
     *     {
     *       "name": "A",
     *       "type": "Region",
     *       "children": []
     *     }
     *   ]
     * }
     *
     * // During render of the child view called Address, one would retrieve the inherited label as follows
     *
     * const propsToUse = { label, ...getPConnect().getInheritedProps() };
     *
     * // This would result in propsToUse.label = “Shipping address”. This inherits the value that was set on the
     * // parent (if the parent had a “label” property) and would override any “label” property that was set on the child view.
     */
    getInheritedProps(): {};
    /**
     * this function helps to assign the value to property name (or key) in state (Redux store).
     * @function setValue
     * @param {string} prop property name whose data value need to set
     * @param {string} value property value which need to get assigned to the property name.
     * @param {string} initialValue property initialValue which need to get assigned to the property name.
     * @param {boolean} isImplicit boolean check if it is implicit setValue action
     * @returns {void}
     *
     * @example <caption>Example for .firstName property </caption>
     * getPConnect().setValue('.firstName', 'lorem ipsum');
     * // here examples shows setting the `lorem ipsum` value in firstName property
     */
    setValue(prop: any, value: any, initialValue?: any, isImplicit?: boolean): void;
    /**
     * This function helps to update the value to property name in change list
     * @function updateDirtyCheckChangeList
     * @param {string} prop property name whose data value need to set
     * @param {string} value property value which need to get assigned to the property name
     * @returns {void}
     *
     * @example <caption>Example for .firstName property </caption>
     * getPConnect().updateDirtyCheckChangeList('.firstName', 'lorem ipsum');
     * // here examples shows setting the `lorem ipsum` value in firstName property
     * @private
     */
    updateDirtyCheckChangeList(prop: string, value: string): void;
    /**
     * Return context data value like when results etc.,
     * @example <caption>getPConnect().getContextDataValue(prop)</caption>
     * const value = getPConnect().getContextDataValue('.summary_of_when_conditions__.testWhen');
     *
     * @param {string} prop property whose context data value is returned
     * @param {string} pageReference pageReference of parent view
     * @returns {string} Context data value
     * @private
     */
    getContextDataValue(prop: string, pageReference?: string): any;
    /**
     * this function helps to merge data object in store deeply.
     * If an element at the same key is present in both store and data object,
     * the value from data object will stay in the store.
     *
     * @function updateState
     * @param {object} dataObject - object to be merged into store.
     *
     * @example <caption>Example usage to merge firstName key to store</caption>
     * getPConnect().updateState({
     *  firstName: "Test"
     * });
     */
    updateState(dataObject: any): void;
    /**
     * this function helps to replace the state of a property or page in the store.
     * @function replaceState
     * @param {string} prop property or page name whose value need to be replaced
     * @param {object} value  value which need to get assigned to the property or page.
     * @returns {void}
     *
     * @example <caption>Example for .address property </caption>
     * getPConnect().replaceState('.address', {
     *  apartment: "Nivee Heights"
     *  streetName: "Park Street",
     * });
     * @param {boolean} options.skipDirtyValidation - flag to decide whether the property has to considered in Dirty Validation. Default is false. If passed as true Dirty Validation will be skipped on the respected property.
     * @example <caption>Example for .address property will not be include in the response of formutils.getChanges() API </caption>
     * getPConnect().replaceState('.address', {
     *  apartment: "Nivee Heights"
     *  streetName: "Park Street",
     * }, {skipDirtyValidation: true });
     */
    replaceState(prop: string, value: string, options?: {
        skipDirtyValidation?: boolean;
    }): void;
    /**
     * this function helps to set error at Redux store level
     * so that the errors that need to be handled at infra level can make use of this function
     *
     * @public
     * @function reportError
     * @param {string} errorMsg - Error message to be logged to Redux store.
     * @param {object} errorObj - Error object that contains more error info.
     * @param {string} context - Context data value
     *
     * @example <caption>Example usage for reportError function</caption>
     * getPConnect().reportError(
     *    ': Error ocurred during ajax call at fetchMessages API :',
     *    {
     *      errorClassification: 'Invalid inputs'
     *      errorDetails: {
     *        localizedValue: 'localized error message'
     *      }
     *    }
     * );
     */
    reportError(errorMsg: any, errorObj: any, context?: string): void;
    /**
     * Returns the env object.
     * @returns {object} env object
     * @private
     */
    getComponent(): any;
    /**
     * This API creates a component whose type is provided as part of the meta object and uses the other parameters to resolve the properties and get the context.
     * The definition of the component type which is provided in meta object is upto consumer.
     * @param {object} componentMeta The metadata of the component to be created.
     * @param {string} dataSource The source reference to the Redux store. This contains properties that will be input to the created component.
     * @param {string} index In case of list datasource mention the index.
     * @param {object} additionalPropsToComp Props will be passed to component apart from the configured values.
     *
     * @function createComponent
     * @example <caption>Usage of createComponent: getPConnect().createComponent(meta, dataSource, index, additionalPropsToComp)</caption>
     * Ex: getPConnect().createComponent(
     *  {
     *    type: "Button",
     *    config: {
     *      label: "@P .FirstName"
     *    }
     *  },
     *  "D_Employees.pxResults",
     *  1,
     *  {
     *    active: true
     *  }
     * );
     *
     * Call the createComponent with meta data and necessary arguments, such that the component receives the resolved props to the created component instance.
     * For React: JSX: <Button label="resolved FirstName property value" /> (or) React.createElement('Button', { label: 'resolved FirstName property value })
     *
     * @returns {object} newly created component instance
     *
     * @public
     */
    createComponent(componentMeta: Meta, dataSource: string, index: number, additionalPropsToComp: any): any;
    /**
     * This API returns the viewMetadata of the referenced view
     * @function getReferencedView
     * @example <caption>
     * const meta = {
     *  meta: {
     *    type: 'reference',
     *    config: {
     *      type: 'view',
     *      name: 'Address'
     *    }
     *  }
     * }
     * const c11nEnv = createC11nEnv(meta).getPConnect();
     * const viewMetadata = c11nEnv.getReferencedView();
     * 'viewMetadata' is the metadata object of the 'Address' view
     * </caption>
     * @returns {object} referenced view metadata
     */
    getReferencedView(): Meta | undefined;
    /**
     * This API returns the PConnect object of the referenced view with in a reference
     * @param {boolean} passOptions this allows to pass reference's options to the view if it is true
     * @function getReferencedViewPConnect
     * @example <caption>const getPConnect = getPConnect().getReferencedViewPConnect().getPConnect</caption>
     * @returns {object} An PConnect object with getPConnect of the referenced view with in type reference
     *
     * @public
     */
    getReferencedViewPConnect(passOptions?: boolean): {
        getPConnect: () => C11nEnv;
    };
    /**
     * Returns an entry point to the Container Manager<br>
     * The Container Manager can be used to access any of the APIs found at {@link ContainerManager}
     * @function getContainerManager
     * @returns {ContainerManager} entry point to the {@link ContainerManager}
     * @example <caption>Example for getContainerManager()</caption>
     * const containerManager = getPConnect().getContainerManager();
     * //any of the container manager APIs can be called on the entry point returned
     */
    getContainerManager(): ContainerManager;
    /**
     * Returns an entry point to the Actions API. This entry point
     * can be used to access any of the APIs found at {@link ActionsApi}
     * @function getActionsApi
     * @example
     * Example usage:
     *   const actionsAPI = pConn.getActionsApi();
     * [...]
     *    actionsApi.showPage(actionInfo);
     *    actionsApi.createWork(actionInfo);
     *
     * where actionInfo is the JSON object that contains the information
     * necessary for the action to be properly invoked.
     *
     * @returns {ActionsApi} entry point to the {@link ActionsApi}
     */
    getActionsApi(): ActionsApi;
    /**
     * Returns the ActionManager object that can be used
     * to access the Core's ActionManager API
     * @returns {object} the {@link ActionManager} object
     * @private
     */
    getActionManager(): {
        getNextActionMgrId(): any;
        register(theActionMgrID: string, thePromise: Promise<any>, theResolve: any, theReject: any, theActionType?: string, actionConfig?: any, enableLoadingIndicator?: boolean): string;
        actionManagerPromise: (theActionType: any, theActionMgrID?: any) => {
            actionMgrID: any;
            promise: Promise<unknown>;
        };
        resolveActionByID(theActionMgrID: any, data?: any, allowDispatch?: boolean): any;
        rejectActionByID(theActionMgrID: any, allowDispatch?: boolean, error?: any): any;
    };
    /**
     * used in the Location component of the Nebula layer to obtain the API key
     * for the Google Maps applicationfrom the DSS setting(uiengine/map/googleapikey) and
     * send it to the MapsContext control of the Cosmos layer as a property
     * @function getGoogleMapsAPIKey
     * @returns {string} google maps api key
     * @example <caption>Example for getGoogleMapsAPIKey()</caption>
     * let apiKey = getPConnect().getGoogleMapsAPIKey();
     * // the API key to render Google Maps is obtained
     */
    getGoogleMapsAPIKey(): string;
    /**
     * used in the Richtext component of the Nebula layer to obtain the server url.
  
     * @function  getServerURL
     * @returns {string} server url
     * @example <caption>Example for getServerURL()</caption>
     * let serverurl = getPConnect().getServerURL();
     * // the server url is obtained
     */
    getServerURL(): any;
    /**
     * Returns the loading status of the current container context
     * @function getLoadingStatus
     * @param {string} contextName representing the context for which we need to fetch the loading status
     * @returns {boolean} true/false : Loading Status of the current container
     * @example <caption>Get the Loading status of the current context container</caption>
     * if(getPConnect().getLoadingStatus()==true){
     * //Code to handle the loading status
     * };
     * @private
     */
    getLoadingStatus(contextName: string): any;
    /**
     * The errorMsgConfig types defines a JSON configuration object used to specify error messages in the store.
     * It is used as a parameter to {@link clearErrorMessages} to indicate which messages should be cleared.
     *
     * @typedef errorMsgConfig
     * @type {object}
     * @property {string} category type of message that needs to be deleted (category types - HTTP (App or top level), PAGE (use this category for messages above the assignment))
     * @property {string} context on which messages needs to be cleared. Can be empty in which case error messages on app container are cleared.
     * @property {string} property name on which messages needs to be cleared.
     *
     * @example <caption>errorConfig to clear messages on a context</caption>
     * {category: "HTTP", context: "app/primary"}
     * This will clear the error messages at the "app/primary" level which belong to category of type HTTP (like 4XX errors).
     *
     * @example <caption>errorConfig to clear messages on AppShell</caption>
     * {category: "HTTP"}
     * This will clear the error messages at the App level which belongs to category HTTP.
     *
     * @example <caption>errorConfig to clearing messages on FirstName property</caption>
     * {property: ".firstName"}
     * This will clear the error messages related to the property: firstName.
     */
    /**
     * Deletes the error messages associated with a specific context (like an assignment, case flow) or App container.
     * @function clearErrorMessages
     * @param {errorMsgConfig} errorMsgConfig The {@link errorMsgConfig} object contains information that specifies which error messages are cleared
     *
     * @example <caption>Example for clearing messages on a context</caption>
     * getPConnect().clearErrorMessages({category: "HTTP", context: "app/primary"});
     * This will clear the error messages at the "app/primary" level which belong to category of type HTTP (like 4XX errors).
     *
     * @example <caption>Example for clearing messages on AppShell</caption>
     * getPConnect().clearErrorMessages({category: "HTTP"});
     * This will clear the error messages at the App level which belongs to category HTTP.
     *
     * @example <caption>Example for clearing messages on FirstName property</caption>
     * getPConnect().clearErrorMessages({property: ".firstName"});
     * This will clear the error messages on the property firstName.
     *
     * @public
     */
    clearErrorMessages(errorMsgConfig: any): void;
    resolveDatasourceReference(datasourceRef: string): any;
    /**
     * Removes the field from form map
     * @function removeFormField
     *
     * @example <caption>Example for clearing form on a context</caption>
     * getPConnect().removeFormField();
     * This will clear the form in the current context.
     *
     * @private
     */
    removeFormField(): void;
    /**
     * Adds the field from form map
     * @private
     */
    addFormField(): void;
    /**
     * This api is used to set the given page value to the given target
     * @param {object} sourcePage source page
     * @param {string} target target property name
     * @example <caption></caption>
     * const dataReferncePConn = getPConnect();
     * dataReferncePConn.setPageValue({street: 'ABC', city: 'DEF'}, '.EmbeddedPage');
     */
    setPageValue(sourcePage: any, target: any): void;
    /**
     * Accepts the value stored in the Suggestions Context for a field.
     * @param {string} target (optional) The field whose value stored in the Suggestions Context is accepted.
     * @function acceptSuggestion
     * @example <caption>Example for acceptSuggestion</caption>
     * In this example, the API accepts the value stored in the Suggestions Context for the Property1 field.
     * getPConnect().acceptSuggestion('.Proerty1');
     * @public
     */
    acceptSuggestion(target: string): void;
    /**
     * Ignores the value stored in the Suggestions Context for a field.
     * @param {string} target (optional) The field whose value stored in the Suggestions Context is ignored.
     * @function ignoreSuggestion
     *
     * @example <caption>Example for ignoreSuggestion</caption>
     * In this example, the API ignores the value stored in the Suggestions Context for the Property1 field.
     * getPConnect().ignoreSuggestion('.Proerty1');
     * @public
     */
    ignoreSuggestion(target: string): void;
}
export declare function createC11nEnv(config: Config): {
    getPConnect: () => C11nEnv;
};
export declare function registerComponentCreator(creator: Function): void;


export default C11nEnv;