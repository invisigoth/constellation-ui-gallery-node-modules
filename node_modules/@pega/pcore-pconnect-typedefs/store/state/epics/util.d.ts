export declare const SCOPE_TYPES: {
    PAGE: string;
    FORM: string;
};
export declare const processHeaders: (responseHeaders: any, caseClassName?: string, optionalHeaders?: any) => any;
/**
 * This function converts Object string in path to array path for lodash unset
 * @param {string} string path to be converted
 * @returns {string} converted string
 */
export declare const convertLiteralKey: (str: string) => string;
/**
 * This function return form data for a given context
 * @param {string} context context of form
 * @param {object} options optional details like onlyChangedData
 * @param {boolean} options.onlyChangedData if true, getSubmitData returns only edited fields data from the form
 * @param {boolean} options.nonEmptyAndChangedData if true, getSubmitData returns pre-populated nonEmpty data and data edited by the user
 * @param {boolean} options.skipUUID [options.skipUUID=true] if true, returns pageInstructions by deleting the UUID property from content (currently it is - "EmbedListUUID__")
 * @returns {*} form data
 */
export declare const getSubmitData: (context: string, options?: any) => any;
export declare const getActionPayload: (translatedDXAPIResponse: any, commonInfo: any) => any;
export declare const processViewResponse: (translatedDXAPIResponse: {
    directUrlUpdation?: boolean;
    semanticURL?: any;
}, actionConfig: {}, options: {
    acName?: any;
    context?: any;
    target?: any;
    containerName?: any;
    containerItemID?: any;
} | undefined, isSemanticURLAssociatedWithActivateContainer?: boolean, skipParseResponse?: boolean) => Promise<void>;
/**
 * this function returns the work id from the insKey
 * @private
 * @function getIdFromInsKey
 * @param {string} insKey
 * @returns {string}
 * @static
 *
 * @example  <caption>Example for getIdFromInsKey.</caption>
 * getIdFromInsKey('ASSIGN-WORKLIST ON8TTL-C11NGALL-WORK C-5028!DETAILS_FLOW');
 * example will return C-5028
 */
export declare const getIdFromInsKey: (insKey: string) => string;
/**
 * this function returns the work id from the insKey
 * @private
 * @function getWorkIDFromInsKey
 * @param {string} insKey inskey
 * @returns {string}    case id
 * @static
 *
 * @example  <caption>Example for getIdFromInsKey.</caption>
 * getIdFromInsKey('ASSIGN-WORKLIST ON8TTL-C11NGALL-WORK C-5028!DETAILS_FLOW');
 * example will return v
 */
export declare const getWorkIDFromInsKey: (insKey?: string) => string;
/**
 * this function returns the assignment key and flow name from insKey
 * @private
 * @function getKeyAndFlowName
 * @param {string} insKey inskey
 * @returns {object} key and flow name of case
 * @static
 *
 * @example  <caption>Example for getKeyAndFlowName.</caption>
 * getKeyAndFlowName('ASSIGN-WORKLIST ON8TTL-C11NGALL-WORK C-5028!DETAILS_FLOW');
 * example will return
 * {
 *  key: 'ASSIGN-WORKLIST ON8TTL-C11NGALL-WORK C-5028',
 *  flowName: DETAILS_FLOW
 * }
 */
export declare const getKeyAndFlowName: (insKey: string | undefined) => {
    key: string;
    flowName: string;
} | {
    key?: undefined;
    flowName?: undefined;
};
/**
 * this function returns if the container item needs to be replaced
 * @private
 * @function shouldReplaceActiveItem
 * @param {string} currentKey current item key
 * @param {string} target target container
 * @returns {boolean} returns true if container item needs to be replaced, otherwise returns false
 * @static
 *
 * @example  <caption>Example for getKeyAndFlowName.</caption>
 * shouldReplaceActiveItem('ON8TTL-C11NGALL-WORK C-5028', 'app/primary_1/workarea');
 */
export declare const shouldReplaceActiveItem: (currentKey: any, target: any) => boolean;
/**
 * Process the Error response and separate out field level errors, page level errors & (@TODO)app level errors,
 * @param {Array} error error content
 * @param {Array} formFields
 * ErroneousInputOutputIdentifier --> field which has error
 * ErroneousInputOutputFieldInPage --> Decides whether it is page level or field level error.
 */
export declare const processErrorResponse: (error: any[], formFields: any) => {
    fieldErrors: never[];
    pageErrors: never[];
};
export declare const processDataToDispatchErrorAction: (data: {
    payload?: any;
}) => any;
export declare const getActionBasedOnContainerMode: (target: string | null, payload: any) => any;
export declare const getContext: (target: string | null, containerName: string, context?: string, options?: any) => any;
export declare const isAddContainerAction: (action: {
    type: string;
}) => boolean;
export declare const areChildContextsInDirtyState: (parentContainerItemID: any) => boolean;
/**
* This function will help to get dirty details of target passed and checks for dirty based on container type
* -- if container type is single - it checks whether active container is in dirty state or not. If dirty it prompts a window confirmation
*    based on user action, continueExecution will be set.
* -- if container type is multiple - it checks whether container limit has reached or not.
*        a) if container limit is not reached then continueExecution will be true.
*        b) if container limit is reached and found non dirty container then continueExecution will be true and removeActionPayload contains
                the containerItem details which need to be rmeoved.
*        c) if container limit is reached and all are dirty containers then continueExecution will be false and
*              window alert will be shown on UI.
* @param {string} target - target container e.g. app/primary
* @param {object} options - additional information for proccessing logic. e.g. showConfirmDialogForMaxDocumentLimitReached
* @returns {object} - object contains below details
                        1) continueExecution (boolean type) - a) true indicates to continue execution
                                                            - b) false indicates to stop further execution
                        2) removeActionPayload (object) - will have details related to container which need to be removed.

  @private
*/
export declare const getDirtyDetails: (target: string | null, options?: any) => {
    continueExecution: boolean;
    removeActionPayload: any;
};
/**
* This function will help to get activation details of item based on config details (PAGE or ASSIGNMENT)
* @param {string} type - PAGE or ASSIGNMENT
* @param {string} target - target container e.g. app/primary
* @param {object} config - contains information related to PAGE or ASSIGNMENT e.g. semanticURL, inskey
* @returns {object} - object contains below details
                        1) activate (boolean type) - a) true indicates if ITEM is already present
                                                   - b) false indicates if ITEM is not present
                        2) activateContainerActionPayload (object) - will have details related to container in which ITEM is present

  @private
*/
export declare const getActivationDetails: (type: string, target: string, config: any) => {
    activate?: undefined;
    activateContainerActionPayload?: undefined;
} | {
    activate: boolean;
    activateContainerActionPayload: {
        target: string;
        containerItemID: string;
        semanticURL: any;
    };
};
/**
* This function is used to perform resetContainers as a batch action
* @returns {object} - returns a action object with type "RESET_CONTAINER"
  @private
*/
export declare const performResetContainer: () => any;
/**
 * This function is used to perform merge content of current container to target inside taregt.data.caseinfo
 * @param {object} target - target object
 * @param {object} containerInfo - target object to be merged
 * @returns {object} - returns merged object
 * @private
 */
export declare const mergeCurrentModalContentToTarget: (target: {
    data: {
        caseInfo: {
            content: any;
        };
    };
}, containerInfo: {
    caseInfo: {
        content: any;
    };
}) => {
    data: {
        caseInfo: {
            content: any;
        };
    };
};
/**
 * This function will return the resetContainer Action if we have any Preview Containers Exist else return null
 * @param {Array} theReturn - An array which contains all the actions which needs to be dispatched.
 * @private
 */
export declare const addPreviewResetAction: (theReturn?: any) => void;
/**
 * This function will return the resourcetype (i.e PAGE or CASE or ASSIGNMENT) based on the routeKey of the url
 * @param {string} routeKey - routeKey associated with the url.
 * @returns {string} - type of resource i.e PAGE or CASE or ASSIGNMENT
 * @private
 */
export declare const getResourceType: (routeKey: string) => any;
export declare const addActionsToParentContext: (childPayload: {
    data?: {} | undefined;
    context: any;
    caseViewMode: any;
}, reduxActions: any[]) => void;
export declare const dispatchCorrectActionIfChildOrRemote: (theReturn: any[]) => void;
export declare const getUpdatedPayloadBasedOnResourceType: (resourceType: string | undefined, data: {
    caseInfo: {
        assignments: {
            ID: any;
        }[];
        ID: any;
    };
    semanticURL: any;
}, payload: any) => any;
/**
 * This function merges Objects and concats Arrays
 * @example
 * let object = { a: [{ b: 2 }], d: { x: 2 } };
 * let other = { a: [{ c: 3 }], d: { y: 3 } };
 * mergeObjectsAndConcatArrays(object, other) = { a: [{ b: 2 }, { c: 3 }], d: { x: 2, y: 3 } };
 */
export declare const mergeObjectsAndConcatArrays: (originalObj: {}, newObj: {}) => any;
export declare const getParentContextChangeSet: (context: any) => {};
