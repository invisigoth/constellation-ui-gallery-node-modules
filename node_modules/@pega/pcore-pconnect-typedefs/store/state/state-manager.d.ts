export declare const getReferenceTokens: (string: any) => any;
/**
 * this function sets storeIn to store object
 *
 * @param {*} storeIn -- store object
 */
export declare const setStore: (storeIn: any) => void;
/**
 * this function returns store object
 *
 * @returns {*} returns store
 */
export declare const getStore: () => any;
/**
 * this function is wrapper around redux dispatch function and dispatches the action object over store
 *
 * @param {*} action -- action object
 */
export declare const dispatch: (action: any) => void;
/**
 * this function will help to provide context data for the given context
 *
 * @param {string} context -- context name
 * @returns {*} returns -- State Object for the given Context
 */
export declare const getDataObject: (context: any) => any;
/**
 * This function returns the shared (readonly) data pages from store
 * @public
 * @function getSharedDataObject
 * @returns {object} shared data object
 * @example <caption> Example for getSharedDataObject() </caption>
 * const sharedData = pConnn.getSharedDataObject();
 */
export declare const getSharedDataObject: () => any;
/**
 * this function will help to get value of the prop from state
 *
 * @param {string} propReference property reference e.g. .FirstName or pyWorkPage.FirstName
 * @param {string} pageReference page reference e.g. .pyWorkPage, D_Accounts.pxResults(1)
 * @param {string} context context of the property
 * @returns {*} returns -- value of the prop
 */
export declare const getValue: (propReference: any, pageReference: any, context: any) => any;
export declare const getContextValue: (path: any, prop: any, context: any) => any;
export declare const lookupContextValue: (path: any, prop: any, context: any) => any;
export declare const getActionType: (options: any) => "UPDATE_DOCUMENT" | "ADD_CONTAINER_ITEM";
/**
 * this function helps to remove ref path in state object
 *
 * @param {*} state -- State object
 * @param {*} fullReference -- full reference of nested structure in state object
 * @returns {*} returns -- updated state object
 */
export declare const removeItem: (state: any, fullReference: any) => boolean;
export declare const isMergeable: (obj: any) => boolean;
export declare const mergeDeep: (originalData: any, newObjectData: any, mergeOptions?: {}) => any;
/**
 * this function helps to update value in state object that has sent in corresponding reference
 *
 * @param {*} state -- State object
 * @param {*} fullReference -- full reference of nested structure in state object
 * @param {*} value -- value to update in reference path
 * @param {object} options -- javascript object containing optional parameters like isArrayDeepMerge etc.
 * @param {boolean} options.isArrayDeepMerge - flag to decide whether to deep merge the objects or values inside array or not
 * @returns {*} returns -- updated state object
 */
export declare const updateValue: (state: any, fullReference: any, value: any, options?: {}) => any;
/**
 * this function helps to replace value in state object that has sent in corresponding reference
 *
 * @param {*} state -- State object
 * @param {*} fullReference -- full reference of nested structure in state object
 * @param {*} value -- value to update in reference path
 * @returns {*} returns -- updated state object
 */
export declare const replaceValue: (state: any, fullReference: any, value: any) => any;
/**
 * Reset the Store to its initial state. <strong>Note: This is typically only
 * used by Mashups when they are exiting out of their flow and want
 * to leave the Store in a state that is initialized for the next use.
 * On the initial loading of the app, the store is automatically
 * initialized.
 * @function
 * @private
 * @returns {object} object with actionMgrID and promise keys: { actionMgrID: <theID>, promise: <thePromise> }
 *
 * @example <caption>Example for resetStore()</caption>
 * const store = PCore.resetStore();
 */
export declare const resetStore: () => Promise<unknown>;
