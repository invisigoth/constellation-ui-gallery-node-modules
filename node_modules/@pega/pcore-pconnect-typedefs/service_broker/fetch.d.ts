import FetchStatus from './fetchStatus';
export declare const UPDATE_SESSION = "updateSession";
export declare const setInterceptor: (interceptorObj: Function) => void;
/**
 * @typedef {object} Config
 * @property {string} method request method(GET, POST, PUT, PATCH, DELETE) to be used when making the request. Default is 'GET'
 * @property {object} headers custom headers to be sent
 * @property {object} body data to be sent as the request body. Only applicable for request methods 'PUT', 'POST', and 'PATCH'
 * @property {number} timeout number of milliseconds before the request times out. Default is '0' (no timeout)
 * @property {boolean} withCredentials indicates whether or not cross-site Access-Control requests. Default is 'false'
 * @property {boolean} withoutDefaultHeaders indicates whether or not to send default headers. Default is 'false'
 * @property {Function} onUploadProgress allows handling of progress events for uploads
 * @property {Function} onDownloadProgress allows handling of progress events for downloads
 * @property {object} signal represents a signal object that allows you to communicate with a fetch request to abort.
 */
/**
 * Seeks url and supporting configuration object for the request to be made.
 * If url is null or undefined, logging a console error.
 * Merge headers passed in config object with the default headers that service broker maintain.
 * Call axios with the prepared config object
 *
 * @param {string} url endpoint url
 * @param {Config} config {@link Config} object which supports additional data for network call
 * @param {*} context context object
 * @param {object} options - Optional, object containing extra parameter like doNotMergeHttpMessagesForStatusCode and cancelContext.
 * @param {string} options.doNotMergeHttpMessagesForStatusCode contains error status code - used to stop merging the error messsages
 * @param {string} options.cancelContext contains unique context string
 * @returns {*} returns the promise object returned by axios
 * @example fetch('http://www.domain.com/employees', {method: 'GET'})
 */
export declare const fetch: (url: string, config: any, context?: any, options?: {
    doNotMergeHttpMessagesForStatusCode?: string | null;
    cancelContext?: string;
    includeRemoteSystemIdIfPresent?: boolean;
}) => any;
export declare const waitForUpdateSession: (url: string, config: any, context: any, fetchStatus: FetchStatus) => Promise<unknown>;
/**
 * this function returns number of active request for the given context
 *
 * @param {*} context context object for which the number of active request count is required
 * @returns {number} returns number of active request for the given context
 */
export declare const getActiveRequestCountPerContext: (context: any) => number;
/**
 * returns the axios cancelToken source object
 *
 * @returns {*} returns the axios cancelToken source object
 *
 */
export declare const getCancelTokenSource: () => {
    [source: string]: any;
};
/**
 * when promise is rejected, this function helps to check if it's because the request was cancelled
 *
 * @param {*} error error object when promise rejects
 * @returns {boolean} returns true/false by calling axios.isCancel for given error object
 */
export declare const isFetchCanceled: (error: any) => boolean;
export declare const updateHeaders: (headersObj: {
    Authorization: string | null;
}) => void;
export declare const updateAuthInfo: (authInfo: {
    tokenInfo?: any;
}) => void;
export declare const updateAuthConfig: (config: {}) => void;
export declare const getAuthConfig: () => {};
export declare const getAuthInfo: () => any;
export declare const resetFetchStatus: () => void;
