import { RoutingInfoObj } from './types';
/**
 * @file Implements parsing logic for Application Routing Table
 * @author WebWiz Team <WebWizDevelopmentTeam@pega.com>
 */
/**
 * RouteParser
 * This class consist of methods required for parsing App Routing Table
 */
declare class RouteParser {
    private routingInfo;
    private appRoutes;
    private appRoutesMeta;
    private appName?;
    private appAlias?;
    private orgName?;
    private reqContextName;
    private reqServletPath?;
    private defaultViewUrlPath;
    private readonly staticRoutesList?;
    private readonly dynamicRoutesList?;
    private appDelimeter?;
    private reqServletNameReal?;
    private bDefaultPortal?;
    private portalName;
    private ignoreFromEndPoint?;
    /**
     * Creates an instance of RouteParser.
     * @memberof RouteParser
     */
    constructor();
    /**
     * This method initializes instance variables of Class
     * @function init
     * @param {*} routingInfo - Application Routing Table Information
     * @param {string} defaultViewUrlPath - url path of default view
     */
    init: (routingInfo: any, defaultViewUrlPath: string) => void;
    /**
     * This method merges new routes to the existing routing table
     * @param {*} routingInfo - new route entries with route and routeMeta
     */
    addRoutes: (routingInfo: any) => void;
    setDefaultRoute: (defaultRoute: string) => void;
    /**
     * this method separates static routes and dyamic routes of App Routing Table,
     * in two different arrays
     * @function _createStaticDynamicRoutesList
     * @param {*} routesObj - routingInfo.routes
     */
    _createStaticDynamicRoutesList: (routesObj: {
        [key: string]: any;
    }) => void;
    /**
     * this method returns key name after removing curly braces
     * @function _getDynamicKeyName
     * @param { string } dynamicKey - dynamic key
     * @returns {string} key name after removing curly braces
     */
    _getDynamicKeyName: (dynamicKey: string) => string;
    /**
     * this method returns true if constellation portal is default portal
     * @function isDefaultPortal
     * @returns {boolean} returns isDefaultPortal
     */
    isDefaultPortal: () => boolean;
    /**
     * this method returns constellation portal Name
     * @function getPortalName
     * returns portalName
     */
    getPortalName: () => string;
    /**
     * this method returns application Path
     * @function getApplicationPath
     * @returns {string} returns applicationPath
     */
    getApplicationPath: () => string;
    /**
     * this method returns application Name
     * @function getReqServletNameReal
     * @returns {string} returns reqServletNameReal
     */
    getReqServletNameReal: () => string;
    /**
     * this method returns application Name
     * @function getAppDelimeter
     * @returns {string} returns appDelimeter
     */
    getAppDelimeter: () => string;
    /**
     * this method returns application Name
     * @function getApplicationName
     * @returns {string} returns applicationName
     */
    getApplicationName: () => string;
    getApplicationAlias: () => string;
    getServletPath: () => string;
    /**
     * this method returns application Name
     * @function getApplicationName
     * @returns {string} returns applicationName
     */
    getOrganizationName: () => string;
    /**
     * this method returns reqContextName(prweb)
     * @function getReqContextName
     * @returns {string} returns reqContextName
     */
    getReqContextName: () => string;
    getRoutingInfo: () => any;
    /**
     * this method returns processed semantic url
     * @function processUrl
     * @param {*} semanticURL - semantic url
     * @param {boolean} convertCase - convert case of semantic url?
     * @returns {string} - processed semantic url
     */
    processUrl: (semanticURL: string, convertCase: boolean) => string;
    /**
     * this method returns endpoint and payload corresponding to semantic url
     * @function getEndPointInfo
     * @param {*} semanticURLParam - semantic url
     * @returns {*} - resolved route corresponding to semantic url
     */
    getEndPointInfo: (semanticURLParam: any) => any;
    /**
     * Get semantic url for given routeKey (ex: showView)
     * @function getSemanticURL
     * @param {*} routeKey - routeKey
     * @param {*} payload - payload
     * @param {*} queryParameters - queryParameters
     * @returns {*} semantic url or empty string
     */
    getSemanticURL(routeKey: string, payload: any, queryParameters: any): string;
    /**
     * Get resolved semantic url for given routeKey (example: openWorkByHandle)
     * @function getResolvedSemanticURL
     * @param {string} routeKey - routeKey - This will be actionType : openWorkByHandle
     * @param {object} payload - payload to match
     * @param {object} params - dynamic param values
     * @returns {string} resolved semantic url or empty string
     */
    getResolvedSemanticURL(routeKey: string, payload: any, params?: {
        [key: string]: string;
    }): string;
    /**
     * Build semantic url for given routeKey (ex: showView)
     * @function _buildSemanticURL
     * @param {string} routeKey - routeKey
     * @param {object} payload - payload
     * @param {object} queryParameters - queryParameters object
     * @returns {string} semantic url or empty string
     */
    _buildSemanticURL(routeKey: string, payload: any, queryParameters: any): string;
    /**
     * Resolves and return the dynamic parameters of queryParameter string
     * @param {string} url - url
     * @param {object} queryParameters - queryParameters object
     * @param {boolean} ignoreCase - Flag to resolve the query parameters ignoring the case
     * @returns {string} - Returns the url with resolved dynamic query parameters
     */
    _getQueryParamsResolvedURL(url: string, queryParameters: any, ignoreCase?: boolean): string;
    _getQueryParamsObject(queryParameters: any): {
        [key: string]: any;
    };
    /**
     * Get restApi for given routeKey (ex: showView)
     * @function getRestEndPoint
     * @param {*} routeKey - routeKey
     * @param {*} payload - payload
     * @returns {*} restApi and reqType. Throws an error for invalid routeKey
     */
    getRestEndPoint(routeKey: string, payload?: any): RoutingInfoObj;
    /**
     * Build restApi for given routeKey (ex: showView)
     * @function _buildRestApi
     * @param {*} routeKey - routeKey
     * @param {*} payload - payload
     * @returns {*} restApi and reqType. Throws an error for invalid routeKey
     */
    _buildRestApi(routeKey: string, payload: any): RoutingInfoObj;
    _isSpecialInstruction(key: string): boolean;
    _processInstruction(instruction: string, keys: [string], payload: any): {
        [key: string]: string;
    };
    /**
     * Detects if a restApi exists with the given routeKey
     * @function doesRestApiExist
     * @param {string} routeKey - routeKey
     * @returns {boolean} Flag indicating whether the Api exists
     */
    doesRestApiExist(routeKey: string): boolean;
    /**
     * Resolve Dynamic Fragments from Endpoint and Payload
     * @function _resolveRoute
     * @param {*} routingInfo - routing table entry
     * @param {*} semanticURL - semantic url
     * @param {*} matchedRoute - matched route pattern
     * @returns {*} Resolved route
     */
    _resolveRoute: (routingInfo: any, semanticURL: string, matchedRoute: string) => any;
    /**
     * Process the RouteEndPoint inside JSON and remove dynamic params
     * @function _resolveRouteEndPoint
     * @param {*} routingInfo - routing table entry
     * @param {string} matchedRoute - matched route pattern
     * @returns {*} Resolved route
     */
    _resolveRouteEndPoint: (routingInfo: any, matchedRoute: string) => any;
    /**
     * Process the replacePayload inside JSON and remove dynamic params
     * @function _resolvePayload
     * @param {*} routingInfo - routing table entry
     * @param {*} tokensMap - key-value pair: key(Dynamic Param in Matched Route), value(corresponding semantic url token)
     * @param {string} matchedRoute - matched route pattern
     * @returns {*} Resolved routing table entry
     */
    _resolvePayload: (routingInfo: any, tokensMap: any, matchedRoute: string) => any;
    _resolvePayloadRecursive(payload: any, tokensMap: any): {
        [key: string]: any;
    };
    /**
     * this method returns route in App Routing Table corresponding to semantic Url
     * @function _getMatchedRouteInRoutingTable
     * @param {*} semanticURL - semantic url
     * @returns {*} matched route or undefined
     */
    _getMatchedRouteInRoutingTable: (semanticURL: string) => string;
    /**
     * this method returns static route if it matches semantic Url,otherwise returns undefined
     * @function _findMatchedRouteInStaticList
     * @param {*} semanticURL - semantic url
     * @returns {*} static route or undefined
     */
    _findMatchedRouteInStaticList: (semanticURL: string) => string;
    /**
     * this method returns dynamic route corresponding to semantic Url, otherwise returns undefined
     * @function _findMatchedRouteInDynamicList
     * @param {*} semanticURL - semantic url
     * @returns {*} dynamic route or undefined
     */
    _findMatchedRouteInDynamicList: (semanticURL: string) => string;
    /**
     * this method send warning and error messages to console
     * @function _sendWarningAndErrorMessages
     * @param {*} message - message
     * @param {*} additionalInfo - additional information to be logged in console
     */
    _sendWarningAndErrorMessages: (message: any, additionalInfo?: any) => void;
}
declare const appRouteParser: RouteParser;
export default appRouteParser;
