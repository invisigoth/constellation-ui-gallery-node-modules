/**
 * helper functions
 */
declare class Utils {
    /**
     * Merges all source properties to target and returns the target object
     * @param {*} source object to be merged
     * @param {*} target target object
     */
    static mergeDeep(source: any, target: any): any;
    static getIn(sourceObject: any, refPath: any, defaultValue?: any): any;
    static setIn(sourceObject: any, refPath: any, objectToSet: any): any;
    static deleteIn(sourceObject: any, refPath: any): boolean;
    /**
     * Checks wether obj is empty or not.
     * @param {*} obj input obj
     */
    static isObjectEmpty(obj: any): boolean;
    /**
     * Checks if value is an empty object, collection, map, or set.
     * @param {*} value input value
     */
    static isEmpty(value: any): any;
    /**
     * Clones passed object.
     * @param {object} obj object to clone
     */
    static deepClone(obj?: {}): any;
    /**
     * Copies the source object to target object
     * it is a shallow copy.
     * @param {object} source source to copy
     * @param {object} target target
     */
    static copy(source: any, target: any): void;
    /**
     * Checks wether reference is valid property
     * reference or not.
     * @param {*} ref  property string to check
     */
    static isPropertyRef(ref: any): boolean;
    /**
     * Checks whether when is configured in the component or not.
     * @param {*} config component metadata
     */
    static isWhenExist(config: any): boolean;
    /**
     * Helper function to check whether expression is configured
     * in the component or not.
     * @param {*} config component metadata
     */
    static isExpressionExist(config: any): boolean;
    static buildDataObject(dataObject: any, context: any): {};
    /**
     * Builds form submit object. Object will be
     * in json format.
     * @param {*} propRef property reference
     * @param {*} resultObj json object
     * @param {*} value value to update to property.
     */
    static buildObject: (propRef: any, resultObj: any, value: any) => void;
    /**
     * get hashed crc32 string
     * @param {string} value string to be hashed
     * @returns {string} hashed string
     */
    static getHashedString(value: any): any;
    /**
     * extract the property name
     * @param {string} value string from which name to be extracted
     * @returns {string} returns the property name without @P
     * @example <caption>Example for getPropertyName(value)</caption>
     * getPropertyName("@P .prop1")
     * this will return "prop1"
     */
    static getPropertyName(value: any): any;
    /**
     * extract the property name
     * @param {string} dependency string/object from which name to be extracted
     * @returns {string} returns the property name
     * @example <caption>Example for getPropertyNameFromDependency(value)</caption>
     * getPropertyNameFromDependency({
        mode: 'multiRecord',
        propertyName: 'caseInfo.content.PartnerOffering.ProductAreas[0].PegaProdMulti'
      })
     * this will return "caseInfo.content.PartnerOffering.ProductAreas[0].PegaProdMulti"
     */
    static getPropertyNameFromDependency(dependency: any): any;
    /**
     * This method will check whether the supplied jsonstring is valid Json after parsed.
     * @param {string} jsonstring - string which results a Valid JSON
     * @returns {object|boolean} this will return false if the supplied string is not valid json string else return
     * the parsed JSON Object
     */
    static isValidJson(jsonstring: any): any;
    /**
     * Compares 2 objects for euqality.
     * It does deep comparation.
     * @param {object} object1 object 1 to be compared
     * @param {object} object2 object 2 compare against
     */
    static isEqual(object1: any, object2: any): boolean;
    /**
     * Removes property from existingDependentPropertiesSet.
     * It does deep comparation.
     * @param {object} existingDependentPropertiesSet set containing existing properties
     * @param {string} propertyName property name that needs to be removed
     */
    static removeExistingDependentProperty(existingDependentPropertiesSet: any, propertyName: any): void;
    static getFullPropertyReference(splittedPropertyArray: any): string;
    /**
     * Iterates over the object and calls the callback on reaching
     * to the leaf of object with two parameters - path and value,
     * where path value will be array such as ['root', 'branch', 'leaf'] and value can be of any type
     * @function iterateLeafNodes
     * @param {object} sourceObj object to iterate
     * @param {Function} callback function which will be executed on reaching leaf node
     * @returns {void}
     * @example <caption>Example for iterateLeafNodes</caption>
     * const data = {Name: 'James Bond', department: {id: '007', type: 'agent'}};
     * iterateLeafNodes(data, (path, value) => {
          if (path.pop() === 'Name' && value === 'James Bond') {
            sendOnMission(value);
          }
        });
     */
    static iterateLeafNodes(sourceObj: any, callback: any): void;
    /**
     * Resolves string boolean values of config object properties to boolean values
     * @param {object} configObject config props object of a component
     * @private
     * @returns {object} configObject of a component
     */
    static resolveStringBooleans(configObject: any): any;
    /**
     * API to generate UUID
     * @returns {string} a unqiue Id
     */
    static generateUniqueID(): any;
    static unflatten(data: any): {};
    static flatten(data: any, path: string, resultObj: any): void;
    static buildInstructionPageReference(pageReference: any, property: any): string;
    static buildAttachmentsFormData(attachmentsArray?: any[]): ({
        type: string;
        attachmentFieldName: any;
        delete: boolean;
        pzInsKey: string;
        category?: undefined;
        ID?: undefined;
        clientFileID?: undefined;
    } | {
        type: string;
        attachmentFieldName: any;
        category: any;
        ID: any;
        clientFileID: any;
        delete?: undefined;
        pzInsKey?: undefined;
    })[];
    /**
     * [convertPageRefToInterestPage]
     * Description : Converts pageReference to clipboardpage notation
     * @param   {string}    pageReference      pageReference
     * @returns {string}    pageReference to interestPage format
     *  @example <caption>Example for convertPageRefToInterestPage()</caption>
     * Example usage - Utils.convertPageRefToInterestPage('.Employees[4].Assets[5]')
     * returns - .Employees(5).Assets(6)
     */
    static convertPageRefToClipboardPageNotation(pageReference: any): any;
    /**
     * [convertClipboardPageToPageRefNotation]
     * Description : Converts clipboardpage notation to pageReference notation
     * @param   {string}    pageReference      pageReference
     * @returns {string}    pageReference format
     *  @example <caption>Example for convertClipboardPageToPageRefNotation()</caption>
     * Example usage - Utils.convertClipboardPageToPageRefNotation(' .Employees(5).Assets(6)')
     * returns - .Employees[4].Assets[5]
     */
    static convertClipboardPageToPageRefNotation(pageReference: any): any;
    static isString(value: any): boolean;
}
export default Utils;
