import UserPresence from './user-presence';
/**
 * @description
 * Exposes APIs for websocket Messaging Service.
 * @public
 */
declare class MessagingServiceManager {
    /**
     * {
     *  "<subID>": <MessageSubscriber>
     * }
     */
    static subscribers: {};
    static connectionsCount: number;
    static webSocket: any;
    static connectionConfig: any;
    static inProgressSubscriptions: any[];
    static inProgressMessages: any[];
    static isServiceAlive: any;
    static serviceAliveHandler: any;
    static userPresence: UserPresence;
    static refreshB2SOffset: number;
    /**
     * Initializing the connection to message service.
     * @param {object} config object to initialize connection to messaging service
     * example:
     * {
     *  messagingService: "ws://localhost:3000/c11nmsg"
     * }
     * @private
     */
    static initConnection(config: any): void;
    static handleOnError(event: any): void;
    static handleOnClose(event: any): void;
    static handleOnOpen(): void;
    static handleOnMessage(event: any): void;
    /**
     * Api to reInitialize connection on abrupt closing of connection or ALIVE message not received in specified time.
     * @param {boolean} skipSetInterval passed true if broadcast message not received in given time period
     * @private
     */
    static reInitialization(skipSetInterval: any): void;
    /**
     * Api to check server liveliness broadcast message based on time passed as argument, to receive recurring ALIVE message on network
     * @param {number} timeToPing  time in ms.
     * @private
     */
    static checkLiveliness(timeToPing: any): void;
    /**
     * Sets the messaging service url
     * @param {string} connectionConfig  service url to be connected for websocket.
     * eq.,
     * {
     *  messagingService: "ws://localhost:3000/c11nmsg"
     * }
     * @private
     */
    static setConnectionConfig(connectionConfig: any): void;
    /**
     * Api to remove all listerner attached on websocket
     * @private
     */
    static cleanSocketListeners(): void;
    /**
     * Api to clean and nullify websocket
     * @private
     */
    static disconnect(): void;
    /**
     * Api to subscribe to messaging service and depends on the filter creteria messages will
     * be forwarded to subscribers.
     * @param {object} filter Object to hold filter creteria,
     * It helps to recieve only targetted changes.
     * eq.,
     * 1.
     * {
     *  matcher: "interaction"
     * }
     *
     * 2.
     * {
     *  matcher: "pulse",
     *  filter: {
     *      caseId: "EPIC-201"
     *  }
     * }
     * @param {Function} messageHandler callback handler
     * @param {string} contextName - Name of the context eq., app/primary_1
     * @param {string} id any specific id or id will be autogenerated. Id can be used for unsubcribing from
     * message service.
     * @example <caption>Example subscribe()</caption>
     * Example usage - PCore.getMessagingServiceManager().subscribe({matcher: "interaction"}, message => {
     *  // Do process message here
     * }));
     * @returns {string} returns the subscription id, can be used for unsubcribing from
     * message service.
     * @public
     */
    static subscribe(filter: any, messageHandler: any, contextName?: string, id?: string): string;
    /**
     * Subscribes to socket.
     * @param {messageSubscriber} messageSubscriber message subscriber
     * @param {id} id subscriber id
     * @private
     */
    static subscribeToSocket(messageSubscriber: any, id: any): void;
    /**
     * Removes the handler from subscriptions and disconnects from service.
     * @param {string} id Pass id returned by subscribe method.
     * @example <caption>Example unsubscribe()</caption>
     * const subId = PCore.getMessagingServiceManager().subscribe({matcher: "interaction"}, message => {
     *  // Do process message here
     * }));
     * PCore.getMessagingServiceManager().unsubscribe(subId);
     * @public
     */
    static unsubscribe(id: any): void;
    /**
     * Publishes the message to subscribers recieved from server.
     * @param {object} message message object recieved from messaging service.
     * @private
     */
    static publishMessage(message: any): void;
    static getUserPresence: () => UserPresence;
    static getCaseSubscription: (caseId: any) => import("./atomic-subscription").default;
    static refreshB2STokenReInit: () => Promise<void>;
    static getTokenExpiryTime: () => number;
    static setTokenExpiryTime: (token: any) => void;
    /**
     * Removes the cache of all subscribers.
     * @param {string} contextName name of the context.
     * @private
     */
    static clearContext(contextName: any): void;
}
export default MessagingServiceManager;
