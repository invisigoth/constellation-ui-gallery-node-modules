import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useRef, useEffect, useCallback, forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { Button, Card, CardContent, CardHeader, defaultThemeProp, Flex, getFocusables, Icon, registerIcon, Popover, StyledCard, Switch, Text, Progress, usePrevious, useItemIntersection, useUID, useConsolidatedRef } from '@pega/cosmos-react-core';
import { useArrows, useElement, useI18n, useOuterEvent } from '@pega/cosmos-react-core/lib/hooks';
import * as filterIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/filter.icon';
import * as filterOnIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/filter-on.icon';
import { StyledCardHeader } from '@pega/cosmos-react-core/lib/components/Card/CardHeader';
import { FeedContext } from './Feed.context';
import FeedButton from './FeedButton';
import FeedAnnouncer from './FeedAnnouncer';
registerIcon(filterIcon, filterOnIcon);
const StyledFeed = styled.div `
  ${StyledCardHeader}:not(${StyledCard} ${StyledCard} > ${StyledCardHeader}) {
    padding-bottom: 0.25rem;
  }
`;
StyledFeed.defaultProps = defaultThemeProp;
const StyledFilterMenu = styled.div(({ theme }) => {
    return css `
    fieldset {
      padding-block-end: calc(2 * ${theme.base.spacing});
      border: none;
      max-height: inherit;

      legend {
        padding-block-start: calc(2 * ${theme.base.spacing});
        padding-inline: calc(2 * ${theme.base.spacing});
      }
    }
  `;
});
StyledFilterMenu.defaultProps = defaultThemeProp;
const StyledFilterList = styled.ul(({ theme }) => {
    return css `
    list-style-type: none;
    min-width: ${theme.base['content-width'].xs};
    padding-inline: calc(2 * ${theme.base.spacing});
    overflow: auto;
  `;
});
StyledFilterList.defaultProps = defaultThemeProp;
const StyledLoadMore = styled.div(({ theme }) => {
    return css `
    margin-top: ${theme.base.spacing};
    min-height: 2rem;
    min-width: 2rem;
  `;
});
StyledLoadMore.defaultProps = defaultThemeProp;
const Feed = forwardRef(function Feed(props, ref) {
    const { loadingPosts = false, variant, children, userInfo, className, title, searchTypes, onDecoratorSearch, searchResults = [], onMentionClick, onMentionPreview, onTagClick, mentionContent, interactionRenderers = [], markdownMap, filters, onFilterChange, onLoadMore, newPostRegion, posts = [], ...restProps } = props;
    const t = useI18n();
    const [popoverEl, setPopoverEl] = useElement();
    const [buttonEl, setButtonEl] = useElement();
    const [mountPopover, setMountPopover] = useState(false);
    const [showSearchResults, setShowSearchResults] = useState(false);
    const prevPosts = usePrevious(posts);
    const [announcementText, setAnnouncementText] = useState('');
    const feedRef = useConsolidatedRef(ref);
    const filterRef = useRef(null);
    useArrows(filterRef);
    useOuterEvent('mousedown', [popoverEl, buttonEl], () => {
        setMountPopover(false);
    });
    useOuterEvent('focusin', [popoverEl], () => {
        setMountPopover(false);
    });
    const onKeydown = ({ key }) => {
        if (key === 'Escape')
            setMountPopover(false);
    };
    useEffect(() => {
        document.addEventListener('keydown', onKeydown);
        return () => {
            document.removeEventListener('keydown', onKeydown);
        };
    }, []);
    const id = useUID();
    useItemIntersection({ current: null }, posts.length - 1, () => {
        onLoadMore?.();
    }, `#${id} > article[role='none']`);
    const announce = useCallback((announcement) => {
        setAnnouncementText('');
        return setTimeout(() => {
            setAnnouncementText(announcement);
        }, 0);
    }, []);
    useEffect(() => {
        if (loadingPosts) {
            const timeoutId = announce(t('loading_post'));
            return () => clearTimeout(timeoutId);
        }
    }, [loadingPosts]);
    useEffect(() => {
        if (prevPosts) {
            let timeoutId;
            const difference = posts.length - prevPosts.length;
            if (difference < 0)
                announce(t('feed_post_removed'));
            else if (difference > 0)
                announce(t('feed_new_post_added', [difference], { count: difference }));
            return () => clearTimeout(timeoutId);
        }
    }, [posts]);
    useEffect(() => {
        if (mountPopover) {
            setTimeout(() => {
                const focusables = getFocusables(filterRef);
                focusables[0]?.focus();
            }, 0);
        }
    }, [mountPopover]);
    return (_jsx(FeedContext.Provider
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    , { 
        // eslint-disable-next-line react/jsx-no-constructed-context-values
        value: {
            searchTypes,
            onSearch: e => {
                if (onDecoratorSearch)
                    onDecoratorSearch(e);
            },
            searchResults,
            showSearchResults,
            setShowSearchResults,
            onMentionClick,
            onMentionPreview,
            onTagClick,
            interactionRenderers,
            markdownMap,
            userInfo,
            announce,
            feedRef
        }, children: _jsxs(StyledFeed, { ref: feedRef, ...restProps, children: [_jsx(FeedAnnouncer, { children: announcementText }), _jsxs(Card, { children: [_jsxs(CardHeader, { children: [_jsx(Text, { variant: 'h2', children: title }), filters && filters.length > 0 && (_jsx(Button, { as: FeedButton, ref: setButtonEl, variant: 'simple', icon: true, onClick: () => setMountPopover(curr => !curr), label: `${title} ${t('filters').toLowerCase()}`, emphasized: true, children: _jsx(Icon, { name: filters?.map(filter => !!filter.on).reduce((acc, curr) => acc || curr)
                                            ? 'filter-on'
                                            : 'filter' }) })), _jsx(Popover, { show: !!filters && mountPopover, ref: setPopoverEl, target: buttonEl, as: StyledFilterMenu, hideOnTargetHidden: true, onKeyDown: (event) => {
                                        if (event.key === 'Tab') {
                                            event.preventDefault();
                                            buttonEl?.focus();
                                        }
                                    }, children: _jsxs(Flex, { container: { direction: 'column', gap: 2 }, as: 'fieldset', children: [_jsx(Text, { variant: 'h3', as: 'legend', children: t('filters') }), _jsx(StyledFilterList, { ref: filterRef, children: filters?.map(filter => {
                                                    return (_jsx("li", { children: _jsx(Switch, { ...filter, onChange: (event) => onFilterChange?.(event.target.id, event.target.checked) }) }, filter.id));
                                                }) })] }) })] }), _jsx(CardContent, { children: newPostRegion })] }), _jsx("div", { id: id, children: posts }), loadingPosts && (_jsx(Flex, { container: { justify: 'center' }, as: StyledLoadMore, children: _jsx(Progress, { placement: 'inline' }) }))] }) }));
});
export default Feed;
//# sourceMappingURL=Feed.js.map