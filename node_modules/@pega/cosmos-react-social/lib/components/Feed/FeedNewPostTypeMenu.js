import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useMemo, useEffect, useCallback, useReducer } from 'react';
import styled, { css } from 'styled-components';
import { Button, Flex, StyledPrimary, StyledMenuItem, Icon, StyledIcon, useElement, useOuterEvent, Popover, Tooltip, Menu, Count, defaultThemeProp, createUID, useAfterInitialEffect, formatListToLocaleString, useConfiguration, useI18n, useModalManager } from '@pega/cosmos-react-core';
import BareRoleButton from '@pega/cosmos-react-core/lib/components/Button/BareRoleButton';
import { StyledMenuListHeader } from '@pega/cosmos-react-core/lib/components/Menu/Menu.styles';
import MultiSelectInput from '@pega/cosmos-react-core/lib/components/ComboBox/MultiSelectInput/MultiSelectInput';
import FeedModalList from './FeedModalList';
const StyledCountButton = styled(BareRoleButton) `
  display: inline-block;
`;
const StyledCountBadgePopoverContent = styled.div(({ theme }) => {
    const { base: { spacing } } = theme;
    return css `
    padding: ${spacing};

    p:not(:last-child) {
      margin-bottom: ${spacing};
    }
  `;
});
StyledCountBadgePopoverContent.defaultProps = defaultThemeProp;
const StyledPostTypePopoverContent = styled.div `
  width: clamp(16rem, 60vw, 40rem);
`;
const StyledSelectedInputContainer = styled.div(({ theme }) => {
    const { base: { spacing } } = theme;
    return css `
    margin: ${spacing} calc(2 * ${spacing}) calc(2 * ${spacing});
  `;
});
StyledSelectedInputContainer.defaultProps = defaultThemeProp;
const StyledRecipientBackButton = styled(StyledMenuListHeader)(({ theme }) => {
    const { base: { 'font-weight': { 'semi-bold': fontWeight }, spacing } } = theme;
    return css `
    font-weight: ${fontWeight};
    padding: ${spacing} calc(2 * ${spacing});

    &:hover,
    &:focus {
      text-decoration: none;
    }

    && ${StyledIcon} {
      display: inline-block;
      margin-inline-end: ${spacing};
    }
  `;
});
StyledRecipientBackButton.defaultProps = defaultThemeProp;
const StyledRecipientMenuHeader = styled.div ``;
const StyledTypeMenuToggle = styled(Button)(({ theme }) => {
    const { base: { spacing } } = theme;
    return css `
    margin-block-end: ${spacing};
  `;
});
StyledTypeMenuToggle.defaultProps = defaultThemeProp;
const StyledRecipientMenu = styled(Menu)(({ theme }) => {
    const { base: { spacing } } = theme;
    return css `
    ${StyledMenuItem} > button {
      padding: ${spacing} calc(2 * ${spacing});
    }
  `;
});
StyledRecipientMenu.defaultProps = defaultThemeProp;
const StyledPostTypePopover = styled(Popover)(({ theme }) => {
    const { base: { 'font-weight': { normal: fontWeight } } } = theme;
    return css `
    ${StyledPrimary} {
      font-weight: ${fontWeight};
    }
  `;
});
StyledPostTypePopover.defaultProps = defaultThemeProp;
const typeCopy = {
    post: {
        primary: 'Public post'
    },
    private: {
        primary: 'Private post'
    }
};
const createRecipientMenuItem = (recipient, selectedIds) => {
    const checkIds = selectedIds || [];
    const id = `option_${recipient.value}`;
    return {
        ...recipient,
        id,
        selected: checkIds.includes(id)
    };
};
const getTypeMenuItems = (type) => {
    return [
        {
            id: '1',
            primary: typeCopy.post.primary,
            selected: type === 'post',
            value: 'post'
        },
        {
            id: '2',
            primary: typeCopy.private.primary,
            selected: type === 'private',
            value: 'private'
        }
    ];
};
const initialState = {
    postType: 'post',
    itemsLoading: false,
    showTypeMenu: false,
    showRecipientMenu: false,
    viewingRecipients: false,
    searchValue: '',
    typeMenuItems: getTypeMenuItems('post'),
    recipientMenuItems: [],
    multiSelectItems: []
};
const FeedNewPostTypeMenu = ({ recipients, onSetPostType, onSelectedRecipientsUpdate, onRecipientSearch, reset, onReset, ...restProps }) => {
    const t = useI18n();
    const { locale } = useConfiguration();
    const { create } = useModalManager();
    const menuPopoverId = useMemo(() => createUID(), []);
    const recipientsModalRef = useRef();
    const multiSelectInputRef = useRef(null);
    const [toggleEl, setToggleEl] = useElement();
    const [recipientCountEl, setRecipientCountEl] = useElement();
    const [typePopoverEl, setTypePopoverEl] = useElement(null);
    const [typeMenuPopoverTarget, setTypeMenuPopoverTarget] = useElement(null);
    const reducer = (state, action) => {
        const type = action.type;
        const payload = action.payload;
        switch (type) {
            case 'reset': {
                return initialState;
            }
            case 'setPostType': {
                const postType = payload;
                const privateSelected = postType === 'private';
                return {
                    ...state,
                    postType,
                    showTypeMenu: !privateSelected ? false : state.showTypeMenu,
                    viewingRecipients: privateSelected ? true : state.viewingRecipients,
                    multiSelectItems: initialState.multiSelectItems,
                    searchValue: initialState.searchValue
                };
            }
            case 'setShowTypeMenu': {
                return {
                    ...state,
                    showTypeMenu: payload
                };
            }
            case 'setShowRecipientMenu': {
                return {
                    ...state,
                    showRecipientMenu: payload
                };
            }
            case 'setSearchValue': {
                return {
                    ...state,
                    searchValue: payload
                };
            }
            case 'setViewingRecipients': {
                return {
                    ...state,
                    viewingRecipients: payload
                };
            }
            case 'setItemsLoading': {
                return {
                    ...state,
                    itemsLoading: payload
                };
            }
            case 'updateTypeMenuItems': {
                return {
                    ...state,
                    typeMenuItems: getTypeMenuItems(state.postType)
                };
            }
            case 'toggleTypeMenu': {
                return {
                    ...state,
                    showTypeMenu: !state.showTypeMenu
                };
            }
            case 'removeRecipientViaMultiSelect': {
                const selectedId = payload;
                const multiSelectItems = state.multiSelectItems.reduce((acc, recipient) => {
                    if (recipient.id === selectedId)
                        return acc;
                    return acc.concat([recipient]);
                }, []);
                const recipientMenuItems = state.recipientMenuItems.map(item => {
                    if (item.id === selectedId) {
                        return {
                            ...item,
                            selected: false
                        };
                    }
                    return {
                        ...item
                    };
                });
                return {
                    ...state,
                    multiSelectItems,
                    recipientMenuItems
                };
            }
            case 'selectRecipientViaMenu': {
                const selectedId = payload;
                if (!state.multiSelectItems.some(item => item.id === selectedId)) {
                    const selectedFromMenu = state.recipientMenuItems.filter(item => item.id === selectedId)[0];
                    const multiSelectItems = state.multiSelectItems.concat([selectedFromMenu]);
                    return {
                        ...state,
                        multiSelectItems,
                        searchValue: ''
                    };
                }
                return {
                    ...state,
                    searchValue: ''
                };
            }
            case 'updateRecipientMenuItems': {
                const selectedIds = state.multiSelectItems.map(item => item.id);
                return {
                    ...state,
                    itemsLoading: false,
                    recipientMenuItems: recipients.map(recipient => createRecipientMenuItem(recipient, selectedIds))
                };
            }
            case 'resetUnappliedState': {
                const postType = state.postType === 'private' && state.multiSelectItems.length === 0
                    ? 'post'
                    : state.postType;
                const searchValue = '';
                return {
                    ...state,
                    postType,
                    searchValue
                };
            }
            default:
                return {
                    ...state
                };
        }
    };
    const [state, dispatch] = useReducer(reducer, initialState);
    const handleKeydownToggle = useCallback((e) => {
        if (e.key === 'Escape' && state.showTypeMenu)
            dispatch({ type: 'toggleTypeMenu' });
    }, [state.showTypeMenu]);
    useOuterEvent('mousedown', [typePopoverEl, typeMenuPopoverTarget], () => {
        dispatch({ type: 'setShowTypeMenu', payload: false });
    });
    useEffect(() => {
        if (reset) {
            dispatch({ type: 'reset' });
            onReset();
        }
    }, [reset]);
    useEffect(() => {
        dispatch({ type: 'updateRecipientMenuItems' });
    }, [recipients]);
    useEffect(() => {
        onSelectedRecipientsUpdate(state.multiSelectItems);
    }, [state.multiSelectItems]);
    useEffect(() => {
        if (!state.showTypeMenu) {
            let timeoutId;
            if (state.postType === 'private') {
                // Timeout to prevent flash of recipients options when closing menu.
                timeoutId = setTimeout(() => {
                    dispatch({ type: 'setViewingRecipients', payload: true });
                }, 100);
            }
            timeoutId = setTimeout(() => {
                // Timeout to prevent flash of type menu when resetting postType on close
                dispatch({ type: 'resetUnappliedState' });
            }, 100);
            return () => clearTimeout(timeoutId);
        }
    }, [state.showTypeMenu]);
    useEffect(() => {
        if (multiSelectInputRef.current) {
            multiSelectInputRef.current?.focus();
        }
    }, [multiSelectInputRef.current]);
    useEffect(() => {
        if (state.postType === 'private') {
            if (!state.viewingRecipients) {
                toggleEl?.focus();
            }
            else {
                multiSelectInputRef.current?.focus();
            }
        }
    }, [state.viewingRecipients]);
    useAfterInitialEffect(() => {
        onSetPostType(state.postType);
        dispatch({ type: 'updateTypeMenuItems' });
        if (state.postType === 'private') {
            multiSelectInputRef.current?.focus();
        }
    }, [state.postType]);
    useEffect(() => {
        const interactionTimeout = setTimeout(() => {
            onRecipientSearch(state.searchValue);
            dispatch({ type: 'setItemsLoading', payload: true });
            dispatch({ type: 'setShowRecipientMenu', payload: !!state.searchValue.length });
        }, 300);
        return () => clearTimeout(interactionTimeout);
    }, [state.searchValue]);
    useEffect(() => {
        toggleEl?.addEventListener('keydown', handleKeydownToggle);
        return () => toggleEl?.removeEventListener('keydown', handleKeydownToggle);
    }, [toggleEl, state.showTypeMenu]);
    useEffect(() => {
        multiSelectInputRef.current?.addEventListener('keydown', handleKeydownToggle);
        return () => multiSelectInputRef.current?.removeEventListener('keydown', handleKeydownToggle);
    }, [multiSelectInputRef.current, state.showTypeMenu]);
    const onRecipientsCountClick = () => {
        recipientsModalRef.current = create(FeedModalList, {
            count: state.multiSelectItems.length,
            heading: t('feed_recipients'),
            listItems: state.multiSelectItems.map(item => ({
                id: item.id,
                primary: item.primary,
                secondary: item.secondary,
                visual: item.visual
            }))
        });
    };
    return (_jsxs(Flex, { container: { gap: 0.5 }, children: [_jsxs(StyledTypeMenuToggle, { ...restProps, onClick: () => {
                    dispatch({ type: 'toggleTypeMenu' });
                }, ref: setToggleEl, variant: 'link', "aria-haspopup": 'menu', "aria-expanded": state.showTypeMenu, children: [_jsx("span", { ref: setTypeMenuPopoverTarget, children: typeCopy[state.postType].primary }), _jsx(Icon, { name: 'arrow-micro-down' })] }), state.postType === 'private' && state.multiSelectItems.length > 0 && (_jsxs(_Fragment, { children: [_jsx(StyledCountButton, { ref: setRecipientCountEl, onClick: onRecipientsCountClick, "aria-label": `${t('feed_private_post')} ${t('feed_recipients')} ${formatListToLocaleString(state.multiSelectItems.map(item => item.primary).slice(0, 2), t, locale, {
                            count: state.multiSelectItems.length
                        })}`, tabIndex: 0, children: _jsx(Count, { children: state.multiSelectItems.length }) }), _jsx(Tooltip, { target: recipientCountEl, showDelay: 'none', hideDelay: 'none', describeTarget: false, children: formatListToLocaleString(state.multiSelectItems.map(item => item.primary).slice(0, 2), t, locale, {
                            count: state.multiSelectItems.length,
                            separator: '\n'
                        }) })] })), _jsxs(StyledPostTypePopover, { id: menuPopoverId, ref: setTypePopoverEl, target: typeMenuPopoverTarget, show: state.showTypeMenu, placement: 'bottom-start', children: [(state.postType !== 'private' || !state.viewingRecipients) && (_jsx(Menu, { items: state.typeMenuItems, focusControlEl: toggleEl || undefined, mode: 'single-select', onItemClick: selectedId => {
                            const postType = state.typeMenuItems.find(item => item.id === selectedId).value;
                            dispatch({ type: 'setPostType', payload: postType });
                        }, onItemExpand: () => {
                            if (state.postType === 'private') {
                                dispatch({ type: 'setViewingRecipients', payload: true });
                            }
                            else {
                                dispatch({ type: 'setPostType', payload: 'private' });
                            }
                        } })), state.postType === 'private' && state.viewingRecipients && (_jsxs(StyledPostTypePopoverContent, { children: [_jsxs(StyledRecipientMenuHeader, { children: [_jsxs(Button, { as: StyledRecipientBackButton, variant: 'text', "aria-label": 'close submenu', onClick: () => {
                                            dispatch({ type: 'setViewingRecipients', payload: false });
                                        }, children: [_jsx(Icon, { name: 'caret-left' }), typeCopy.private.primary] }), _jsx(StyledSelectedInputContainer, { children: _jsx(MultiSelectInput, { ref: multiSelectInputRef, selected: state.multiSelectItems.map(item => ({
                                                id: item.id,
                                                text: item.primary
                                            })), onRemove: (selectedId) => {
                                                dispatch({ type: 'removeRecipientViaMultiSelect', payload: selectedId });
                                            }, value: state.searchValue, onChange: (e) => {
                                                dispatch({ type: 'setSearchValue', payload: e.target.value });
                                            } }) })] }), state.showRecipientMenu && (_jsx(StyledRecipientMenu, { loading: state.itemsLoading, focusControlEl: multiSelectInputRef.current, items: state.itemsLoading ? [] : state.recipientMenuItems, scrollAt: 11, mode: 'action', emptyText: 'No items', onItemClick: (selectedId) => {
                                    dispatch({ type: 'selectRecipientViaMenu', payload: selectedId });
                                } }))] }))] })] }));
};
export default FeedNewPostTypeMenu;
//# sourceMappingURL=FeedNewPostTypeMenu.js.map