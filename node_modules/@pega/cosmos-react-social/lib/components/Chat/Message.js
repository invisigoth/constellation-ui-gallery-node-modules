import { createElement as _createElement } from "react";
import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useEffect, useMemo, useRef } from 'react';
import { Avatar, Flex, Icon, registerIcon, SummaryItem, Image, EmojiDisplay, useI18n, Actions, Tooltip, useTheme, useElement } from '@pega/cosmos-react-core';
import * as documentDocIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/document-doc.icon';
import * as chainUpIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/chain-up.icon';
import * as flagWaveSolidIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/flag-wave-solid.icon';
import { StyledMessageContainer, StyledMessageMain, StyledMessageBubble, StyledMessageBubbleContent, StyledMediaList, StyledMediaListItem, StyledMediaThumbNail, StyledSummaryItem, StyledMediaLink, StyledMetaInfoContainer, StyledMetaInfo, StyledBlinkingDot, StyledMediaButton, StyledMessageHeader, StyledMessageHeaderContent, StyledMessageHeaderMeta, StyledUndeliveredIcon, StyledStatusInfo, StyledHeadset, getMessageColors, StyledFlagIcon, StyledHeadsetIconBackground } from './Message.styles';
registerIcon(documentDocIcon, chainUpIcon, flagWaveSolidIcon);
const Attachment = (props) => {
    const { id, icon, name, meta, actions = [], onPreview, thumbnail } = props;
    const actionRef = useRef(null);
    useEffect(() => {
        const listener = (e) => {
            if (e.target?.getAttribute('aria-expanded') === 'true' &&
                ['ArrowLeft', 'ArrowRight', 'ArrowDown', 'ArrowUp'].includes(e.key)) {
                e.stopPropagation();
            }
        };
        actionRef.current?.addEventListener('keydown', listener);
        return () => {
            actionRef.current?.removeEventListener('keydown', listener);
        };
    }, [actions]);
    return (_jsxs(Flex, { as: StyledMediaListItem, container: {
            direction: 'column'
        }, children: [thumbnail && (_jsx(Image, { as: StyledMediaThumbNail, src: thumbnail, onClick: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    onPreview?.(id);
                }, alt: name })), _jsx(SummaryItem, { as: StyledSummaryItem, primary: _jsx(StyledMediaButton, { onClick: (e) => {
                        e.preventDefault();
                        e.stopPropagation();
                        onPreview?.(id);
                    }, children: name }), secondary: meta, visual: _jsx(Icon, { name: icon || 'document-doc' }), actions: _jsx(Actions, { ref: actionRef, items: actions, iconOnly: true }) })] }, id));
};
const Message = forwardRef(function Message(props, ref) {
    const { message, direction, avatarInfo, timestamp, attachments = [], mediaPageLinks = [], status, typing, messageHeader, senderType, senderId, agentVariant, ...restProps } = props;
    const t = useI18n();
    const theme = useTheme();
    const [avatarRef, setAvatarRef] = useElement();
    const { content: messageBubbleBackgroundColor } = useMemo(() => getMessageColors(theme, direction, senderType, agentVariant), [theme, direction, senderType, agentVariant]);
    let messageMetaJustify = 'between';
    if (timestamp && !status) {
        messageMetaJustify = 'start';
    }
    else if (!timestamp && status) {
        messageMetaJustify = 'end';
    }
    const renderAvatar = useMemo(() => {
        if (direction !== 'in' || (senderType !== 'bot' && !avatarInfo)) {
            return null;
        }
        if (senderType === 'agent') {
            return (_jsxs(_Fragment, { children: [_jsxs(StyledHeadset, { children: [_jsx(Avatar, { name: avatarInfo.name, size: 'm', shape: 'circle', imageSrc: avatarInfo.imageSrc, ref: setAvatarRef, backgroundColor: messageBubbleBackgroundColor }), _jsx(StyledHeadsetIconBackground, { children: _jsx(Icon, { name: 'headset' }) })] }), _jsx(Tooltip, { target: avatarRef, showDelay: 'none', hideDelay: 'none', children: avatarInfo.name })] }));
        }
        return (_jsxs(_Fragment, { children: [_jsx(Avatar, { name: avatarInfo ? avatarInfo.name : t('bot'), size: 'm', shape: 'circle', icon: !avatarInfo?.imageSrc && senderType === 'bot' ? 'robot-solid' : undefined, imageSrc: avatarInfo?.imageSrc, ref: setAvatarRef, backgroundColor: messageBubbleBackgroundColor }), _jsx(Tooltip, { target: avatarRef, showDelay: 'none', hideDelay: 'none', children: avatarInfo ? avatarInfo.name : t('bot') })] }));
    }, [avatarInfo, senderType, direction, avatarRef]);
    let ariaLabel;
    const sender = avatarInfo ? avatarInfo.name : senderType;
    ariaLabel = t('sender_replied_message', [sender, message || '']);
    if (attachments.length > 0)
        ariaLabel = t('chat_attachments', [ariaLabel, attachments.length]);
    if (mediaPageLinks.length > 0)
        ariaLabel = t('chat_links', [ariaLabel, mediaPageLinks.length]);
    if (timestamp)
        ariaLabel = t('chat_message_at_timestamp', [ariaLabel, timestamp]);
    if (status && direction === 'out')
        ariaLabel += ` ${t('chat_message_status', [status])}`;
    return (_jsxs(Flex, { as: StyledMessageContainer, ref: ref, container: {
            gap: 1.5,
            direction: direction === 'in' ? 'row' : 'row-reverse'
        }, item: {
            shrink: 0
        }, hasMessage: !!message, direction: direction, senderType: senderType, typing: typing, messageHeader: messageHeader, status: status, agentVariant: agentVariant, "aria-label": ariaLabel, ...restProps, children: [renderAvatar, _jsxs(Flex, { container: {
                    direction: 'column',
                    alignItems: direction === 'in' ? 'start' : 'end',
                    justify: 'center'
                }, as: StyledMessageMain, children: [_jsxs(Flex, { container: {
                            direction: direction === 'in' ? 'row' : 'row-reverse',
                            alignItems: 'center',
                            gap: 0.5
                        }, children: [_jsxs(StyledMessageBubble, { children: [messageHeader && (_jsxs(Flex, { container: { gap: 0.5, justify: 'between' }, as: StyledMessageHeader, children: [_jsxs(Flex, { container: { gap: 0.5 }, children: [_jsx(StyledFlagIcon, { name: 'flag-wave-solid' }), _jsx(StyledMessageHeaderContent, { children: messageHeader.content })] }), _jsx(StyledMessageHeaderMeta, { children: messageHeader.meta })] })), message && (_jsx(StyledMessageBubbleContent, { children: _jsx(EmojiDisplay, { content: message, size: 20 }) })), (attachments.length > 0 || mediaPageLinks.length > 0) && (_jsxs(StyledMediaList, { children: [attachments.map(attachment => {
                                                return _createElement(Attachment, { ...attachment, key: attachment.id });
                                            }), mediaPageLinks.map(pagePushLink => {
                                                const { id, href, title, thumbnail } = pagePushLink;
                                                return (_jsxs(Flex, { as: StyledMediaListItem, container: {
                                                        direction: 'column'
                                                    }, children: [thumbnail && (_jsx(Image, { as: StyledMediaThumbNail, src: thumbnail, alt: title || href })), _jsx(SummaryItem, { as: StyledSummaryItem, primary: _jsx(StyledMediaLink, { "aria-label": title, href: href, target: '_blank', rel: 'noreferrer', children: href }), visual: _jsx(Icon, { name: 'chain-up' }) })] }, id));
                                            })] }))] }), status === 'undeliverable' && message && direction === 'out' && (_jsx(StyledUndeliveredIcon, { name: 'warn-solid' }))] }), !typing && (_jsxs(Flex, { as: StyledMetaInfoContainer, container: {
                            justify: messageMetaJustify,
                            gap: 1.5
                        }, children: [timestamp && _jsx(StyledMetaInfo, { children: timestamp }), status && direction === 'out' && _jsx(StyledStatusInfo, { children: t(status) })] })), typing && (_jsxs(Flex, { container: {
                            gap: 0.25
                        }, children: [_jsx(StyledBlinkingDot, { delay: 0 }), _jsx(StyledBlinkingDot, { delay: 0.25 }), _jsx(StyledBlinkingDot, { delay: 0.5 })] }))] })] }));
});
export default Message;
//# sourceMappingURL=Message.js.map