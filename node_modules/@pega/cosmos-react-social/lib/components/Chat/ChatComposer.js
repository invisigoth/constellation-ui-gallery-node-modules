import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { createElement as _createElement } from "react";
import { forwardRef, useState, useEffect, useCallback, useImperativeHandle, useRef } from 'react';
import styled, { css } from 'styled-components';
import { Flex, TextArea, Button, Icon, registerIcon, Popover, EmojiPicker, hasProp, useI18n, useElement, defaultThemeProp, Tooltip, useOuterEvent, VisuallyHiddenText, FileUploadItem, Grid } from '@pega/cosmos-react-core';
import BareButton from '@pega/cosmos-react-core/lib/components/Button/BareButton';
import * as timesIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/times.icon';
import * as faceHappyIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/face-happy.icon';
import * as paperClipIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/paper-clip.icon';
registerIcon(timesIcon, faceHappyIcon, paperClipIcon);
const StyledAttachmentItem = styled(FileUploadItem) ``;
const StyledAttachmentElementContainer = styled.div(({ disabled, theme }) => {
    return (disabled &&
        css `
        &:focus {
          box-shadow: ${theme.base.shadow.focus};
          border-radius: 50%;
          outline: none;
        }
      `);
});
const StyledPreviewButton = styled(BareButton) ``;
const StyledDeleteButton = styled(BareButton) ``;
const StyledChatComposer = styled.footer(({ theme, disabled, theme: { base: { 'disabled-opacity': transparentBg, spacing } } }) => {
    return css `
      padding: calc(2 * ${spacing});
      background-color: ${theme.base.palette['secondary-background']};
      border-end-start-radius: inherit;
      border-end-end-radius: inherit;
      textarea {
        border-radius: ${theme.base['border-radius']};
        height: 5rem;
        border: 0.0625rem solid ${theme.base.colors.gray['extra-light']};
        max-width: 100%;
      }
      ${StyledAttachmentItem} {
        ${disabled &&
        css `
          pointer-events: none;
          opacity: ${transparentBg};
        `}
      }

      ${StyledAttachmentElementContainer} {
        ${disabled &&
        css `
          pointer-events: none;
        `}
      }

      ${StyledPreviewButton} {
        color: ${theme.base.palette.interactive};
        font-weight: bold;
        &:hover {
          text-decoration: underline;
        }
      }

      ${StyledDeleteButton} {
        color: ${theme.base.palette.interactive};
      }
    `;
});
StyledChatComposer.defaultProps = defaultThemeProp;
StyledAttachmentElementContainer.defaultProps = defaultThemeProp;
export const StyledAttachmentsListContainer = styled.div(({ theme }) => {
    return css `
    max-height: 5rem;
    overflow-y: auto;

    &:focus-within {
      box-shadow: ${theme.base.shadow['focus-group']};
      border-radius: calc(0.5 * ${theme.base['border-radius']});
    }
  `;
});
const ChatComposer = forwardRef(function ChatComposer(props, ref) {
    const { children, attachments = [], maxAttachments = 0, onAddAttachment, maxLength, placeholder: defaultPlaceHolder, defaultMessage = '', onSend, specialKeysConfig, disabled = false, enterKeySendsMessage = true, showEmoji, ...restProps } = props;
    const [message, setMessage] = useState(defaultMessage);
    useEffect(() => {
        setMessage(defaultMessage);
    }, [defaultMessage]);
    const t = useI18n();
    const textAreaRef = useRef(null);
    const [showEmojiPicker, setShowEmojiPicker] = useState(false);
    const [emojiBtnEl, setEmojiBtnEl] = useElement();
    const [attachmentsBtnEl, setAttachmentsBtnEl] = useElement();
    const [announcement, setAnnouncement] = useState('');
    const lastEnteredSpecialKey = useRef(null);
    const appendToMessage = useCallback((appendMessage, position, selectText = true) => {
        let selectionStart;
        let selectionEnd;
        if (textAreaRef.current) {
            if (position === 'start') {
                textAreaRef.current.value = appendMessage + textAreaRef.current.value;
                selectionStart = 0;
                selectionEnd = appendMessage.length;
            }
            else if (position === 'end') {
                const initialEnd = textAreaRef.current.value.length;
                textAreaRef.current.value += appendMessage;
                selectionStart = initialEnd;
                selectionEnd = initialEnd + appendMessage.length;
            }
            else if (position === 'specialKey' && lastEnteredSpecialKey.current) {
                const replaceChars = lastEnteredSpecialKey.current.length;
                const currentSelectionStart = textAreaRef.current.selectionStart;
                textAreaRef.current.value =
                    textAreaRef.current.value.substring(0, textAreaRef.current.selectionStart - replaceChars) +
                        appendMessage +
                        textAreaRef.current.value.substring(textAreaRef.current.selectionStart, textAreaRef.current.value.length);
                selectionStart = currentSelectionStart - replaceChars;
                selectionEnd = currentSelectionStart + appendMessage.length - replaceChars;
                lastEnteredSpecialKey.current = null;
            }
            else {
                const currentSelectionStart = textAreaRef.current.selectionStart;
                textAreaRef.current.value =
                    textAreaRef.current.value.substring(0, textAreaRef.current.selectionStart) +
                        appendMessage +
                        textAreaRef.current.value.substring(textAreaRef.current.selectionStart, textAreaRef.current.value.length);
                selectionStart = currentSelectionStart;
                selectionEnd = currentSelectionStart + appendMessage.length;
            }
            textAreaRef.current.selectionStart = selectText ? selectionStart : selectionEnd;
            textAreaRef.current.selectionEnd = selectionEnd;
            textAreaRef.current.focus();
            setMessage(textAreaRef.current.value);
        }
    }, [setMessage, textAreaRef.current]);
    const chatComposerRef = useRef(null);
    useImperativeHandle(ref, () => ({ appendToMessage, chatComposerRef, textAreaRef }), [
        appendToMessage,
        chatComposerRef.current,
        textAreaRef.current
    ]);
    const sendMessage = useCallback((newMessage) => {
        if (onSend) {
            onSend(newMessage);
            setMessage('');
        }
    }, [onSend]);
    const handleEnterKeyDown = useCallback((e) => {
        if (enterKeySendsMessage && e.keyCode === 13 && !e.shiftKey) {
            if (!maxLength || message.length <= maxLength) {
                sendMessage(message);
                setAnnouncement(t('message_sent'));
            }
            e.preventDefault();
            e.stopPropagation();
        }
    }, [onSend, message, maxLength]);
    const handleTextAreaChange = useCallback((e) => {
        setMessage(e.currentTarget.value);
        setAnnouncement('');
    }, [setMessage]);
    const handleSpecialKey = useCallback((e) => {
        if (!specialKeysConfig)
            return;
        const { keys, onSpecialKey } = specialKeysConfig;
        if (specialKeysConfig && keys.length > 0) {
            const composerValue = e.currentTarget.value.substring(0, e.currentTarget.selectionStart);
            const specialKey = keys.find(key => composerValue.endsWith(key));
            if (specialKey) {
                lastEnteredSpecialKey.current = specialKey;
                onSpecialKey(e, specialKey);
            }
        }
    }, [specialKeysConfig]);
    const toggleEmoji = () => {
        setShowEmojiPicker(!showEmojiPicker);
    };
    const onEmojiSelect = emojiElem => {
        // Check that it is not a custom emoji
        if (hasProp(emojiElem, 'native')) {
            appendToMessage(emojiElem.native, 'cursor', false);
        }
        setShowEmojiPicker(false);
    };
    const EmojiPickerRef = useRef(null);
    useOuterEvent('mousedown', [emojiBtnEl, EmojiPickerRef], () => {
        setShowEmojiPicker(false);
    });
    return (_jsxs(_Fragment, { children: [_jsxs(Flex, { as: StyledChatComposer, disabled: disabled, container: {
                    direction: 'column',
                    gap: 2
                }, item: {
                    shrink: 0
                }, ...restProps, ref: chatComposerRef, children: [_jsxs(Flex, { container: {
                            direction: 'column',
                            gap: 0.5
                        }, children: [_jsx(Grid, { container: {
                                    cols: 'repeat(auto-fill, minmax(12rem, 1fr))',
                                    gap: 1
                                }, role: 'group', "aria-label": `${t('attachments')}`, as: StyledAttachmentsListContainer, children: attachments.map((attachment, idx) => {
                                    if (disabled) {
                                        const attachmentProps = {
                                            ...attachment,
                                            onDelete: undefined,
                                            onDownload: undefined,
                                            onPreview: undefined,
                                            onEdit: undefined,
                                            onCancel: undefined
                                        };
                                        return _createElement(StyledAttachmentItem, { ...attachmentProps, key: attachmentProps.name });
                                    }
                                    return (_jsx("div", { "aria-label": `${t('attachments_x_of_y', [idx + 1, attachments.length])}`, children: _jsx(StyledAttachmentItem, { ...attachment }) }, attachment.name));
                                }) }), _jsx(TextArea, { ref: textAreaRef, maxLength: maxLength, displayCharCount: maxLength !== undefined, hardStop: false, placeholder: defaultPlaceHolder, value: message, disabled: disabled, onKeyUp: handleSpecialKey, onKeyDown: handleEnterKeyDown, onChange: handleTextAreaChange, onFocus: handleTextAreaChange, "aria-label": t('enter_message'), autoResize: false })] }), _jsxs(Flex, { container: { gap: 0.5 }, children: [showEmoji && (_jsx(Button, { ref: setEmojiBtnEl, onClick: toggleEmoji, variant: 'simple', disabled: disabled, icon: true, "aria-label": t('add_emoji'), children: _jsx(Icon, { name: 'face-happy' }) })), maxAttachments > 0 && (_jsxs(StyledAttachmentElementContainer, { disabled: attachments.length >= maxAttachments, ref: setAttachmentsBtnEl, tabIndex: attachments.length >= maxAttachments ? 0 : undefined, role: 'button', children: [_jsx(Button, { onClick: onAddAttachment, variant: 'simple', disabled: !!(disabled || attachments.length >= maxAttachments), icon: true, "aria-label": attachments.length >= maxAttachments
                                            ? t('email_disable_attachment', [maxAttachments])
                                            : t('email_add_attachment', [maxAttachments]), children: _jsx(Icon, { name: 'paper-clip' }) }), attachments.length >= maxAttachments && (_jsx(Tooltip, { target: attachmentsBtnEl, showDelay: 'none', hideDelay: 'none', ...restProps, children: t('email_disable_attachment', [maxAttachments]) }))] })), _jsx(Flex, { item: { grow: 1 }, children: children }), _jsx(Button, { variant: 'primary', disabled: disabled || (!!maxLength && message.length > maxLength), onClick: () => {
                                    sendMessage(message);
                                    setAnnouncement(t('message_sent'));
                                }, children: t('send') }), announcement && (_jsx(VisuallyHiddenText, { "aria-live": 'assertive', children: announcement }))] })] }), _jsx(Popover, { show: showEmojiPicker, target: emojiBtnEl, placement: 'top-start', modifiers: [
                    {
                        name: 'flip',
                        enabled: true
                    }
                ], children: _jsx(EmojiPicker, { ref: EmojiPickerRef, onSelect: onEmojiSelect }) })] }));
});
export default ChatComposer;
//# sourceMappingURL=ChatComposer.js.map