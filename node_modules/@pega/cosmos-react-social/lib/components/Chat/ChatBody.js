import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { createElement as _createElement } from "react";
import { forwardRef, useCallback, useImperativeHandle, useLayoutEffect, useRef, useState, useEffect } from 'react';
import styled, { css } from 'styled-components';
import { Button, debounce, defaultThemeProp, Flex, getFocusables, Icon, Progress, registerIcon, StyledButton, useAfterInitialEffect, useArrows, useI18n, useItemIntersection, useLiveLog, useOuterEvent } from '@pega/cosmos-react-core';
import * as caretDownIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/caret-down.icon';
import { isMessageListItem, isSystemMessageListItem, isTypeIndicatorListItem } from './Chat.types';
import Message from './Message';
import SystemMessage, { StyledSystemMessage } from './SystemMessage';
import TypeIndicator from './TypeIndicator';
import { StyledMessageContainer } from './Message.styles';
registerIcon(caretDownIcon);
export const NewMessageSeparatorId = 'new-message-separator';
const StyledMessageList = styled.ul ``;
const StyledSession = styled.div ``;
const StyledChatBody = styled.div(props => {
    const { theme: { base: { shadow: { high: shadowHigh, focus }, colors: { white }, spacing, palette } } } = props;
    return css `
    position: relative;
    overflow-y: hidden;

    > ${StyledButton} {
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translate(-50%, -50%);
      box-shadow: ${shadowHigh};
      z-index: 1;
      background-color: ${white};
    }

    > ${StyledMessageList} {
      overflow-y: auto;
      list-style-type: none;
      height: 100%;

      > ${StyledSession} {
        padding-inline: 1rem;
        :not(:last-child) {
          border-block-end: 0.0625rem solid ${palette['border-line']};
          margin-block-end: ${spacing};
          padding-block-end: ${spacing};
        }
      }
      ${StyledMessageContainer}, ${StyledSystemMessage} {
        &:focus-visible {
          box-shadow: ${focus};
          outline: none;
        }
        margin-block-end: ${spacing};
      }
    }
  `;
});
StyledChatBody.defaultProps = defaultThemeProp;
const ScrollToLatest = props => {
    const { scrollContainerRef } = props;
    useLayoutEffect(() => {
        if (scrollContainerRef.current) {
            scrollContainerRef.current.scrollTop =
                scrollContainerRef.current.scrollHeight - scrollContainerRef.current.offsetHeight;
        }
    });
    return null;
};
const ChatMessage = ({ agentSerial, message }) => {
    const getAgentVariant = (senderId, senderType, direction = 'in') => {
        if (agentSerial.current === null)
            return undefined;
        if (senderType === 'agent' && direction === 'in') {
            if (agentSerial.current[senderId] !== undefined) {
                return agentSerial.current[senderId];
            }
            const nextIndex = Object.entries(agentSerial.current).length;
            agentSerial.current[senderId] = nextIndex;
            return nextIndex;
        }
        return undefined;
    };
    if (isMessageListItem(message)) {
        const { id, senderType, direction, senderId } = message;
        const agentVariant = getAgentVariant(senderId, senderType, direction);
        return _createElement(Message, { ...message, key: id, agentVariant: agentVariant });
    }
    if (isSystemMessageListItem(message)) {
        const extraProps = {};
        const { id } = message;
        if (id === NewMessageSeparatorId) {
            extraProps['data-new-message-separator'] = NewMessageSeparatorId;
        }
        return _createElement(SystemMessage, { ...message, key: id, ...extraProps });
    }
    if (isTypeIndicatorListItem(message)) {
        const { id, senderId, senderType } = message;
        const agentVariant = getAgentVariant(senderId, senderType);
        return _createElement(TypeIndicator, { ...message, key: id, agentVariant: agentVariant });
    }
    return null;
};
const ChatBody = forwardRef(function ChatBody(props, ref) {
    const { transcripts, liveChat, unreadMessageCount = 0, onScrollToButtonClick, handle, loading, offset = -1, loadMore, ...restProps } = props;
    const t = useI18n();
    const conversationRef = useRef(null);
    const scrollRef = useRef(false);
    const buttonRef = useRef(null);
    const focusInMessageList = useRef(false);
    const initialMessageListFocused = useRef(false);
    const elementRef = useRef(null);
    const activeElementIndex = useRef(-1);
    const agentSerial = useRef({});
    const [messageList, setMessageList] = useState([]);
    const [verticalNav, setVerticalNav] = useState(true);
    const { announcePolite } = useLiveLog();
    const isScrolledToLatest = useCallback(() => {
        return conversationRef.current
            ? conversationRef.current.scrollHeight -
                conversationRef.current.scrollTop -
                conversationRef.current.offsetHeight <=
                30
            : true;
    }, [conversationRef.current]);
    const scrollToLatestMessage = useCallback(() => {
        if (conversationRef.current) {
            conversationRef.current.scrollTop = conversationRef.current.scrollHeight;
            focusInMessageList.current = true;
            messageList[messageList.length - 1]?.focus();
            activeElementIndex.current = messageList.length - 1;
        }
    }, [conversationRef.current, messageList]);
    const [displayScrollLatest, setDisplayScrollToLatest] = useState(false);
    const onMessageListScroll = useCallback(() => {
        const isScrolled = isScrolledToLatest();
        if (scrollRef.current && isScrolled) {
            scrollRef.current = false;
            if (unreadMessageCount) {
                onScrollToButtonClick?.();
            }
        }
        if (!scrollRef.current && !isScrolled) {
            scrollRef.current = true;
        }
        setDisplayScrollToLatest(!isScrolled);
    }, [isScrolledToLatest(), unreadMessageCount]);
    const scrollToNewMessage = useCallback(() => {
        if (conversationRef.current) {
            setDisplayScrollToLatest(false);
            const newMessageIndicatorEle = conversationRef.current.querySelector('[data-new-message-separator]');
            if (newMessageIndicatorEle &&
                newMessageIndicatorEle.nextElementSibling instanceof HTMLElement) {
                conversationRef.current.scrollTop = newMessageIndicatorEle.offsetTop;
                focusInMessageList.current = true;
                newMessageIndicatorEle.nextElementSibling.focus();
                activeElementIndex.current =
                    messageList.findIndex(item => item?.hasAttribute('data-new-message-separator')) + 1;
            }
            else {
                scrollToLatestMessage();
            }
        }
    }, [conversationRef.current, messageList]);
    useImperativeHandle(handle, () => ({
        isScrolledToLatest,
        scrollToLatestMessage,
        scrollToNewMessage
    }), [isScrolledToLatest, scrollToLatestMessage, scrollToNewMessage]);
    useItemIntersection(conversationRef, offset, () => {
        loadMore?.();
    }, ':scope > div > li');
    useEffect(() => {
        const focusableElements = conversationRef.current?.querySelectorAll('li[type="system"],li[type="message"],li[type="typing"]');
        if (focusableElements)
            setMessageList(Array.from(focusableElements));
        if (focusableElements && initialMessageListFocused.current === false) {
            activeElementIndex.current = focusableElements.length - 1;
        }
    }, [transcripts, liveChat]);
    useEffect(() => {
        elementRef.current = messageList[activeElementIndex.current];
        if (verticalNav) {
            elementRef.current?.focus();
        }
        else {
            getFocusables(elementRef)[0]?.focus();
        }
    }, [verticalNav]);
    useArrows(conversationRef, {
        cycle: true,
        selector: ':scope > div > li',
        dir: 'up-down',
        allowTabFocus: true
    }, [transcripts, liveChat]);
    useArrows(elementRef, {
        cycle: true,
        selector: 'a, button, input, textarea, select, details',
        dir: 'left-right',
        allowTabFocus: true
    }, [transcripts, liveChat, verticalNav]);
    const focusSiblingElement = (currentElement, isShiftKey = false) => {
        elementRef.current = currentElement;
        const focusableElements = getFocusables(elementRef);
        if (focusableElements?.length > 0) {
            focusableElements?.[isShiftKey ? focusableElements.length - 1 : 0].focus();
        }
        else {
            const element = isShiftKey
                ? elementRef.current?.previousElementSibling
                : elementRef.current?.nextElementSibling;
            if (element)
                focusSiblingElement(element, isShiftKey);
        }
    };
    useOuterEvent('mousedown', [conversationRef], () => {
        focusInMessageList.current = false;
    });
    useAfterInitialEffect(() => {
        if (liveChat?.length > 0) {
            const unreadMessage = liveChat[liveChat.length - 1];
            if (isSystemMessageListItem(unreadMessage) ||
                (isMessageListItem(unreadMessage) && unreadMessage.direction === 'in')) {
                announcePolite({
                    message: t('new_message'),
                    type: 'alert'
                });
            }
        }
    }, [liveChat]);
    return (_jsxs(_Fragment, { children: [_jsxs(Flex, { ...restProps, as: StyledChatBody, item: {
                    grow: 1
                }, container: {
                    direction: 'column'
                }, ref: ref, children: [_jsxs(StyledMessageList, { ref: conversationRef, onScroll: debounce(onMessageListScroll, 100), onFocus: () => {
                            if (!focusInMessageList.current) {
                                initialMessageListFocused.current = true;
                                elementRef.current = messageList[activeElementIndex.current];
                                elementRef.current?.focus();
                                focusInMessageList.current = true;
                            }
                        }, onKeyDown: e => {
                            if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                                elementRef.current = messageList[activeElementIndex.current];
                                if (getFocusables(elementRef).length > 0) {
                                    setVerticalNav(false);
                                }
                            }
                            else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                                if (e.key === 'ArrowUp') {
                                    activeElementIndex.current =
                                        activeElementIndex.current === 0
                                            ? messageList.length - 1
                                            : activeElementIndex.current - 1;
                                }
                                else {
                                    activeElementIndex.current =
                                        activeElementIndex.current === messageList.length - 1
                                            ? 0
                                            : activeElementIndex.current + 1;
                                }
                                setVerticalNav(true);
                            }
                            else if (e.key === 'Tab') {
                                e.preventDefault();
                                focusInMessageList.current = false;
                                if (e.shiftKey) {
                                    const prevElement = conversationRef?.current?.parentElement?.previousElementSibling;
                                    if (prevElement)
                                        focusSiblingElement(prevElement, true);
                                }
                                else if (unreadMessageCount > 0 || displayScrollLatest) {
                                    buttonRef?.current?.focus();
                                }
                                else {
                                    const nextElement = conversationRef.current?.parentElement?.nextElementSibling;
                                    if (nextElement)
                                        focusSiblingElement(nextElement);
                                }
                            }
                        }, children: [loading && _jsx(Progress, { as: 'li', placement: 'block' }), transcripts.map(session => {
                                return (_jsx(StyledSession, { children: session.messages.map(message => (_jsx(ChatMessage, { message: message, agentSerial: agentSerial }, message.id))) }, session.id));
                            }), _jsx(StyledSession, { children: liveChat.map(message => (_jsx(ChatMessage, { message: message, agentSerial: agentSerial }, message.id))) })] }), (unreadMessageCount > 0 || displayScrollLatest) && (_jsxs(Button, { "aria-label": unreadMessageCount > 0
                            ? t('scroll_to_unread_messages')
                            : t('scroll_to_latest_message'), onClick: () => {
                            if (unreadMessageCount > 0) {
                                scrollToNewMessage();
                            }
                            else {
                                scrollToLatestMessage();
                            }
                            onScrollToButtonClick?.();
                        }, icon: unreadMessageCount === 0, ref: buttonRef, children: [_jsx(Icon, { name: 'caret-down' }), unreadMessageCount > 0 && _jsxs(_Fragment, { children: ["\u00A0 ", t('new_messages')] })] }))] }), isScrolledToLatest() && _jsx(ScrollToLatest, { scrollContainerRef: conversationRef })] }));
});
export default ChatBody;
//# sourceMappingURL=ChatBody.js.map