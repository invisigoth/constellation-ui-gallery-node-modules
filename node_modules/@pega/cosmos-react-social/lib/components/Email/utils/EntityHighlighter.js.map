{"version":3,"file":"EntityHighlighter.js","sourceRoot":"","sources":["../../../../src/components/Email/utils/EntityHighlighter.ts"],"names":[],"mappings":"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","sourcesContent":["import { TextNode, Element, Node, ParentNode, parse, serialize, Document } from 'parse5';\n\nimport { EmailProps, EntityMatch, MatchRange } from '../Email.types';\n\nconst isParentNode = (node: Node | undefined): node is ParentNode =>\n  !!node &&\n  node.nodeName !== '#text' &&\n  node.nodeName !== '#comment' &&\n  node.nodeName !== '#documentType';\n\n/**\n * Function to check if there is nesting in the given ranges\n * @param {MatchRange} range1\n * @param {MatchRange} range2\n * @returns {boolean}\n */\nconst isNesting = (range1: MatchRange, range2: MatchRange): boolean => {\n  return (\n    (range1.start >= range2.start && range1.end <= range2.end) ||\n    (range2.start >= range1.start && range2.end <= range1.end)\n  );\n};\n\n/**\n * Function to check if there is an intersection in the ranges\n * @param {MatchRange} range1\n * @param {MatchRange} range2\n * @returns {boolean}\n */\nconst isIntersecting = (range1: MatchRange, range2: MatchRange): boolean => {\n  return (\n    (range1.start > range2.start && range1.start <= range2.end && range1.end > range2.end) ||\n    (range2.start > range1.start && range2.start <= range1.end && range2.end > range1.end)\n  );\n};\n\n/**\n * Callback function to sort ranges\n * @param {MatchRange} range1\n * @param {MatchRange} range2\n * @returns {number}\n */\nconst matchSorter = (range1: MatchRange, range2: MatchRange): number => {\n  if (range1.start === range2.start) {\n    return range2.end - range1.end;\n  }\n\n  return range1.start - range2.start;\n};\n\n/**\n * Recursive function to generate nested matches structure by inserting it at the right place\n * @param {EntityMatch} match\n * @param {EntityMatch[]} nestedMatches\n * @returns {EntityMatch[]}\n */\nconst insertIntoNestedMatches: (\n  match: EntityMatch,\n  nestedMatches: EntityMatch[]\n) => EntityMatch[] = (match: EntityMatch, nestedMatches: EntityMatch[]): EntityMatch[] => {\n  const updatedNestedMatches = [...nestedMatches];\n  let isInserted = false;\n\n  for (let index = 0; index < nestedMatches.length; index += 1) {\n    const matchInArr = nestedMatches[index];\n\n    if (isNesting(match, matchInArr)) {\n      if (match.end - match.start <= matchInArr.end - matchInArr.start) {\n        // The range of existing match in array is either larger or equal, so new match can be a child.\n        if (matchInArr.children && matchInArr.children.length > 0) {\n          // Recursive call\n          const updatedChildren = insertIntoNestedMatches(match, matchInArr.children);\n          // Update matchInArr in the newOverlapsArray\n          matchInArr.children = updatedChildren;\n        } else {\n          matchInArr.children = [match];\n        }\n        updatedNestedMatches.splice(index, 1, matchInArr);\n        isInserted = true;\n        break;\n      } else {\n        // Replace the existing match and make it the child of current match\n        updatedNestedMatches.splice(index, 1, { ...match, children: [matchInArr] });\n        isInserted = true;\n        break;\n      }\n    }\n\n    if (isIntersecting(match, matchInArr)) {\n      // Intersection\n      // We are only keeping the first match and discarding the following match\n      if (match.start < matchInArr.start) {\n        updatedNestedMatches.splice(index, 1, match);\n        isInserted = true;\n      } else {\n        isInserted = true;\n      }\n      break;\n    }\n  }\n\n  if (!isInserted) {\n    // Not nesting or intersecting\n    updatedNestedMatches.push(match);\n  }\n\n  return updatedNestedMatches;\n};\n\nconst getConsolidatedDescription = (match: EntityMatch) => {\n  const consolidatedDescription: { [name: string]: Set<string> } = {};\n\n  match.names?.forEach(name => {\n    if (!consolidatedDescription[name]) {\n      consolidatedDescription[name] = new Set();\n    }\n    consolidatedDescription[name].add(match.matchedText);\n  });\n\n  if (match.children && match.children.length > 0) {\n    match.children.forEach(nestedMatch => {\n      const nestMatchDesc = getConsolidatedDescription(nestedMatch);\n      Object.keys(nestMatchDesc).forEach(key => {\n        if (consolidatedDescription[key]) {\n          consolidatedDescription[key] = new Set([\n            ...consolidatedDescription[key],\n            ...nestMatchDesc[key]\n          ]);\n        } else {\n          consolidatedDescription[key] = nestMatchDesc[key];\n        }\n      });\n    });\n  }\n\n  return consolidatedDescription;\n};\n\nconst highlightEntitiesInTextNode = (\n  textNode: TextNode,\n  entityMapping: EmailProps['entityHighlightMapping']\n) => {\n  const matches: EntityMatch[] = [];\n  // Find all matches\n  entityMapping?.forEach(mapping => {\n    const escapedValue = mapping.value.replace(/[-[\\]{}()*+?.,\\\\^$|#\\s]/g, '\\\\$&');\n    // TODO - look-behind is not supported in safari at this point\n    // So we miss the use case of matching entities staring with non word characters like .5\n    // The best regex for webkit browsers is (?<=\\\\W|^)${escapedValue}(?=(\\\\W|$))\n    const regExp = new RegExp(`\\\\b${escapedValue}(?=(\\\\W|$))`, 'ig');\n    let res;\n    // eslint-disable-next-line no-cond-assign\n    while ((res = regExp.exec(textNode.value)) !== null) {\n      matches.push({\n        start: res.index,\n        end: res.index + res[0].length,\n        matchedText: res[0],\n        ...mapping\n      });\n    }\n  });\n\n  if (matches.length === 0) {\n    // Early exit as there are no matches\n    const newSpanNode: Element = {\n      nodeName: 'span',\n      tagName: 'span',\n      parentNode: textNode.parentNode,\n      attrs: [],\n      namespaceURI: '',\n      childNodes: []\n    };\n    newSpanNode.childNodes.push(textNode);\n    return newSpanNode;\n  }\n\n  matches.sort(matchSorter);\n\n  // Handle nesting and intersections\n  let nestedMatches: EntityMatch[] = [];\n  matches.forEach(match => {\n    nestedMatches = insertIntoNestedMatches(match, nestedMatches);\n  });\n\n  // Wrap matched ranges\n  let lastIndex = 0;\n  const updatedNodes: Node[] = [];\n  nestedMatches.sort(matchSorter);\n  nestedMatches.forEach(match => {\n    if (match.start !== lastIndex) {\n      const newSpanNode: Element = {\n        nodeName: 'span',\n        tagName: 'span',\n        parentNode: textNode.parentNode,\n        attrs: [],\n        namespaceURI: '',\n        childNodes: []\n      };\n\n      newSpanNode.childNodes.push({\n        ...textNode,\n        nodeName: '#text',\n        value: textNode.value.substring(lastIndex, match.start),\n        parentNode: newSpanNode\n      });\n\n      updatedNodes.push(newSpanNode);\n    }\n\n    const consolidatedDescription = getConsolidatedDescription(match);\n    let consolidatedDescriptionArray;\n    if (Object.entries(consolidatedDescription).length === 1) {\n      consolidatedDescriptionArray = [`${Object.keys(consolidatedDescription)[0]}`];\n    } else {\n      consolidatedDescriptionArray = Object.entries(consolidatedDescription).map(([key, value]) => {\n        return `${key}: ${[...value].join(', ')}`;\n      });\n    }\n\n    const newMarkNode: Element = {\n      nodeName: 'pega-email-entity',\n      tagName: 'pega-email-entity',\n      parentNode: textNode.parentNode,\n      attrs: [\n        { name: 'data-variant', value: `${match.variant}` },\n        { name: 'data-entity-type', value: match.type },\n        { name: 'data-description', value: JSON.stringify(consolidatedDescriptionArray) }\n      ],\n      namespaceURI: '',\n      childNodes: []\n    };\n\n    newMarkNode.childNodes.push({\n      nodeName: '#text',\n      value: match.matchedText,\n      parentNode: newMarkNode\n    });\n\n    updatedNodes.push(newMarkNode);\n\n    lastIndex = match.end;\n  });\n\n  if (lastIndex !== textNode.value.length) {\n    const newSpanNode: Element = {\n      nodeName: 'span',\n      tagName: 'span',\n      parentNode: textNode.parentNode,\n      attrs: [],\n      namespaceURI: '',\n      childNodes: []\n    };\n\n    newSpanNode.childNodes.push({\n      ...textNode,\n      nodeName: '#text',\n      value: textNode.value.substring(lastIndex),\n      parentNode: newSpanNode\n    } as TextNode);\n\n    updatedNodes.push(newSpanNode);\n  }\n\n  return updatedNodes;\n};\n\nconst highlightEntitiesInNode = (\n  node: Node,\n  entityMapping: EmailProps['entityHighlightMapping']\n) => {\n  // Either call self recursively or call mark entities in text\n  if (isParentNode(node) && node.childNodes?.length > 0) {\n    // Iteratively mark entities to all child nodes\n    let newChildNodes: Node[] = [];\n    node.childNodes.forEach(childNode => {\n      const res = highlightEntitiesInNode(childNode, entityMapping);\n      if (Array.isArray(res)) {\n        newChildNodes = [...newChildNodes, ...res];\n      } else {\n        newChildNodes.push(res as Node);\n      }\n    });\n    return { ...node, childNodes: newChildNodes };\n  }\n\n  if (node.nodeName === '#text') {\n    return highlightEntitiesInTextNode(node as TextNode, entityMapping);\n  }\n\n  return node;\n};\n\n/**\n * Function to highlight entities in a given html\n * @param {string} html\n * @param {EmailProps['entityHighlightMapping']} entityMapping\n * @returns {string}\n */\nconst highlightEntities = (\n  html: string,\n  entityMapping: EmailProps['entityHighlightMapping']\n): string => {\n  const document: Document = parse(html);\n\n  const markedDocument = highlightEntitiesInNode(document, entityMapping);\n\n  return serialize(markedDocument as Document);\n};\n\nexport default highlightEntities;\n"]}