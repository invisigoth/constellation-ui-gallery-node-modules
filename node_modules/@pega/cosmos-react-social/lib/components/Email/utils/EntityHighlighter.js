import { parse, serialize } from 'parse5';
const isParentNode = (node) => !!node &&
    node.nodeName !== '#text' &&
    node.nodeName !== '#comment' &&
    node.nodeName !== '#documentType';
/**
 * Function to check if there is nesting in the given ranges
 * @param {MatchRange} range1
 * @param {MatchRange} range2
 * @returns {boolean}
 */
const isNesting = (range1, range2) => {
    return ((range1.start >= range2.start && range1.end <= range2.end) ||
        (range2.start >= range1.start && range2.end <= range1.end));
};
/**
 * Function to check if there is an intersection in the ranges
 * @param {MatchRange} range1
 * @param {MatchRange} range2
 * @returns {boolean}
 */
const isIntersecting = (range1, range2) => {
    return ((range1.start > range2.start && range1.start <= range2.end && range1.end > range2.end) ||
        (range2.start > range1.start && range2.start <= range1.end && range2.end > range1.end));
};
/**
 * Callback function to sort ranges
 * @param {MatchRange} range1
 * @param {MatchRange} range2
 * @returns {number}
 */
const matchSorter = (range1, range2) => {
    if (range1.start === range2.start) {
        return range2.end - range1.end;
    }
    return range1.start - range2.start;
};
/**
 * Recursive function to generate nested matches structure by inserting it at the right place
 * @param {EntityMatch} match
 * @param {EntityMatch[]} nestedMatches
 * @returns {EntityMatch[]}
 */
const insertIntoNestedMatches = (match, nestedMatches) => {
    const updatedNestedMatches = [...nestedMatches];
    let isInserted = false;
    for (let index = 0; index < nestedMatches.length; index += 1) {
        const matchInArr = nestedMatches[index];
        if (isNesting(match, matchInArr)) {
            if (match.end - match.start <= matchInArr.end - matchInArr.start) {
                // The range of existing match in array is either larger or equal, so new match can be a child.
                if (matchInArr.children && matchInArr.children.length > 0) {
                    // Recursive call
                    const updatedChildren = insertIntoNestedMatches(match, matchInArr.children);
                    // Update matchInArr in the newOverlapsArray
                    matchInArr.children = updatedChildren;
                }
                else {
                    matchInArr.children = [match];
                }
                updatedNestedMatches.splice(index, 1, matchInArr);
                isInserted = true;
                break;
            }
            else {
                // Replace the existing match and make it the child of current match
                updatedNestedMatches.splice(index, 1, { ...match, children: [matchInArr] });
                isInserted = true;
                break;
            }
        }
        if (isIntersecting(match, matchInArr)) {
            // Intersection
            // We are only keeping the first match and discarding the following match
            if (match.start < matchInArr.start) {
                updatedNestedMatches.splice(index, 1, match);
                isInserted = true;
            }
            else {
                isInserted = true;
            }
            break;
        }
    }
    if (!isInserted) {
        // Not nesting or intersecting
        updatedNestedMatches.push(match);
    }
    return updatedNestedMatches;
};
const getConsolidatedDescription = (match) => {
    const consolidatedDescription = {};
    match.names?.forEach(name => {
        if (!consolidatedDescription[name]) {
            consolidatedDescription[name] = new Set();
        }
        consolidatedDescription[name].add(match.matchedText);
    });
    if (match.children && match.children.length > 0) {
        match.children.forEach(nestedMatch => {
            const nestMatchDesc = getConsolidatedDescription(nestedMatch);
            Object.keys(nestMatchDesc).forEach(key => {
                if (consolidatedDescription[key]) {
                    consolidatedDescription[key] = new Set([
                        ...consolidatedDescription[key],
                        ...nestMatchDesc[key]
                    ]);
                }
                else {
                    consolidatedDescription[key] = nestMatchDesc[key];
                }
            });
        });
    }
    return consolidatedDescription;
};
const highlightEntitiesInTextNode = (textNode, entityMapping) => {
    const matches = [];
    // Find all matches
    entityMapping?.forEach(mapping => {
        const escapedValue = mapping.value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
        // TODO - look-behind is not supported in safari at this point
        // So we miss the use case of matching entities staring with non word characters like .5
        // The best regex for webkit browsers is (?<=\\W|^)${escapedValue}(?=(\\W|$))
        const regExp = new RegExp(`\\b${escapedValue}(?=(\\W|$))`, 'ig');
        let res;
        // eslint-disable-next-line no-cond-assign
        while ((res = regExp.exec(textNode.value)) !== null) {
            matches.push({
                start: res.index,
                end: res.index + res[0].length,
                matchedText: res[0],
                ...mapping
            });
        }
    });
    if (matches.length === 0) {
        // Early exit as there are no matches
        const newSpanNode = {
            nodeName: 'span',
            tagName: 'span',
            parentNode: textNode.parentNode,
            attrs: [],
            namespaceURI: '',
            childNodes: []
        };
        newSpanNode.childNodes.push(textNode);
        return newSpanNode;
    }
    matches.sort(matchSorter);
    // Handle nesting and intersections
    let nestedMatches = [];
    matches.forEach(match => {
        nestedMatches = insertIntoNestedMatches(match, nestedMatches);
    });
    // Wrap matched ranges
    let lastIndex = 0;
    const updatedNodes = [];
    nestedMatches.sort(matchSorter);
    nestedMatches.forEach(match => {
        if (match.start !== lastIndex) {
            const newSpanNode = {
                nodeName: 'span',
                tagName: 'span',
                parentNode: textNode.parentNode,
                attrs: [],
                namespaceURI: '',
                childNodes: []
            };
            newSpanNode.childNodes.push({
                ...textNode,
                nodeName: '#text',
                value: textNode.value.substring(lastIndex, match.start),
                parentNode: newSpanNode
            });
            updatedNodes.push(newSpanNode);
        }
        const consolidatedDescription = getConsolidatedDescription(match);
        let consolidatedDescriptionArray;
        if (Object.entries(consolidatedDescription).length === 1) {
            consolidatedDescriptionArray = [`${Object.keys(consolidatedDescription)[0]}`];
        }
        else {
            consolidatedDescriptionArray = Object.entries(consolidatedDescription).map(([key, value]) => {
                return `${key}: ${[...value].join(', ')}`;
            });
        }
        const newMarkNode = {
            nodeName: 'pega-email-entity',
            tagName: 'pega-email-entity',
            parentNode: textNode.parentNode,
            attrs: [
                { name: 'data-variant', value: `${match.variant}` },
                { name: 'data-entity-type', value: match.type },
                { name: 'data-description', value: JSON.stringify(consolidatedDescriptionArray) }
            ],
            namespaceURI: '',
            childNodes: []
        };
        newMarkNode.childNodes.push({
            nodeName: '#text',
            value: match.matchedText,
            parentNode: newMarkNode
        });
        updatedNodes.push(newMarkNode);
        lastIndex = match.end;
    });
    if (lastIndex !== textNode.value.length) {
        const newSpanNode = {
            nodeName: 'span',
            tagName: 'span',
            parentNode: textNode.parentNode,
            attrs: [],
            namespaceURI: '',
            childNodes: []
        };
        newSpanNode.childNodes.push({
            ...textNode,
            nodeName: '#text',
            value: textNode.value.substring(lastIndex),
            parentNode: newSpanNode
        });
        updatedNodes.push(newSpanNode);
    }
    return updatedNodes;
};
const highlightEntitiesInNode = (node, entityMapping) => {
    // Either call self recursively or call mark entities in text
    if (isParentNode(node) && node.childNodes?.length > 0) {
        // Iteratively mark entities to all child nodes
        let newChildNodes = [];
        node.childNodes.forEach(childNode => {
            const res = highlightEntitiesInNode(childNode, entityMapping);
            if (Array.isArray(res)) {
                newChildNodes = [...newChildNodes, ...res];
            }
            else {
                newChildNodes.push(res);
            }
        });
        return { ...node, childNodes: newChildNodes };
    }
    if (node.nodeName === '#text') {
        return highlightEntitiesInTextNode(node, entityMapping);
    }
    return node;
};
/**
 * Function to highlight entities in a given html
 * @param {string} html
 * @param {EmailProps['entityHighlightMapping']} entityMapping
 * @returns {string}
 */
const highlightEntities = (html, entityMapping) => {
    const document = parse(html);
    const markedDocument = highlightEntitiesInNode(document, entityMapping);
    return serialize(markedDocument);
};
export default highlightEntities;
//# sourceMappingURL=EntityHighlighter.js.map