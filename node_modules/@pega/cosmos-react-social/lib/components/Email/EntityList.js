import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useState, useEffect, useImperativeHandle } from 'react';
import { Text, Flex, Icon, Card, CardHeader, CardContent, useScrollToggle, useElement, useOuterEvent, EmptyState, useConsolidatedRef } from '@pega/cosmos-react-core';
import ContextMenuPopover from './ContextMenuPopover';
import { StyledEntityList } from './Email.styles';
import EmailEntity from './EmailEntity';
const EntityList = forwardRef(function EntityList({ content, header, contextMenu }, ref) {
    const [popoverOpen, setPopoverOpen] = useState(false);
    const [currentTarget, setCurrentTarget] = useState();
    const { disableScroll, enableScroll } = useScrollToggle();
    // Only way to set this is through imperative handle
    const [contextMenuItems, setContextMenuItems] = useState([]);
    const [contextMenuLoading, setContextMenuLoading] = useState(false);
    const [popoverEl, setPopoverEl] = useElement();
    const popoverRef = useConsolidatedRef(setPopoverEl, contextMenu?.popoverRef);
    useOuterEvent('mousedown', [popoverEl], () => {
        if (popoverOpen)
            setPopoverOpen(false);
    });
    useImperativeHandle(contextMenu?.handle, () => ({
        setItems: (ctxMenuItems) => {
            setContextMenuItems(ctxMenuItems || []);
        },
        setLoading(loading) {
            setContextMenuLoading(loading);
        },
        setOpen(visible) {
            setPopoverOpen(visible);
        }
    }));
    // Handler for right click
    const onContextMenu = (e) => {
        if (e.target instanceof HTMLElement && e.target.textContent?.trim()) {
            setCurrentTarget({
                targetNode: e.target,
                cursorPosition: {
                    x: e.pageX - window.scrollX,
                    y: e.pageY - window.scrollY
                }
            });
            contextMenu?.onContextMenu(e);
        }
    };
    const onItemClick = (selectedValue) => {
        setPopoverOpen(false);
        contextMenu?.onItemClick(selectedValue);
    };
    const fields = content.map(data => {
        return data.value
            ? {
                ...data,
                value: (
                // Attach the handler only when context menu is enabled
                _jsx(Flex, { container: { gap: 0.5, wrap: 'wrap' }, onContextMenu: onContextMenu, children: data.value.map(entityObject => {
                        return _jsx(EmailEntity, { entity: entityObject.entity }, entityObject.id);
                    }) }))
            }
            : data;
    });
    useEffect(() => {
        if (popoverOpen)
            disableScroll();
        else
            enableScroll();
    }, [popoverOpen]);
    return (_jsxs(Card, { ref: ref, children: [header && (_jsxs(CardHeader, { container: { alignItems: 'center', gap: 1 }, children: [_jsx(Icon, { name: header.icon }), _jsx(Text, { variant: 'h3', children: header.text })] })), content.length > 0 ? (_jsxs(CardContent, { children: [_jsx(StyledEntityList, { fields: fields, variant: 'stacked' }), contextMenu && currentTarget && (_jsx(ContextMenuPopover, { ref: popoverRef, cursorPosition: currentTarget?.cursorPosition, contextMenu: {
                            ...contextMenu,
                            items: contextMenuItems,
                            loading: contextMenuLoading,
                            onItemClick
                        }, targetNode: currentTarget.targetNode, show: popoverOpen }))] })) : (_jsx(EmptyState, {}))] }));
});
export default EntityList;
//# sourceMappingURL=EntityList.js.map