import { createElement as _createElement } from "react";
import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useState, useMemo, useRef, useImperativeHandle, useEffect } from 'react';
import styled, { css } from 'styled-components';
import { stripUnit } from 'polished';
import { Button, Flex, Icon, registerIcon, useI18n, defaultThemeProp, FileUploadItem, MenuButton, Input, Modal, useModalManager, useModalContext, Grid, ComboBox, menuHelpers, createStringMatcher } from '@pega/cosmos-react-core';
import { Editor } from '@pega/cosmos-react-rte';
import * as paperClipIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/paper-clip.icon';
import * as replyAllIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/reply-all.icon';
import * as replyIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/reply.icon';
import * as forwardIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/forward.icon';
import EmailSelector from './EmailSelector';
registerIcon(paperClipIcon, replyAllIcon, replyIcon, forwardIcon);
export const StyledEmailComposer = styled.div(({ progress }) => {
    return css `
    ${progress
        ? css `
          visibility: hidden;
        `
        : css `
          visibility: visible;
        `}
  `;
});
export const StyledResponseTypeIcon = styled(Icon)(({ theme }) => {
    return css `
    color: ${theme.base.palette.interactive};
  `;
});
StyledResponseTypeIcon.defaultProps = defaultThemeProp;
export const StyledToggleButton = styled(Button)(({ theme }) => {
    return css `
    margin-block-start: calc(2 * ${theme.base.spacing});
    color: ${theme.base.palette.interactive};
  `;
});
StyledToggleButton.defaultProps = defaultThemeProp;
const StyledResponseType = styled(MenuButton) `
  align-self: flex-start;
`;
StyledResponseType.defaultProps = defaultThemeProp;
export const StyledModal = styled(Modal)(({ state, theme }) => {
    if (state !== 'docked')
        return;
    return css `
    max-height: calc(100vh - ${theme.base.spacing} * 4);
  `;
});
StyledModal.defaultProps = defaultThemeProp;
const responseTypeIcons = {
    reply: 'reply',
    replyAll: 'reply-all',
    forward: 'forward'
};
const editorToolbar = [
    'inline-styling',
    'lists',
    'indentation',
    'images',
    'links'
];
const ComposerModal = ({ modalContent, actions: modalActions, progress: modalProgress, subject, onCancel, compose }) => {
    const { state } = useModalContext();
    const t = useI18n();
    return (_jsx(StyledModal, { heading: compose ? t('compose_label') : subject.value, onRequestDismiss: () => {
            onCancel();
            return false;
        }, actions: !modalProgress ? modalActions : undefined, progress: modalProgress, state: state, children: modalContent }));
};
const createEmailTemplates = (selectedTemplateId, templates = []) => {
    return templates.map(template => {
        return {
            id: template.id,
            primary: template.title,
            items: template.templates
                ? createEmailTemplates(selectedTemplateId, template.templates)
                : undefined,
            selected: template.id === selectedTemplateId
        };
    });
};
const EmailComposer = forwardRef(function EmailComposer({ participants, senderAccounts, onCancel, onSend, onSave, onImageAdded, externalValidator, onChange, footerMoreActions, progress = false, templates, data: { to, cc, bcc, responseType, subject, bodyContent, selectedTemplateId, attachments, emailAccount }, handle, onEditorInit, ...restProps }, ref) {
    const t = useI18n();
    const { create: createModal } = useModalManager();
    const [userCCToggleState, setUserCCToggleState] = useState(false);
    const [userBCCToggleState, setUserBCCToggleState] = useState(false);
    const [editorContent, setEditorContent] = useState('');
    const [filterValue, setFilterValue] = useState('');
    const filterRegex = createStringMatcher(filterValue, 'contains');
    const compose = useMemo(() => {
        return !!(senderAccounts && senderAccounts.length > 0);
    }, [senderAccounts]);
    const emailTemplatesToRender = useMemo(() => {
        const emailTemplates = createEmailTemplates(selectedTemplateId, templates);
        const newItems = filterValue
            ? menuHelpers.flatten(emailTemplates).filter(({ primary }) => {
                return filterRegex.test(primary);
            })
            : emailTemplates;
        return menuHelpers.mapTree(newItems, item => ({
            ...item,
            selected: item.items ? undefined : item.selected
        }));
    }, [filterValue, selectedTemplateId, templates]);
    const selectedEmailTemplate = useMemo(() => {
        return menuHelpers.getSelected(emailTemplatesToRender)[0];
    }, [emailTemplatesToRender]);
    const editorRef = useRef(null);
    const fileUploadInputRef = useRef(null);
    const modalMethods = useRef();
    const responseTypeMenuData = useMemo(() => {
        const menuItems = [
            {
                id: 'reply',
                primary: t('reply'),
                visual: _jsx(StyledResponseTypeIcon, { name: responseTypeIcons.reply }),
                selected: responseType === 'reply',
                onClick: () => {
                    onChange('responseType', 'reply');
                }
            },
            {
                id: 'replyAll',
                primary: t('reply_all'),
                visual: _jsx(StyledResponseTypeIcon, { name: responseTypeIcons.replyAll }),
                selected: responseType === 'replyAll',
                onClick: () => {
                    onChange('responseType', 'replyAll');
                }
            },
            {
                id: 'forward',
                primary: t('forward'),
                visual: _jsx(StyledResponseTypeIcon, { name: responseTypeIcons.forward }),
                selected: responseType === 'forward',
                onClick: () => {
                    onChange('responseType', 'forward');
                }
            }
        ];
        return {
            menuItems,
            selectedResponseType: menuItems.find(item => item.selected)?.primary || menuItems[0].primary,
            selectedResponseTypeIcon: (responseType && responseTypeIcons[responseType]) || responseTypeIcons.reply
        };
    }, [responseType]);
    const onAttachmentDelete = (name) => {
        onChange('attachments', attachments?.filter(item => item.name !== name) || []);
    };
    const onFileChange = (e) => {
        if (e.target.files) {
            const newFiles = Array.from(e.target.files).map(file => ({ name: file.name, file }));
            onChange('attachments', attachments ? [...attachments, ...newFiles] : newFiles);
        }
    };
    useImperativeHandle(handle, () => ({
        replaceBodyContent: (contentToReplace) => {
            editorRef.current?.insertHtml(contentToReplace, true);
            // Triggering onChange manually with new content as onChange on RTE is not triggered automatically for insertHTML
            onChange('bodyContent', editorRef.current?.getHtml() || '');
        },
        updateImage: (imageData, id) => {
            editorRef.current?.appendImage(imageData, id);
            // Triggering onChange manually as onChange on RTE is not triggered automatically for appendImage
            onChange('bodyContent', editorRef.current?.getHtml() || '');
        },
        activate: () => {
            modalMethods.current?.activate();
        },
        setCursorLocationToStart: () => {
            editorRef.current?.setCursorLocationToStart?.();
        }
    }));
    const hasCC = useMemo(() => !!cc?.value?.length, [cc]);
    const hasBCC = useMemo(() => !!bcc?.value?.length, [bcc]);
    const content = (_jsxs(Flex, { as: StyledEmailComposer, ...restProps, container: {
            gap: 2,
            direction: 'column'
        }, progress: !!progress, ref: ref, children: [senderAccounts && senderAccounts.length > 0 && (_jsx(EmailSelector, { participants: senderAccounts, selectedItems: emailAccount ? [emailAccount.value] : [], label: t('email_account'), mode: 'single-select', required: true, onSelectedItemChange: (selectedItems) => {
                    onChange('emailAccount', selectedItems[0]);
                }, status: emailAccount?.error ? 'error' : undefined, info: emailAccount?.error, compose: true })), responseType && (_jsx(StyledResponseType, { text: responseTypeMenuData.selectedResponseType, variant: 'link', icon: responseTypeMenuData.selectedResponseTypeIcon, menu: {
                    mode: 'single-select',
                    items: responseTypeMenuData.menuItems
                } })), _jsxs(Flex, { container: {
                    alignItems: 'start',
                    gap: 0.5
                }, children: [_jsx(Flex, { container: {
                            gap: 1,
                            direction: 'column'
                        }, item: {
                            grow: 1
                        }, children: _jsx(EmailSelector, { participants: participants, selectedItems: to?.value || [], label: t('to'), mode: 'multi-select', required: true, onSelectedItemChange: (selectedItems) => {
                                onChange('to', selectedItems);
                            }, externalValidator: externalValidator, status: to?.error ? 'error' : undefined, info: to?.error }) }), !(userCCToggleState || hasCC) && (_jsx(StyledToggleButton, { variant: 'simple', onClick: () => setUserCCToggleState(true), icon: true, children: t('cc') })), !(userBCCToggleState || hasBCC) && (_jsx(StyledToggleButton, { variant: 'simple', onClick: () => setUserBCCToggleState(true), icon: true, children: t('bcc') }))] }), (userCCToggleState || hasCC) && (_jsx(EmailSelector, { participants: participants, selectedItems: cc?.value || [], label: t('cc'), mode: 'multi-select', onSelectedItemChange: (selectedItems) => onChange('cc', selectedItems), externalValidator: externalValidator, status: cc?.error ? 'error' : undefined, info: cc?.error })), (userBCCToggleState || hasBCC) && (_jsx(EmailSelector, { participants: participants, selectedItems: bcc?.value || [], label: t('bcc'), mode: 'multi-select', onSelectedItemChange: (selectedItems) => onChange('bcc', selectedItems), externalValidator: externalValidator, status: bcc?.error ? 'error' : undefined, info: bcc?.error })), _jsx(Input, { value: subject.value, onChange: (e) => onChange('subject', e.target.value), label: t('subject'), status: subject.error ? 'error' : undefined, info: subject.error }), _jsx(ComboBox, { label: t('response_templates'), value: filterValue, mode: 'single-select', menu: {
                    items: emailTemplatesToRender,
                    onItemClick: (id) => {
                        setFilterValue('');
                        onChange('selectedTemplateId', id);
                    },
                    accent: filterRegex
                }, selected: selectedEmailTemplate
                    ? {
                        items: {
                            id: selectedEmailTemplate.id,
                            text: selectedEmailTemplate.primary
                        }
                    }
                    : undefined, onChange: (e) => {
                    if (!e.target.value)
                        onChange('selectedTemplateId', '');
                    setFilterValue(e.target.value);
                } }), _jsx(Editor, { autoFocus: true, ref: editorRef, toolbar: editorToolbar, onImageAdded: onImageAdded, labelHidden: true, label: t('email_message'), defaultValue: editorContent || bodyContent.defaultValue, 
                // Below rem values are derived from min 150px, max 300px minus the approx height of toolbar
                height: {
                    min: stripUnit('7rem') * 16,
                    max: stripUnit('16.5rem') * 16
                }, status: bodyContent.error ? 'error' : undefined, info: bodyContent.error, onChange: () => {
                    const currentHtml = editorRef?.current?.getHtml() || '';
                    setEditorContent(currentHtml);
                    onChange('bodyContent', currentHtml);
                }, onInit: onEditorInit }), !!attachments?.length && (_jsx(Grid, { ref: ref, container: {
                    cols: 'repeat(auto-fill, minmax(15rem, 1fr))',
                    gap: 1
                }, children: attachments?.map(attachment => (_createElement(FileUploadItem, { ...attachment, key: attachment.name, onDelete: onAttachmentDelete }))) }))] }));
    const footerContent = (_jsx(Flex, { container: {
            gap: 1,
            direction: 'column'
        }, item: { grow: 1 }, children: _jsxs(Flex, { container: {
                gap: 1
            }, children: [_jsxs(Flex, { container: true, item: { grow: 1 }, children: [_jsx(Button, { variant: 'secondary', onClick: () => {
                                onCancel();
                            }, children: t('cancel') }), footerMoreActions] }), _jsxs(Flex, { container: true, children: [_jsx(Button, { icon: true, onClick: () => fileUploadInputRef.current?.click(), variant: 'simple', label: t('file_upload_text_multiple'), children: _jsx(Icon, { name: 'paper-clip' }) }), onSave && _jsx(Button, { onClick: onSave, children: t('save_as_draft') }), _jsx(Button, { variant: 'primary', onClick: onSend, children: t('send') })] }), _jsx("input", { type: 'file', style: { display: 'none' }, ref: fileUploadInputRef, onChange: onFileChange, multiple: true })] }) }));
    // Create modal on mount
    useEffect(() => {
        modalMethods.current = createModal(ComposerModal, { modalContent: content, actions: footerContent, progress, subject, onCancel, compose }, { minimizable: true, maximizable: true, dockable: true });
        return () => {
            // Will close the modal on unmount
            modalMethods.current?.dismiss();
            modalMethods.current?.unmount();
        };
    }, []);
    useEffect(() => {
        modalMethods.current?.update({
            modalContent: content,
            actions: footerContent,
            progress,
            subject,
            onCancel,
            compose
        });
    });
    return null;
});
export default EmailComposer;
//# sourceMappingURL=EmailComposer.js.map