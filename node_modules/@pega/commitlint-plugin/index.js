'use strict';

const { fork } = require('child_process');

// Type rules as Record<string, Rule<any>> to allow it to match Plugin type while still having types for rule parameters.
const /** @type {{ rules: Record<string, import('@commitlint/types').Rule<any>> } }} */ Plugin = {
    rules: {
      '@pega/multi-scope-enum':
        /** @satisfies {import('@commitlint/types').SyncRule<{ scopes?: string[]; separator?: string | RegExp; trim?: boolean; }>} */
        (
          { scope },
          enable = 'always',
          { scopes = [], separator = /\\|\/|,/, trim = false } = {}
        ) => {
          if (!scope || !scopes.length) return [true, ''];

          if (enable === 'always') {
            return [
              scope.split(separator).every(s => scopes.includes(trim ? s.trim() : s)),
              `Scope must be one or more of the following [${scopes.join(', ')}].`
            ];
          }

          // enable === 'never'
          return [
            !scope.split(separator).some(s => scopes.includes(trim ? s.trim() : s)),
            `Scope must not be one or more of the following [${scopes.join(', ')}].`
          ];
        },

      '@pega/header-reference':
        /** @satisfies {import('@commitlint/types').SyncRule} */
        ({ header, references }, enable = 'always') => {
          if (!header) return [true, ''];

          if (enable === 'always') {
            return [
              references.some(({ raw }) => header.includes(raw)),
              'Header must contain a reference id.'
            ];
          }

          // enable === 'never'
          return [
            !references.some(({ raw }) => header.includes(raw)),
            'Header must not contain a reference id.'
          ];
        },

      '@pega/reference-action-enum':
        /** @satisfies {import('@commitlint/types').SyncRule<{ actions?: string[]; caseSensitive?: boolean; }>} */
        (
          { references },
          enable = 'always',
          {
            actions = [
              'close',
              'closes',
              'closed',
              'fix',
              'fixes',
              'fixed',
              'resolve',
              'resolves',
              'resolved'
            ],
            caseSensitive = false
          } = {}
        ) => {
          if (!references.length) return [true, ''];

          if (!caseSensitive) actions = actions.map(action => action.toLowerCase());

          if (enable === 'always') {
            return [
              references.every(
                ({ action }) =>
                  action && actions.includes(caseSensitive ? action : action.toLowerCase())
              ),
              `Reference action must be one or more of the following [${actions.join(', ')}].`
            ];
          }

          // enable === 'never'
          return [
            !references.some(
              ({ action }) =>
                action && actions.includes(caseSensitive ? action : action.toLowerCase())
            ),
            `Reference action must not be one or more of the following [${actions.join(', ')}].`
          ];
        },

      '@pega/reference-order':
        /** @satisfies {import('@commitlint/types').SyncRule<{ prefixes?: string[]; ascending?: boolean; }>} */
        ({ references }, enable = 'always', { prefixes = ['#'], ascending = true } = {}) => {
          if (references.length < 2 || enable !== 'always') return [true, ''];

          /** @type {{ [prefix: string]: string[][]; }} */
          const referenceMap = {};

          let highestPrefixIndex = -1;
          for (const { prefix, issue } of references) {
            if (issue) {
              const idx = prefixes.findIndex(p => p === prefix);

              // Check prefixes are ordered.
              if (highestPrefixIndex > idx) {
                return [
                  false,
                  `References must be in the following order [${prefixes.join(', ')}].`
                ];
              }

              // Group reference id's by prefix.
              if (!referenceMap[prefix]) referenceMap[prefix] = [];
              referenceMap[prefix].push(issue.split(/\D+/));

              highestPrefixIndex = idx;
            }
          }

          // Check id's are ordered.
          for (const refs of Object.values(referenceMap).filter(r => r.length >= 2)) {
            if (!ascending) refs.reverse();

            for (let refIdx = 0; refIdx < refs.length - 1; refIdx += 1) {
              const refA = refs[refIdx];
              const refB = refs[refIdx + 1];

              for (let partIdx = 0; partIdx < Math.max(refA.length, refB.length); partIdx += 1) {
                const refAPart = Number.parseInt(refA[partIdx] ?? '0', 10);
                const refBPart = Number.parseInt(refB[partIdx] ?? '0', 10);

                if (refAPart < refBPart) break;
                else if (refAPart > refBPart) {
                  return [
                    false,
                    `References must be in ${ascending ? 'ascending' : 'descending'} order.`
                  ];
                }
              }
            }
          }

          return [true, ''];
        },

      '@pega/agile-studio':
        /** @satisfies {import('@commitlint/types').SyncRule<{ prefixes?: string[]; }>} */
        ({ footer }, enable = 'always', { prefixes = ['#'] } = {}) => {
          if (enable !== 'always' || !footer) return [true, ''];

          if (footer.indexOf('AgileStudio:') !== footer.lastIndexOf('AgileStudio:')) {
            return [false, 'Multiple Agile Studio notes found.'];
          }

          const [, agileStudioNote] = /^AgileStudio:(.+)$/m.exec(footer) ?? [];

          if (!agileStudioNote) return [true, ''];

          if (!agileStudioNote.startsWith(' ')) {
            return [false, 'Agile Studio note should have a space after the colon.'];
          }

          if (agileStudioNote.endsWith('.')) {
            return [false, 'Agile Studio note should not end in a period.'];
          }

          if (/,[^ ]/.test(agileStudioNote)) {
            return [false, 'Agile Studio ids should be separated by a comma and space.'];
          }

          // Check if id is a case id.
          const idRegExp = new RegExp(`^(?:${prefixes.join('|')})[0-9-]+$`);

          for (const id of agileStudioNote.slice(1).split(', ')) {
            if (!idRegExp.test(id)) {
              return [false, `Agile Studio id does not match expected format "${id}".`];
            }
          }

          return [true, ''];
        },

      '@pega/open-agile':
        /** @satisfies {import('@commitlint/types').SyncRule<{ prefixes?: string[]; }>} */
        ({ footer }, enable = 'always', { prefixes = ['#'] } = {}) => {
          if (enable !== 'always' || !footer) return [true, ''];

          if (footer.indexOf('OpenAgile:') !== footer.lastIndexOf('OpenAgile:')) {
            return [false, 'Multiple Open Agile notes found.'];
          }

          const [, openAgileNote] = /^OpenAgile:(.+)$/m.exec(footer) ?? [];

          if (!openAgileNote) return [true, ''];

          if (!openAgileNote.startsWith(' ')) {
            return [false, 'Open Agile note should have a space after the colon.'];
          }

          if (openAgileNote.endsWith('.')) {
            return [false, 'Open Agile note should not end in a period.'];
          }

          if (/,[^ ]/.test(openAgileNote)) {
            return [false, 'Open Agile id pairs should be separated by a comma and space.'];
          }

          // Check if id pair is a case id followed by a base64 hash.
          const idPairRegExp = new RegExp(`^(?:${prefixes.join('|')})[A-Z0-9]+ [a-zA-Z0-9=_-]+$`);

          for (const idPair of openAgileNote.slice(1).split(', ')) {
            if (!idPairRegExp.test(idPair)) {
              return [false, `Open Agile id pair does not match expected format "${idPair}".`];
            }
          }

          return [true, ''];
        },

      '@pega/merge-commit':
        /** @satisfies {import('@commitlint/types').SyncRule} */
        ({ merge }, enable = 'never') => {
          if (enable !== 'never') return [true, ''];

          return [!merge, 'Merge commits are not allowed.'];
        },

      '@pega/revert-commit':
        /** @satisfies {import('@commitlint/types').SyncRule} */
        ({ revert }, enable = 'never') => {
          if (enable !== 'never') return [true, ''];

          return [!revert, 'Revert commits are not allowed.'];
        },

      '@pega/spellcheck':
        /** @satisfies {import('@commitlint/types').AsyncRule<{ ignorePrefixes?: string[]; }>} */
        async ({ raw }, enable = 'always', { ignorePrefixes = [] } = {}) => {
          if (enable !== 'always') return [true, ''];

          const cspell = fork(
            require.resolve('cspell/bin'),
            ['--no-summary', '--unique', 'stdin'],
            {
              stdio: 'pipe'
            }
          );

          cspell.stdin?.write(
            raw
              .split('\n')
              .filter(
                s => !s.startsWith('#') && ignorePrefixes.some(prefix => !s.startsWith(prefix))
              )
              .join('\n')
          );
          cspell.stdin?.end();

          /** @type {Buffer[]} */
          const out = [];
          let outLen = 0;
          cspell.stdout?.on('data', chunk => {
            out.push(chunk);
            outLen += Buffer.byteLength(chunk);
          });

          return new Promise(resolve => {
            cspell.on('exit', code => {
              if (code === 0) resolve([true, '']);

              const output = Buffer.concat(out, outLen).toString('utf-8');

              const words = [...output.matchAll(/^.+:\d+:\d+ - Unknown word \((.*)\)$/gm)].map(
                ([, word]) => word
              );

              resolve([
                false,
                `Unknown word${words.length === 1 ? '' : 's'} [${words.join(', ')}].`
              ]);
            });
          });
        }
    }
  };

module.exports = Plugin;
