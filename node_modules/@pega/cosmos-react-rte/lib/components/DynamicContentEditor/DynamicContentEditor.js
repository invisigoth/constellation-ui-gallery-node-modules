import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useRef, useEffect, useState } from 'react';
import styled from 'styled-components';
import { Button, defaultThemeProp, Menu, menuHelpers, Modal, Popover, StyledPopover, useModalManager, useConsolidatedRef, useI18n, useUID } from '@pega/cosmos-react-core';
import { getKeyCommand } from '@pega/cosmos-react-rte/lib/components/RichTextEditor/Toolbar/utils';
import { Editor } from '../Editor';
import { isFieldMenuItem } from './DynamicContentEditor.types';
import { pegaReferenceElementStyle, createPegaReferenceElement } from './PegaCustomElement';
const StyledDynamicContentEditor = styled.div ``;
export const StyledSearchPopover = styled(StyledPopover) `
  min-width: 20rem;
`;
StyledDynamicContentEditor.defaultProps = defaultThemeProp;
const DynamicContentEditor = forwardRef(function DynamicContentEditor({ form: { dynamicContentPicker, onSubmit }, onActiveFieldChange, label, toolbar, fieldItems, defaultValue, onBlur, ...restProps }, ref) {
    const menuID = useUID();
    const { create } = useModalManager();
    const t = useI18n();
    const modalMethods = useRef();
    const [editor, setEditor] = useState();
    const [bookmark, setBookmark] = useState();
    const [fieldMenuItems, setFieldMenuItems] = useState(fieldItems || []);
    const [currentElementId, setCurrentElementId] = useState('');
    const [currentElementContent, setCurrentElementContent] = useState('');
    const [currentElementNamespace, setCurrentElementNamespace] = useState('');
    const [currentCursorPosition, setCurrentCursorPosition] = useState({
        bottom: 0,
        height: 0,
        left: 0,
        right: 0,
        top: 0,
        width: 0,
        x: 0,
        y: 0,
        toJSON: () => { }
    });
    const [showFieldsPopover, setShowFieldsPopover] = useState(false);
    const fieldPopoverRef = useRef(null);
    const editorRef = useConsolidatedRef(ref);
    const tooltip = getKeyCommand(navigator.appVersion.includes('Mac'), ({ ctrl }) => `${t('rte_insert_field')} (${ctrl}/)`);
    const insertField = (field) => {
        if (!editor)
            return;
        const fieldContent = `<pega-reference role="button" contenteditable="false" data-rule-type='field' data-rule-id=${field.id} ${field.namespace && `data-rule-namespace=${field.namespace}`}>${field.text}</pega-reference>`;
        if (bookmark) {
            editor.selection.moveToBookmark(bookmark);
            editor.selection.setContent(fieldContent);
        }
        else {
            editor.insertContent(fieldContent);
        }
        modalMethods.current?.dismiss();
    };
    const modalProps = {
        children: dynamicContentPicker,
        heading: t('rte_insert_field'),
        actions: (_jsxs(_Fragment, { children: [_jsx(Button, { variant: 'secondary', onClick: () => modalMethods.current?.dismiss(), children: t('cancel') }), _jsx(Button, { variant: 'primary', onClick: () => onSubmit(insertField), children: t('submit') })] })),
        center: true,
        onAfterClose: () => {
            setBookmark(undefined);
            setCurrentElementId('');
            setCurrentElementContent('');
            setCurrentElementNamespace('');
            onActiveFieldChange({ id: '', text: '', namespace: '' });
        },
        onBeforeOpen: () => {
            if (currentElementId) {
                onActiveFieldChange({
                    id: currentElementId,
                    text: currentElementContent,
                    namespace: currentElementNamespace
                });
            }
        }
    };
    const findAndRenameField = (fieldId) => {
        if (!editor || !fieldMenuItems)
            return;
        const selectedRange = editor.selection.getRng();
        const endOffset = selectedRange.endOffset;
        const stringToSearch = selectedRange.commonAncestorContainer.nodeValue?.slice(0, endOffset);
        if (stringToSearch === undefined)
            return;
        const splitSearch = stringToSearch.split(' ');
        const fieldString = splitSearch[splitSearch.length - 1];
        const range = editor.getDoc().createRange();
        const startPos = stringToSearch.lastIndexOf(fieldString);
        const endPos = startPos + fieldString.length;
        range.setStart(selectedRange.commonAncestorContainer, startPos);
        range.setEnd(selectedRange.commonAncestorContainer, endPos);
        editor.getDoc().getSelection()?.removeAllRanges();
        editor.getDoc().getSelection()?.addRange(range);
        const selectedField = menuHelpers.getItem(fieldMenuItems, fieldId);
        if (selectedField && isFieldMenuItem(selectedField)) {
            editor.selection.setContent(`<pega-reference role="button" contenteditable="false" data-rule-type="field" data-rule-id="${selectedField.id}" ${selectedField.namespace && `data-rule-namespace=${selectedField.namespace}`}>${selectedField.primary}</pega-reference>`);
            setShowFieldsPopover(false);
        }
    };
    const hidePopover = () => {
        if (fieldPopoverRef)
            setShowFieldsPopover(false);
    };
    const filterFieldMenu = (searchString) => {
        setShowFieldsPopover(true);
        setFieldMenuItems(fieldItems || []);
        if (/\s/.test(searchString)) {
            setShowFieldsPopover(false);
            return;
        }
        if (searchString && fieldMenuItems) {
            const newFieldMenuItems = menuHelpers
                .flatten(fieldMenuItems)
                .filter(({ primary }) => primary.toLowerCase().startsWith(searchString.toLocaleLowerCase()));
            if (newFieldMenuItems) {
                setShowFieldsPopover(true);
                setFieldMenuItems(newFieldMenuItems);
            }
            else
                setShowFieldsPopover(false);
        }
    };
    const updateBookmarkAndCurrentElement = (editorSelection) => {
        const targetEl = editorSelection.getNode();
        const fieldId = targetEl.getAttribute('data-rule-id');
        const fieldNamespace = targetEl.getAttribute('data-rule-namespace');
        const fieldValue = targetEl.innerText;
        setBookmark(editorSelection.getBookmark());
        setCurrentElementId(fieldId || '');
        setCurrentElementContent(fieldValue);
        setCurrentElementNamespace(fieldNamespace || '');
    };
    const handleElementClick = ({ target }) => {
        if (editor && target && target.tagName === 'PEGA-REFERENCE') {
            updateBookmarkAndCurrentElement(editor.selection);
        }
        hidePopover();
    };
    const onInsertField = (incEditor) => {
        const targetEl = incEditor.selection.getNode();
        if (targetEl.tagName === 'PEGA-REFERENCE') {
            updateBookmarkAndCurrentElement(incEditor.selection);
        }
        else {
            modalMethods.current = create(Modal, modalProps);
        }
    };
    const isPegaRefActive = (incEditor) => {
        const targetEl = incEditor.selection.getNode();
        return targetEl.tagName === 'PEGA-REFERENCE';
    };
    const fieldSelectionPopover = (_jsx(Popover, { show: showFieldsPopover, strategy: 'fixed', ref: fieldPopoverRef, target: {
            getBoundingClientRect() {
                return currentCursorPosition;
            }
        }, modifiers: [
            {
                name: 'offset',
                options: {
                    offset: () => {
                        const iframe = editorRef.current?.element?.querySelector('iframe');
                        const iframeRect = iframe?.getBoundingClientRect();
                        const x = iframeRect?.x ?? 0;
                        const y = iframeRect?.y ?? 0;
                        return [x, y];
                    }
                }
            }
        ], placement: 'bottom-start', children: fieldMenuItems && (_jsx(Menu, { id: menuID, items: fieldMenuItems, as: StyledSearchPopover, focusControlEl: editor?.getBody() || undefined, mode: 'action', onItemClick: findAndRenameField, variant: 'drill-down' })) }));
    useEffect(() => {
        if (currentElementId && currentElementContent)
            modalMethods.current = create(Modal, modalProps);
    }, [currentElementId, currentElementContent]);
    useEffect(() => {
        editor?.getDoc().addEventListener('click', handleElementClick);
        return () => {
            editor?.getDoc().removeEventListener('click', handleElementClick);
        };
    }, [editor, editorRef.current]);
    useEffect(() => {
        if (modalMethods.current) {
            modalMethods.current.update(modalProps);
        }
    }, [modalProps]);
    const onEditorChange = (formEditor) => {
        if (formEditor) {
            const targetEl = formEditor.selection.getBoundingClientRect();
            const { left = 0, top = 0 } = targetEl ?? {};
            setCurrentCursorPosition({
                ...formEditor.selection.getBoundingClientRect(),
                x: left,
                y: top,
                toJSON: () => { }
            });
            if (formEditor.selection.isCollapsed()) {
                // get the full line string
                const selectedRange = formEditor.selection.getRng();
                const endOffset = selectedRange.endOffset;
                const stringToSearch = selectedRange.commonAncestorContainer.nodeValue?.slice(0, endOffset);
                const fieldString = stringToSearch?.split(' ')[stringToSearch.split(' ').length - 1];
                if (fieldString?.startsWith('@') &&
                    fieldString.indexOf('@') === fieldString.lastIndexOf('@')) {
                    filterFieldMenu(fieldString.slice(1));
                }
                else
                    setShowFieldsPopover(false);
            }
        }
    };
    const onKeyDown = event => {
        if ((event?.key === 'Enter' ||
            event?.key === 'ArrowLeft' ||
            event?.key === 'ArrowRight' ||
            event?.key === 'ArrowDown' ||
            event?.key === 'ArrowUp') &&
            !!fieldPopoverRef.current) {
            event?.preventDefault();
        }
        if (event?.key === 'Escape' && !!fieldPopoverRef.current) {
            hidePopover();
        }
    };
    return (_jsx(Editor, { ref: editorRef, ...restProps, label: label, toolbar: toolbar, customComponents: [
            {
                createCustomElement: createPegaReferenceElement,
                name: 'pega-reference',
                extensionAttributes: ['contenteditable'],
                style: pegaReferenceElementStyle
            }
        ], customActions: [
            {
                icon: 'code',
                text: tooltip,
                onMouseDown: () => {
                    modalMethods.current = create(Modal, modalProps);
                },
                active: isPegaRefActive,
                shortcut: {
                    pattern: 'meta+191',
                    description: tooltip,
                    command: onInsertField
                }
            }
        ], onInit: setEditor, onChange: onEditorChange, onBlur: () => {
            onBlur?.();
            hidePopover();
        }, onKeyDown: onKeyDown, defaultValue: defaultValue, children: fieldSelectionPopover }));
});
export default DynamicContentEditor;
//# sourceMappingURL=DynamicContentEditor.js.map