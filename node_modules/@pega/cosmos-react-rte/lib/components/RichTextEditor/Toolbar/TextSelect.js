import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useState, useCallback } from 'react';
import { Transforms } from 'slate';
import { ReactEditor, useSlate } from 'slate-react';
import styled, { css } from 'styled-components';
import { Popover, Icon, registerIcon, useOuterEvent, Menu, Button, defaultThemeProp, useI18n, Tooltip, calculateFontSize } from '@pega/cosmos-react-core';
import * as arrowMicroDownIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/arrow-micro-down.icon';
import EditorCommands from '../utils/EditorCommands';
import { useRTEContext } from '../RichTextEditor.context';
import { getKeyCommand } from './utils';
registerIcon(arrowMicroDownIcon);
const StyledTextSelect = styled(Button)(({ theme }) => {
    const fontSizes = calculateFontSize(theme.base['font-size'], theme.base['font-scale']);
    return css `
    color: ${theme.base.palette['foreground-color']};
    display: inline-flex;
    align-items: center;
    border-radius: calc(0.25 * ${theme.base['border-radius']});
    height: calc(4 * ${theme.base.spacing});
    padding: calc(0.5 * ${theme.base.spacing});
    font-size: ${fontSizes.xxs};

    span {
      white-space: nowrap;
    }

    :focus {
      box-shadow: ${theme.base.shadow.focus};
    }
  `;
});
StyledTextSelect.defaultProps = defaultThemeProp;
const StyledSelectMenu = styled.div `
  min-width: 10rem;
`;
const textMapping = {
    paragraph: 'Normal',
    'heading-1': 'Heading 1',
    'heading-2': 'Heading 2',
    'heading-3': 'Heading 3',
    'heading-4': 'Heading 4',
    '': 'Normal'
};
const getTextCommand = (num, osx) => {
    return getKeyCommand(osx, ({ ctrl, alt }) => `${ctrl}${alt}${num}`);
};
const getTextFormats = (osx) => {
    return [
        { text: 'Normal', subText: getTextCommand(0, osx), type: 'paragraph' },
        { text: 'Heading 1', subText: getTextCommand(1, osx), type: 'heading-1' },
        { text: 'Heading 2', subText: getTextCommand(2, osx), type: 'heading-2' },
        { text: 'Heading 3', subText: getTextCommand(3, osx), type: 'heading-3' },
        { text: 'Heading 4', subText: getTextCommand(4, osx), type: 'heading-4' }
    ];
};
const TextSelect = ({ osx }) => {
    const t = useI18n();
    const { disabled } = useRTEContext();
    const [open, setOpen] = useState(false);
    const selecting = useRef(false);
    const openedByClick = useRef(false);
    const buttonRef = useRef(null);
    const popoverRef = useRef(null);
    const menuRef = useRef(null);
    const editor = useSlate();
    const textFormats = useCallback(() => {
        return getTextFormats(osx);
    }, [osx])();
    useOuterEvent('click', [buttonRef, popoverRef, menuRef], () => {
        setOpen(false);
    });
    const onTextSelect = (type, e) => {
        e.stopPropagation();
        e.preventDefault();
        EditorCommands.setBlock(type, editor);
        if (!openedByClick.current) {
            buttonRef.current?.focus();
        }
        setOpen(false);
        selecting.current = true;
        setTimeout(() => {
            if (!ReactEditor.isFocused(editor) && openedByClick.current) {
                const selection = editor.selection;
                ReactEditor.focus(editor);
                if (selection)
                    Transforms.select(editor, selection);
            }
        }, 0);
    };
    return (_jsxs(_Fragment, { children: [_jsxs(StyledTextSelect, { variant: 'simple', type: 'button', disabled: disabled, icon: false, ref: buttonRef, onMouseDown: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setOpen(true);
                    openedByClick.current = true;
                }, onKeyDown: (e) => {
                    if (e.key === 'Enter' && !selecting.current) {
                        e.preventDefault();
                        setOpen(true);
                        openedByClick.current = false;
                    }
                    else if (e.key === 'Enter') {
                        e.preventDefault();
                        selecting.current = false;
                    }
                    else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        setOpen(false);
                    }
                }, onFocus: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, onClick: (e) => e.stopPropagation(), "aria-expanded": open, "aria-label": `Text formatting toolbar. ${t('rte_heading_style')}. ${textMapping[EditorCommands.getActiveBlockType(editor)]} selected`, "aria-haspopup": true, children: [_jsx("span", { children: textMapping[EditorCommands.getActiveBlockType(editor)] }), _jsx(Icon, { name: 'arrow-micro-down' })] }), buttonRef.current && (_jsx(Tooltip, { target: buttonRef.current, showDelay: 'none', hideDelay: 'none', children: t('rte_heading_style') })), _jsx(Popover, { show: open, as: StyledSelectMenu, target: buttonRef.current, placement: 'bottom-start', ref: popoverRef, children: _jsx(Menu, { items: textFormats.map(({ text, type, subText }) => ({
                        id: type,
                        primary: text,
                        secondary: [subText],
                        selected: type === EditorCommands.getActiveBlockType(editor)
                    })), focusControlEl: buttonRef.current || undefined, mode: 'single-select', ref: menuRef, onItemClick: onTextSelect }) })] }));
};
export default TextSelect;
//# sourceMappingURL=TextSelect.js.map