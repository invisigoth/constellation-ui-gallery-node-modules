import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useEffect, useRef } from 'react';
import { useSlate, useFocused, ReactEditor } from 'slate-react';
import styled, { css } from 'styled-components';
import { Flex, Icon, useArrows, useI18n, defaultThemeProp, navigatorIsAvailable } from '@pega/cosmos-react-core';
import EditorCommands from '../utils/EditorCommands';
import ListCommands from '../utils/ListCommands';
import ToolbarButton from './ToolbarButton';
import TableButton from './TableButton';
import AnchorButton from './AnchorButton';
import ImageButton from './ImageButton';
import TextSelect from './TextSelect';
import IndentButton from './IndentButton';
import { getKeyCommand } from './utils';
const StyledToolbar = styled.div(({ sticky, theme }) => {
    return css `
    background-color: ${props => props.theme.base.palette['primary-background']};
    border-radius: calc(0.25 * ${props => props.theme.base['border-radius']});
    overflow: auto;
    padding: 0.125rem;
    ${sticky &&
        css `
      position: sticky;
      bottom: 0;
    `}

    &:has(:focus-visible) {
      box-shadow: ${theme.base.shadow['focus-group']};
    }
  `;
});
StyledToolbar.defaultProps = defaultThemeProp;
const isMobile = navigatorIsAvailable && navigator.userAgent.includes('Mobile');
// Function that returns the text styling buttons
function renderStyleButtons(editor, t, focused, osx) {
    const inlineStyleButtons = [
        {
            style: 'BOLD',
            text: 'B',
            format: 'bold',
            label: t('rte_bold'),
            tooltip: isMobile
                ? `${t('rte_bold')}`
                : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_bold')} (${ctrl}B, ${ctrl}${shift}B)`)
        },
        {
            style: 'ITALIC',
            text: 'I',
            format: 'italic',
            label: t('rte_italic'),
            tooltip: isMobile
                ? `${t('rte_italic')}`
                : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_italic')} (${ctrl}I, ${ctrl}${shift}I)`)
        },
        {
            style: 'STRIKE-THROUGH',
            text: 'S',
            format: 'line-through',
            label: t('rte_strike_through'),
            tooltip: isMobile
                ? `${t('rte_strike_through')}`
                : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_strike_through')} (${ctrl}${shift}X)`)
        }
    ];
    return inlineStyleButtons.map(({ format, style, text, label, tooltip }) => {
        return (_jsx(ToolbarButton, { onMouseDown: e => {
                e.preventDefault();
                if (!focused) {
                    ReactEditor.focus(editor);
                }
                setTimeout(() => {
                    EditorCommands.toggleFormat(format, editor);
                }, 0);
            }, styleType: style, active: EditorCommands.isFormatActive(format, editor), tooltip: tooltip, label: label, children: text }, style));
    });
}
// Function that returns the cut, copy and paste buttons
function renderCutCopyPaste(editor, t, osx) {
    const CutCopyPasteButtons = [
        {
            text: 'Cut',
            icon: 'scissors',
            label: t('rte_cut'),
            func: () => {
                document.execCommand('cut');
            },
            tooltip: getKeyCommand(osx, ({ ctrl }) => `${t('rte_cut')} (${ctrl}X)`)
        },
        {
            text: 'Copy',
            icon: 'copy',
            label: t('rte_copy'),
            func: () => {
                document.execCommand('copy');
            },
            tooltip: getKeyCommand(osx, ({ ctrl }) => `${t('rte_copy')} (${ctrl}C)`)
        },
        {
            text: 'Paste',
            icon: 'clipboard-data',
            label: t('rte_paste'),
            func: () => {
                navigator.clipboard.readText().then(text => {
                    EditorCommands.replaceWithText(editor, editor.selection, text);
                });
            },
            tooltip: getKeyCommand(osx, ({ ctrl }) => `${t('rte_paste')} (${ctrl}V)`)
        }
    ];
    return CutCopyPasteButtons.map(btn => {
        return (_jsx(ToolbarButton, { onMouseDown: e => {
                e.preventDefault();
                btn.func();
            }, tooltip: btn.tooltip, label: btn.label, children: _jsx(Icon, { name: btn.icon }) }, btn.text));
    });
}
// Takes the features array and transforms it into a map for faster lookup
function createActiveFeaturesMap(features) {
    return features.reduce((acc, feature) => {
        return { ...acc, [feature]: true };
    }, {});
}
const Toolbar = (props) => {
    const { features, sticky, setFocusableBtn } = props;
    const editor = useSlate();
    const focused = useFocused();
    const t = useI18n();
    const [osx, setOsx] = useState(false);
    const toolbarRef = useRef(null);
    useArrows(toolbarRef, { selector: 'button', dir: 'left-right' });
    const [activeFeatures, setActiveFeatures] = useState(createActiveFeaturesMap(features));
    useEffect(() => {
        const btn = toolbarRef?.current?.querySelector('button');
        if (btn)
            setFocusableBtn(btn);
    }, [toolbarRef.current]);
    useEffect(() => {
        setActiveFeatures(createActiveFeaturesMap(features));
    }, [features]);
    useEffect(() => {
        if (navigator.appVersion.includes('Mac'))
            setOsx(true);
    }, []);
    return (_jsxs(Flex, { as: StyledToolbar, sticky: sticky, container: { justify: 'between' }, ref: toolbarRef, children: [_jsxs(Flex, { container: { alignItems: 'end' }, children: [_jsx(TextSelect, { osx: osx }), activeFeatures['inline-styling'] && renderStyleButtons(editor, t, focused, osx), activeFeatures.lists && (_jsxs(_Fragment, { children: [_jsx(ToolbarButton, { onMouseDown: e => {
                                    e.preventDefault();
                                    ListCommands.toggleList('unordered-list', editor);
                                }, active: EditorCommands.isBlockActive('unordered-list', editor), tooltip: isMobile
                                    ? `${t('rte_bulleted_list')}`
                                    : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_bulleted_list')} (${ctrl}${shift}L)`), label: t('rte_bulleted_list'), children: _jsx(Icon, { name: 'list' }) }), _jsx(ToolbarButton, { onMouseDown: e => {
                                    e.preventDefault();
                                    ListCommands.toggleList('ordered-list', editor);
                                }, active: EditorCommands.isBlockActive('ordered-list', editor), tooltip: t('rte_numbered_list'), label: t('rte_numbered_list'), children: _jsx(Icon, { name: 'list-number' }) })] })), activeFeatures.indentation && (_jsxs(_Fragment, { children: [_jsx(IndentButton, { type: 'indent', osx: osx }), _jsx(IndentButton, { type: 'unindent', osx: osx })] })), activeFeatures.tables && _jsx(TableButton, {})] }), _jsxs(Flex, { container: { alignItems: 'end' }, children: [activeFeatures.links && _jsx(AnchorButton, { osx: osx }), activeFeatures.images && _jsx(ImageButton, {})] }), activeFeatures['cut-copy-paste'] && (_jsx(Flex, { container: { alignItems: 'end' }, children: renderCutCopyPaste(editor, t, osx) }))] }));
};
export default Toolbar;
//# sourceMappingURL=Toolbar.js.map