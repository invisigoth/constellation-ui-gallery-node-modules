import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useState, useEffect } from 'react';
import { Text, Editor, Transforms } from 'slate';
import { ReactEditor, useSlate } from 'slate-react';
import { Button, CardContent, Grid, Icon, registerIcon, Input, Popover, useOuterEvent, useElement, Form, useI18n } from '@pega/cosmos-react-core';
import * as chainIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/chain.icon';
import { useRTEContext } from '../RichTextEditor.context';
import EditorCommands from '../utils/EditorCommands';
import ToolbarButton from './ToolbarButton';
import { getKeyCommand } from './utils';
registerIcon(chainIcon);
const AnchorButton = ({ osx, ...props }) => {
    const t = useI18n();
    const { setPopoverOpen, onEditorFocus } = useRTEContext();
    const buttonRef = useRef(null);
    const textInputRef = useRef(null);
    const urlInputRef = useRef(null);
    const editor = useSlate();
    const [popoverEl, setPopoverEl] = useElement();
    const [selectedText, setSelectedText] = useState('');
    const [selection, setSelection] = useState(null);
    const [url, setUrl] = useState('');
    const [urlMatch, setUrlMatch] = useState(true);
    const [anchorMenu, setAnchorMenu] = useState(false);
    const tooltip = getKeyCommand(osx, ({ ctrl }) => `${t('rte_link')} (${ctrl}K)`);
    const openMenu = (opts = {}) => {
        setAnchorMenu(true);
        setPopoverOpen(true);
        if (opts.focusInput) {
            setTimeout(() => {
                textInputRef.current?.focus();
            }, 0);
        }
    };
    const resetMenu = (opts = { focusEditor: true }) => {
        setSelection(null);
        setSelectedText('');
        setUrl('');
        setUrlMatch(true);
        setAnchorMenu(false);
        setPopoverOpen(false);
        if (opts.focusEditor) {
            setTimeout(() => {
                onEditorFocus({
                    runAfterFocus: () => {
                        if (selection)
                            Transforms.setSelection(editor, selection);
                    }
                });
            }, 0);
        }
    };
    useOuterEvent('mousedown', [popoverEl], () => {
        if (anchorMenu) {
            resetMenu();
        }
    });
    const createLink = () => {
        if (url) {
            EditorCommands.createLink(editor, selectedText, new URL(/^[a-z][a-z0-9.+-]*:/i.test(url) ? url : `http:${url}`).href, selection);
            resetMenu();
        }
    };
    useEffect(() => {
        if (editor.selection) {
            setSelectedText(Editor.string(editor, editor.selection));
            setSelection(editor.selection);
            const [match] = Editor.nodes(editor, {
                match: n => Text.isText(n) && !!n.href,
                at: editor.selection
            });
            if (match) {
                setUrl(match[0].href || '');
                setSelectedText(match[0].text);
            }
            else {
                setUrl('');
            }
        }
    }, [anchorMenu]);
    const preventDef = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };
    const isLinkActive = () => {
        const [link] = Editor.nodes(editor, { match: n => Text.isText(n) && !!n.href });
        return !!link;
    };
    const cancelAnchorCreation = (event) => {
        if ((event?.type === 'keydown' && event?.key === 'Enter') ||
            event?.type === 'mousedown' ||
            !event) {
            event?.preventDefault();
            resetMenu({ focusEditor: false });
            buttonRef.current?.focus();
        }
    };
    useEffect(() => {
        const keyCommandListener = (e) => {
            if (e.key === 'k' && (e.metaKey || e.ctrlKey) && ReactEditor.isFocused(editor)) {
                e.preventDefault();
                openMenu({ focusInput: true });
            }
            if (e.key === 'Escape') {
                cancelAnchorCreation();
            }
        };
        document.addEventListener('keydown', keyCommandListener);
        return () => {
            document.removeEventListener('keydown', keyCommandListener);
        };
    }, []);
    return (_jsxs(_Fragment, { children: [_jsx(ToolbarButton, { ref: buttonRef, onMouseDown: () => {
                    openMenu();
                }, onKeyDown: (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        openMenu({ focusInput: true });
                    }
                }, active: isLinkActive(), tooltip: tooltip, label: t('rte_link'), ...props, children: _jsx(Icon, { name: 'chain' }) }), _jsx(Popover, { show: anchorMenu, target: buttonRef.current, ref: setPopoverEl, placement: 'bottom', children: _jsx(CardContent, { children: _jsx(Form, { actions: _jsxs(_Fragment, { children: [_jsx(Button, { variant: 'secondary', onKeyDown: cancelAnchorCreation, onMouseDown: cancelAnchorCreation, type: 'button', children: "Cancel" }), _jsx(Button, { disabled: !url || !urlMatch, name: 'apply', type: 'submit', variant: 'primary', children: "Apply" })] }), onSubmit: (e) => {
                            e.preventDefault();
                            createLink();
                        }, children: _jsxs(Grid, { container: { rowGap: 2 }, children: [_jsx(Input, { label: 'Text', value: selectedText, onClick: preventDef, onChange: (e) => {
                                        setSelectedText(e.target.value);
                                    }, onBlur: () => {
                                        setTimeout(() => {
                                            if (document.activeElement !== urlInputRef.current) {
                                                resetMenu({ focusEditor: false });
                                            }
                                        }, 0);
                                    }, ref: textInputRef }), _jsx(Input, { label: 'URL', value: url, onClick: preventDef, onChange: (e) => {
                                        const urlInput = e.target.value;
                                        setUrl(urlInput);
                                        if (!urlMatch) {
                                            try {
                                                // eslint-disable-next-line no-new
                                                new URL(/^[a-z][a-z0-9+.-]*:/i.test(urlInput) ? urlInput : `http:${urlInput}`);
                                                setUrlMatch(true);
                                            }
                                            catch {
                                                setUrlMatch(false);
                                            }
                                        }
                                    }, onBlur: () => {
                                        try {
                                            // eslint-disable-next-line no-new
                                            new URL(/^[a-z][a-z0-9+.-]*:/i.test(url) ? url : `http:${url}`);
                                            setUrlMatch(true);
                                        }
                                        catch {
                                            setUrlMatch(false);
                                        }
                                    }, info: !urlMatch ? 'Not a valid URL' : '', status: !urlMatch ? 'error' : undefined, ref: urlInputRef })] }) }) }) })] }));
};
export default AnchorButton;
//# sourceMappingURL=AnchorButton.js.map