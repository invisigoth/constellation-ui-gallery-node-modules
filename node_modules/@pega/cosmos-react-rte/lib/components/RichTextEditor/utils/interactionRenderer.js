import { TLDs } from 'global-tld-list';
const parser = new DOMParser();
// Checks a string for regex matches and returns an array of matches
const checkRegex = (params) => {
    const regexMatches = [];
    let res;
    // eslint-disable-next-line no-cond-assign
    while ((res = params.regexPattern.exec(params.text))) {
        const start = res.index;
        regexMatches.push({
            start,
            end: start + res[0].length,
            match: res,
            ...params
        });
    }
    return regexMatches;
};
// Extracts all properties from an xml element represented as a string
export const getXMLAttributes = (element) => {
    const document = parser.parseFromString(element, 'application/xml');
    if (document.querySelector('parsererror'))
        return undefined;
    const attributes = {};
    for (let i = 0; i < document.documentElement.attributes.length; i += 1) {
        const attr = document.documentElement.attributes.item(i);
        if (attr) {
            attributes[attr.name] = attr.value;
        }
    }
    attributes.rawText = element;
    return attributes;
};
// Parses text node to custom slate node
const parseTextToCustomSlateNodes = (text, renderers) => {
    // Runs through an array of custom renderers and gets the matches
    const positions = renderers?.flatMap(renderer => checkRegex({ text, ...renderer })) || [];
    // Early exit when no matched positions
    if (positions.length === 0) {
        return [{ text }];
    }
    // Sorts the matches based on the start positions of the matches
    positions.sort((a, b) => a.start - b.start);
    const nodes = [];
    // Use the regex match positions to slice the text into the correct text nodes and other custom nodes
    let lastPos;
    positions.forEach((pos, i) => {
        // If the first regex match isn't at the start of the text node,
        // slice the text node up to the first match and insert it into the nodes array
        if (i === 0 && pos.start !== 0) {
            nodes.push({
                text: text.slice(i, pos.start)
            });
        }
        // If there was a last position, slice the text between the last position
        // and the new position to insert it as a new text node
        if (lastPos && lastPos.end < pos.start) {
            nodes.push({
                text: text.slice(lastPos.end, pos.start)
            });
        }
        else if (i !== 0) {
            nodes.push({
                text: ' '
            });
        }
        if (pos.type === 'builtin-url' && pos.match.groups) {
            const { leadingChar, url } = pos.match.groups;
            try {
                // Check for valid URL since the regex isn't exhaustive.
                const { href } = new URL(pos.match.groups.protocol ? url : `https://${url}`);
                if (!TLDs.includes(pos.match.groups.tld)) {
                    throw new Error('Invalid URL. Skipping formatting.');
                }
                if (leadingChar) {
                    nodes.push({ text: leadingChar });
                }
                nodes.push({
                    text: url,
                    href
                });
            }
            catch {
                // Invalid URL, just render as text.
                nodes.push({ text: pos.match[0] });
            }
        }
        else if (pos.xmlElement) {
            const xmlAttributes = getXMLAttributes(pos.match[0]);
            if (!xmlAttributes) {
                // Invalid XML, just render as text.
                nodes.push({ text: pos.match[0] });
            }
            else if (pos.component) {
                nodes.push({
                    type: 'custom',
                    component: pos.component,
                    content: xmlAttributes,
                    children: [{ text: '' }]
                });
            }
            else if (pos.getSearchAttributes) {
                const searchResult = pos.getSearchAttributes(pos.xmlElement, pos.match[0]);
                if (searchResult && searchResult.text) {
                    nodes.push({
                        text: searchResult.text,
                        searchResult: {
                            markdown: searchResult.markdown,
                            component: searchResult.component,
                            props: searchResult.props,
                            toJSON: () => undefined
                        }
                    });
                }
                else {
                    nodes.push({ text: pos.match[0] });
                }
            }
        }
        // If we are at the end of the positions array, and there's still text left
        // slice the text and add it as a new text node
        if (i === positions.length - 1 && pos.end < text.length) {
            nodes.push({
                text: text.slice(pos.end, text.length)
            });
        }
        lastPos = pos;
    });
    return nodes.length > 0 ? nodes : [{ text: '' }];
};
export default parseTextToCustomSlateNodes;
//# sourceMappingURL=interactionRenderer.js.map