import { Editor, Element, Path, Transforms, Text } from 'slate';
import { createUID } from '@pega/cosmos-react-core';
import { LIST_TYPES, TEXT_TYPES } from './utils.types';
const matchList = (n) => Element.isElement(n) && LIST_TYPES.includes(n.type);
const matchListItem = (n) => Element.isElement(n) && n.type === 'list-item';
const getNextPathBelow = (path) => {
    path[path.length - 1] = path[path.length - 1] + 1;
    return path;
};
const commands = {
    toggleList: (type, editor) => {
        const [listItemInSelection] = Editor.nodes(editor, {
            at: editor.selection?.anchor.path || undefined,
            match: matchListItem
        });
        if (!listItemInSelection) {
            Transforms.wrapNodes(editor, { type, children: [] });
            Transforms.wrapNodes(editor, {
                type: 'list-item',
                order: 1,
                level: 1,
                id: createUID(),
                children: []
            });
        }
        else {
            Transforms.setNodes(editor, { type }, { match: matchList });
        }
    },
    checkListEnter: (editor, event) => {
        // Gets the list item node at your selection in the lowest part of the tree.
        // Your selection could technically be in multiple list items in the tree because
        // the lists can be nested. That is what the mode: 'lowest' arg is for.
        const [listItemNodeEntry] = Editor.nodes(editor, {
            at: editor.selection?.anchor.path || undefined,
            match: matchListItem,
            mode: 'lowest'
        });
        if (['Backspace', 'Enter'].includes(event.key) && listItemNodeEntry) {
            const [listItemNode, listItemPath] = listItemNodeEntry;
            // Getting the text node
            const [[textNode]] = Editor.nodes(editor, {
                at: editor.selection?.anchor.path || undefined,
                match: Text.isText
            });
            // Getting the parent list-item node
            const [[parentNode]] = Editor.nodes(editor, {
                at: editor.selection || undefined,
                match: matchListItem,
                mode: 'highest'
            });
            let belowListItemPath;
            try {
                belowListItemPath = Path.next(listItemPath);
            }
            catch {
                belowListItemPath = undefined;
            }
            if (textNode.text !== '') {
                // If the text node the selection is in is not empty, and the key that was pressed is Enter
                if (event.key === 'Enter') {
                    event.preventDefault();
                    const newId = createUID();
                    const copiedChildren = [];
                    // If this list-item has another list nested inside of it
                    if (listItemNode.children.length === 2) {
                        // Copy the list nested inside
                        const copiedList = { ...listItemNode.children[1] };
                        // Add a new parentId to all the children in the list
                        copiedList.children = copiedList.children.map(node => {
                            return { ...node, parentId: newId };
                        });
                        copiedChildren.push(copiedList);
                        // Remove the list
                        Transforms.removeNodes(editor, { at: [...listItemPath, 1] });
                    }
                    // Create a new list item with the copied children as it's children,
                    // and insert it into the editor
                    Transforms.insertNodes(editor, {
                        type: 'list-item',
                        order: listItemNode.order ? listItemNode.order + 1 : 0,
                        level: listItemNode.level ? listItemNode.level : 1,
                        id: newId,
                        parentId: parentNode.id,
                        children: [{ type: 'paragraph', children: [{ text: '' }] }, ...copiedChildren]
                    });
                    // Nodes needs to be lifted one level higher because it will be inserted
                    // into the list item itself rather than it's parent list
                    Transforms.liftNodes(editor, {
                        match: n => matchListItem(n) && n.id === newId
                    });
                    const selectionPoint = { path: [...Path.next(listItemPath), 0, 0], offset: 0 };
                    // Set the selection to the new list item created
                    Transforms.setSelection(editor, { focus: selectionPoint, anchor: selectionPoint });
                }
                else if (editor.selection?.anchor.offset === 0) {
                    commands.unNestList(editor);
                }
            }
            else if (parentNode && parentNode.children.length > 1) {
                // Un nest this list item from it's parent
                event.preventDefault();
                commands.unNestList(editor);
            }
            else if (belowListItemPath) {
                // Break out of the list
                event.preventDefault();
                Transforms.unwrapNodes(editor, {
                    at: editor.selection?.anchor.path || undefined,
                    match: matchListItem
                });
                Transforms.liftNodes(editor);
            }
        }
    },
    nestList: (editor) => {
        const [listItemNodeEntry] = Editor.nodes(editor, {
            at: editor.selection?.anchor.path || undefined,
            match: matchListItem,
            mode: 'lowest'
        });
        let listType = 'unordered-list';
        const [highestList] = Editor.nodes(editor, {
            at: editor.selection?.anchor.path || undefined,
            match: matchList,
            mode: 'highest'
        });
        if (highestList) {
            listType = highestList[0].type;
        }
        const [listItemNode, listItemPath] = listItemNodeEntry || [
            undefined,
            undefined
        ];
        // Try to find the path to the node above the selected list item
        let abovePath;
        try {
            abovePath = Path.previous(listItemPath);
        }
        catch {
            abovePath = undefined;
        }
        // Only nest the list if there is a list item above the list item trying to be nested
        if (listItemNode && abovePath && listItemNode.level < 3) {
            // Get the list item and it's path from above the current list item
            const [[aboveListItemNode, aboveListItemPath]] = Editor.nodes(editor, {
                at: abovePath,
                match: n => matchListItem(n) && n.level === listItemNode.level
            });
            // Gets the path for the text node above list-item
            const [[, innerTextNodePath]] = Editor.nodes(editor, {
                at: abovePath,
                match: n => Element.isElement(n) && TEXT_TYPES.includes(n.type)
            });
            let copiedSubListNodes = [];
            const newListItemChildren = [listItemNode.children[0]];
            if (listItemNode.children.length && listItemNode.children.length > 1) {
                // Copy the item to be nested's sub list if it has one
                const subList = listItemNode.children[1];
                if (subList) {
                    copiedSubListNodes = [...subList.children];
                }
            }
            // If the above list item has a sub list
            if (aboveListItemNode.children.length > 1) {
                // Get the list items in the sub list of the above list item
                const { children } = aboveListItemNode.children[1];
                // Gets the last list item in the above sub list
                const [[parentSubListItem, parentSubListItemPath]] = Editor.nodes(editor, {
                    at: aboveListItemPath,
                    match: n => matchListItem(n) &&
                        n.order === children.length &&
                        n.level - 1 === listItemNode.level
                });
                // Gets the path after the last list item in the above sub list
                const nextParentSubListItemPath = Path.next(parentSubListItemPath);
                // Inserts a copy of the list-item you are nesting below the lowest list item
                // in the above sub list, as well as copies of any children the list-item you are
                // nesting had.
                let subOrderCount = parentSubListItem.order + 1;
                Transforms.insertNodes(editor, [
                    {
                        ...listItemNode,
                        level: listItemNode.level + 1,
                        order: parentSubListItem.order + 1,
                        parentId: aboveListItemNode.id,
                        children: newListItemChildren
                    },
                    ...copiedSubListNodes.map(n => {
                        subOrderCount += 1;
                        return {
                            ...n,
                            level: listItemNode.level + 1,
                            order: subOrderCount,
                            parentId: aboveListItemNode.id
                        };
                    })
                ], { at: nextParentSubListItemPath });
            }
            else {
                const nextInnerTextNodePath = getNextPathBelow(innerTextNodePath);
                // Nest the selected list item into a new list and then into the above list item
                let subOrderCount = 1;
                Transforms.insertNodes(editor, {
                    type: listType,
                    children: [
                        {
                            ...listItemNode,
                            order: 1,
                            level: listItemNode.level + 1,
                            parentId: aboveListItemNode.id,
                            children: newListItemChildren
                        },
                        ...copiedSubListNodes.map(n => {
                            subOrderCount += 1;
                            return {
                                ...n,
                                level: listItemNode.level + 1,
                                order: subOrderCount,
                                parentId: aboveListItemNode.id
                            };
                        })
                    ]
                }, { at: nextInnerTextNodePath, mode: 'lowest' });
            }
            // Remove the old list item as we just copied it into the correct place
            Transforms.removeNodes(editor, { at: listItemPath });
        }
    },
    unNestList: (editor) => {
        // Get the current node to be un nested
        const [[node, nodePath]] = Editor.nodes(editor, {
            at: editor.selection?.anchor.path || undefined,
            match: matchListItem,
            mode: 'lowest'
        });
        const [singleItemList] = Editor.nodes(editor, {
            match: n => matchList(n) && n.children.length === 1,
            mode: 'highest'
        });
        if (singleItemList) {
            Transforms.unwrapNodes(editor, { match: matchListItem });
            Transforms.unwrapNodes(editor, { match: matchList });
            return;
        }
        // Attempt to get the highest parent in the nested list if it exists
        const [highestParent] = Editor.nodes(editor, {
            at: editor.selection || undefined,
            match: n => matchListItem(n) && node.level - n.level === 2,
            mode: 'lowest'
        });
        // Get the parent list node if it exists (list item)
        const [[parentNode]] = Editor.nodes(editor, {
            at: editor.selection || undefined,
            match: n => matchListItem(n) && node.level - n.level === 1,
            mode: 'lowest'
        });
        // Get the parent list
        const [[parentList]] = Editor.nodes(editor, {
            at: editor.selection || undefined,
            match: matchList,
            mode: 'lowest'
        });
        if (parentNode && parentNode.children.length > 1) {
            let newParentId;
            if (highestParent) {
                const [highestParentNode] = highestParent;
                newParentId = highestParentNode.id;
            }
            // Setting the node to un nests new order and level
            Transforms.setNodes(editor, {
                level: node.level - 1,
                order: parentNode.order + 1
            }, { at: nodePath, match: n => matchListItem(n) && n.id === node.id });
            // Set the level of any children under the node we are un nesting
            Transforms.setNodes(editor, { level: node.level }, {
                at: nodePath,
                match: n => matchListItem(n) && n.level > node.level
            });
            // If there's a new parent id set it, otherwise unset the parent id entirely
            if (newParentId) {
                Transforms.setNodes(editor, { parentId: newParentId }, { at: nodePath, match: n => matchListItem(n) && n.id === node.id });
            }
            else {
                Transforms.unsetNodes(editor, 'parentId', {
                    at: nodePath,
                    match: n => matchListItem(n) && n.id === node.id
                });
            }
            const listItemsExistBelow = node.order < parentList.children.length;
            if (listItemsExistBelow) {
                // Getting the inner text node inside of the list item in order to get the next path
                const [[, innerTextNodePath]] = Editor.nodes(editor, {
                    at: nodePath,
                    match: matchList
                });
                const nextPath = Path.next(innerTextNodePath);
                const copiedChildren = [];
                let count = 1;
                // Copy the children from the parent list that are below the list item we are un nesting
                for (let i = node.order; i < parentList.children.length; i += 1) {
                    copiedChildren.push({
                        ...parentList.children[i],
                        parentId: node.id,
                        order: count
                    });
                    count += 1;
                }
                // Insert a new list with the copied children into the un nested list item
                Transforms.insertNodes(editor, {
                    type: parentList.type,
                    children: [...copiedChildren]
                }, { at: nextPath });
                const [[newParentList, newParentListPath]] = Editor.nodes(editor, {
                    at: editor.selection?.anchor.path || undefined,
                    match: matchList,
                    mode: 'lowest'
                });
                let order = 0;
                // Set the nodes below the list item being un nested
                Transforms.setNodes(editor, {
                    parentId: node.id,
                    order
                }, {
                    match: n => {
                        if (!matchListItem(n))
                            return false;
                        if (n.parentId === node.id)
                            order += 1;
                        return n.parentId === node.id;
                    }
                });
                // Removing all old nodes from that were under the un nested item
                for (let i = newParentList.children.length - 1; i >= node.order; i -= 1) {
                    const childPath = [...newParentListPath, i];
                    Transforms.removeNodes(editor, { at: childPath, match: matchListItem });
                }
            }
            // Lift the current node at the users selection out of it's parent node twice
            Transforms.liftNodes(editor, { match: matchListItem });
            Transforms.liftNodes(editor, { match: matchListItem });
        }
    }
};
export default commands;
//# sourceMappingURL=ListCommands.js.map