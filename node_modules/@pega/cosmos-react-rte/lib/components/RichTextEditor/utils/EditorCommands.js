import { Editor, Transforms, Range, Path, Element, Text } from 'slate';
import ListCommands from './ListCommands';
const textKeyCodeMapping = {
    48: 'paragraph',
    49: 'heading-1',
    50: 'heading-2',
    51: 'heading-3',
    52: 'heading-4'
};
const commands = {
    // Checks if an inline format is active
    isFormatActive: (format, editor) => {
        const marks = Editor.marks(editor);
        return marks ? marks[format] === true : false;
    },
    // Toggles an inline format on or off
    toggleFormat: (format, editor) => {
        const formatActive = commands.isFormatActive(format, editor);
        if (formatActive) {
            Editor.removeMark(editor, format);
        }
        else {
            Editor.addMark(editor, format, true);
        }
    },
    // Checks if a block level format is active
    isBlockActive: (format, editor) => {
        const [match] = Editor.nodes(editor, {
            match: n => Element.isElement(n) && n.type === format
        });
        return !!match;
    },
    // Gets the active block level type
    getActiveBlockType: (editor) => {
        const [match] = Editor.nodes(editor, {
            at: editor.selection || undefined,
            match: Element.isElement,
            mode: 'lowest'
        });
        if (match) {
            return match[0].type;
        }
        return '';
    },
    // Sets the block type of the currently selected block
    setBlock: (format, editor) => {
        Transforms.setNodes(editor, { type: format }, { mode: 'lowest' });
    },
    // Replaces a target in the editor with the given text
    replaceWithText: (editor, target, text) => {
        if (target) {
            Transforms.select(editor, target);
        }
        Transforms.insertText(editor, text);
        Transforms.move(editor);
    },
    // Replaces a target in the editor with the given node
    replaceWithNodes: (editor, target, node) => {
        if (target) {
            Transforms.select(editor, target);
        }
        Transforms.insertNodes(editor, node);
    },
    // Gets the highest selected block level node
    getSelectedNode: (editor) => {
        const [node] = Editor.nodes(editor, {
            at: editor.selection || undefined,
            match: n => Element.isElement(n),
            mode: 'highest'
        });
        return node;
    },
    // Appends a 3x3 table into the editor and adds a blank line to the bottom
    appendTable: (editor) => {
        const baseArr = new Array(3).fill(new Array(3).fill(0));
        const table = [
            {
                type: 'table',
                children: [
                    {
                        type: 'table-body',
                        children: baseArr.map(row => {
                            return {
                                type: 'table-row',
                                children: row.map(() => {
                                    return {
                                        type: 'table-cell',
                                        children: [{ type: 'paragraph', children: [{ text: '' }] }]
                                    };
                                })
                            };
                        })
                    }
                ]
            },
            {
                type: 'paragraph',
                children: [{ text: '' }]
            }
        ];
        Transforms.insertNodes(editor, table, { mode: 'highest' });
        const [firstTableCell] = Editor.nodes(editor, {
            at: editor.selection?.anchor.path.slice(0, 1),
            match: n => Element.isElement(n) && n.type === 'paragraph',
            mode: 'highest'
        });
        if (firstTableCell) {
            const [, path] = firstTableCell;
            path.push(0);
            const nextPosition = { path, offset: 0 };
            Transforms.setSelection(editor, { anchor: nextPosition, focus: nextPosition });
        }
    },
    // Finds the image placeholder and replaces it with an image node
    appendImage: (editor, imageData, id) => {
        const [node] = Editor.nodes(editor, {
            match: n => Element.isElement(n) && n.type === 'image-placeholder',
            at: [Number(id)]
        });
        if (node) {
            const [, path] = node;
            Transforms.setNodes(editor, { type: 'image', src: imageData.src, alt: imageData.alt }, { at: path });
            Transforms.unsetNodes(editor, 'id', { at: path });
            return Editor.end(editor, path);
        }
        return null;
    },
    appendImagePlaceholder: (editor) => {
        const node = commands.getSelectedNode(editor);
        if (node) {
            const [, path] = node;
            const next = Path.next(path);
            Transforms.insertNodes(editor, { type: 'image-placeholder', children: [{ text: '' }] }, { at: next });
            return next[0].toString();
        }
        return '';
    },
    // Creates a link at the given selection
    createLink: (editor, text, url, selection) => {
        const linkNode = { text: text || url, href: url };
        if (selection) {
            if (Range.isCollapsed(selection)) {
                const [node] = Editor.node(editor, selection);
                if (Text.isText(node) && node.href) {
                    const before = Editor.before(editor, selection, { unit: 'word' });
                    const after = Editor.after(editor, selection, { unit: 'word' });
                    if (before && after) {
                        Transforms.insertNodes(editor, [linkNode], { at: { anchor: before, focus: after } });
                    }
                    else if (before) {
                        const calculatedAfter = Editor.after(editor, before, { unit: 'word' });
                        if (calculatedAfter) {
                            Transforms.insertNodes(editor, [linkNode], {
                                at: { anchor: before, focus: calculatedAfter }
                            });
                        }
                    }
                    else if (after) {
                        const calculatedBefore = Editor.before(editor, after, { unit: 'word' });
                        if (calculatedBefore) {
                            Transforms.insertNodes(editor, [linkNode], {
                                at: { anchor: calculatedBefore, focus: after }
                            });
                        }
                    }
                }
                else {
                    Transforms.insertNodes(editor, [linkNode]);
                }
            }
            else {
                Transforms.insertNodes(editor, [linkNode], {
                    at: selection
                });
            }
        }
        else {
            Transforms.insertNodes(editor, [linkNode]);
        }
    },
    // Used to handle the enter key when the cursor is next to an image, inserts a new paragraph
    checkImageEnter: (editor, e) => {
        const [image] = Editor.nodes(editor, {
            match: n => Element.isElement(n) && n.type === 'image'
        });
        if (image) {
            if (e.keyCode < 37 && e.keyCode > 40) {
                e.preventDefault();
            }
            if (e.key === 'Enter') {
                e.preventDefault();
                const [, path] = image;
                const next = Path.next(path);
                Transforms.insertNodes(editor, { type: 'paragraph', children: [{ text: '' }] }, { at: next });
                Transforms.select(editor, next);
            }
        }
    },
    // Turns the href and/or searchResult property off on the text node when space is pressed while on a link or mention
    checkLinkBreak: (editor, e) => {
        const [link] = Editor.nodes(editor, {
            match: n => Text.isText(n) && !!n.href
        });
        const [searchResult] = Editor.nodes(editor, {
            match: n => Text.isText(n) && !!n.searchResult
        });
        if ((link || searchResult) && (e.key === ' ' || e.key === 'Enter')) {
            e.preventDefault();
            Editor.insertNode(editor, { text: e.key === 'Enter' ? '\n' : ' ' });
            Editor.removeMark(editor, link ? 'href' : 'searchResult');
        }
    },
    /**
     * Turns the searchResult property off on the text node when any key is pressed while on a searchResult.
     * Will delete the searchResult node if backspace key is hit.
     * Will re-position cursor to the start/end of the searchResult if arrow navigation is used.
     */
    checkSearchDownKeys: (editor, e) => {
        const [text] = Editor.nodes(editor, {
            match: n => Text.isText(n)
        });
        if (text) {
            const [node, path] = text;
            const nextNode = Editor.next(editor)?.[0];
            const nextPath = Editor.next(editor)?.[1];
            const previousNode = Editor.previous(editor)?.[0];
            const previousPath = Editor.previous(editor)?.[1];
            const next = nextNode && nextNode.searchResult;
            const nextInline = next && path[0] === nextPath?.[0];
            const previous = previousNode && previousNode.searchResult;
            const previousInline = previous && path[0] === previousPath?.[0];
            // Checks if the current selection is a single cursor point rather than spanning multiple characters
            const singlePointSelection = editor.selection?.anchor.offset === editor.selection?.focus.offset &&
                editor.selection?.anchor.path[0] === editor.selection?.focus.path[0] &&
                editor.selection?.anchor.path[1] === editor.selection?.focus.path[1];
            // Checks if the current selected node is a search result, or directly adjacent inline with a search result
            if (node.searchResult || (next && nextInline) || (previous && previousInline)) {
                const atStart = node.searchResult && editor.selection?.anchor.offset === 0;
                const atEnd = node.searchResult && editor.selection?.anchor.offset === node.text.length;
                // Deletes the entire search result only if the cursor is at the end of the search result
                if (e.key === 'Backspace' && (atEnd || (previous && previousInline))) {
                    if (singlePointSelection)
                        e.preventDefault();
                    Transforms.delete(editor, { at: previous ? previousPath : path });
                    // Deletes the entire search result only if the cursor is at the start of the search result
                }
                else if (e.key === 'Delete' && (atStart || (next && nextInline))) {
                    if (singlePointSelection)
                        e.preventDefault();
                    Transforms.delete(editor, { at: next ? nextPath : path });
                    // Moves cursor to start of search result only if the cursor is at the end of the search result
                }
                else if (e.key === 'ArrowLeft' && (atEnd || (previous && previousInline))) {
                    if (singlePointSelection)
                        e.preventDefault();
                    Transforms.move(editor, {
                        distance: previous ? previousNode.text.length : node.text.length,
                        unit: 'character',
                        reverse: true
                    });
                    // Moves cursor to end of search result only if the cursor is at the start of the search result
                }
                else if (e.key === 'ArrowRight' && (atStart || (next && nextInline))) {
                    if (singlePointSelection)
                        e.preventDefault();
                    Transforms.move(editor, {
                        distance: next ? nextNode.text.length : node.text.length,
                        unit: 'character'
                    });
                    // Ensures all other character (besides special key bindings) are inserted as plain text
                }
                else if (e.key.length === 1 && !e.altKey && !e.ctrlKey && !e.metaKey) {
                    e.preventDefault();
                    Editor.insertNode(editor, { text: e.key === 'Enter' ? '\n' : e.key });
                }
                // Prevents partial search result selections from disabling the searchResult flag
                if (singlePointSelection) {
                    Editor.removeMark(editor, 'searchResult');
                }
            }
        }
    },
    // Checks arrow navigation key up events around search results
    checkSearchUpKeys: (editor, e) => {
        const [text] = Editor.nodes(editor, {
            match: n => Text.isText(n)
        });
        if (text) {
            const [node, path] = text;
            const cursorInSearchResult = node.searchResult &&
                editor.selection?.anchor.path[0] === path[0] &&
                editor.selection?.anchor.path[1] === path[1];
            if (cursorInSearchResult && editor.selection) {
                const distanceToStart = editor.selection.anchor.offset;
                const distanceToEnd = node.text.length - editor.selection.anchor.offset;
                // Moves cursor to the start of the search result
                if (e.key === 'ArrowLeft') {
                    e.preventDefault();
                    Transforms.move(editor, {
                        distance: distanceToStart,
                        unit: 'character',
                        reverse: true
                    });
                    // Moves cursor to end of search result
                }
                else if (e.key === 'ArrowRight') {
                    e.preventDefault();
                    Transforms.move(editor, {
                        distance: distanceToEnd,
                        unit: 'character'
                    });
                    // Moves cursor to start or end of search result, whichever is closer
                }
                else if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    Transforms.move(editor, {
                        distance: distanceToStart <= distanceToEnd ? distanceToStart : distanceToEnd,
                        unit: 'character',
                        reverse: distanceToStart <= distanceToEnd
                    });
                }
            }
        }
    },
    // Either adds a tab character or indents a list depending on the selection
    indent: (editor) => {
        const [nodeInListItem] = Editor.nodes(editor, {
            match: n => Element.isElement(n) && n.type === 'list-item'
        });
        if (nodeInListItem) {
            ListCommands.nestList(editor);
            return;
        }
        if (editor.selection) {
            let start = Editor.before(editor, editor.selection, { unit: 'block' });
            start = start || Editor.start(editor, editor.selection);
            Transforms.insertText(editor, '\t', { at: start });
        }
    },
    // Either removes a tab character or un indents a list depending on the selection
    unindent: (editor) => {
        const [nodeInListItem] = Editor.nodes(editor, {
            match: n => Element.isElement(n) && n.type === 'list-item'
        });
        if (nodeInListItem) {
            ListCommands.unNestList(editor);
            return;
        }
        if (editor.selection) {
            let start = Editor.before(editor, editor.selection, { unit: 'block' });
            start = start || Editor.start(editor, editor.selection);
            let end = Editor.after(editor, editor.selection, { unit: 'block' });
            end = end || Editor.end(editor, editor.selection);
            if (start && end) {
                const text = Editor.string(editor, { anchor: start, focus: end });
                const newText = text.replace(/\t/, '');
                Transforms.insertText(editor, newText, { at: { anchor: start, focus: end } });
            }
        }
    },
    checkKeyCommands: (editor, e, markdownOnly) => {
        const cmdOrCtrl = e.metaKey || e.ctrlKey;
        let commandExecuted = false;
        if (cmdOrCtrl && !markdownOnly) {
            // Command or Ctrl + Shift
            if (e.shiftKey) {
                switch (e.key) {
                    case 'b':
                        commands.toggleFormat('bold', editor);
                        commandExecuted = true;
                        break;
                    case 'i':
                        commands.toggleFormat('italic', editor);
                        commandExecuted = true;
                        break;
                    case 'x':
                        commands.toggleFormat('line-through', editor);
                        commandExecuted = true;
                        break;
                    case 'l':
                        ListCommands.toggleList('unordered-list', editor);
                        commandExecuted = true;
                        break;
                    default:
                }
                // Command or Ctrl but not alt
            }
            else if (!e.shiftKey && !e.altKey) {
                switch (e.key) {
                    case 'b':
                        commands.toggleFormat('bold', editor);
                        commandExecuted = true;
                        break;
                    case 'i':
                        commands.toggleFormat('italic', editor);
                        commandExecuted = true;
                        break;
                    default:
                }
            }
        }
        else if (cmdOrCtrl && markdownOnly && !e.shiftKey && !e.altKey && e.key === 'x') {
            const [searchResult] = Editor.nodes(editor, {
                match: n => Text.isText(n) && !!n.searchResult
            });
            if (searchResult) {
                Editor.removeMark(editor, 'searchResult');
            }
        }
        if (e.altKey && !markdownOnly) {
            if (cmdOrCtrl) {
                if (textKeyCodeMapping[e.keyCode]) {
                    commands.setBlock(textKeyCodeMapping[e.keyCode], editor);
                    commandExecuted = true;
                }
            }
            else if (e.keyCode === 77) {
                if (e.shiftKey) {
                    commands.unindent(editor);
                    commandExecuted = true;
                }
                else {
                    commands.indent(editor);
                    commandExecuted = true;
                }
            }
        }
        if (markdownOnly && e.key === 'Backspace') {
            const [searchResult] = Editor.nodes(editor, {
                match: n => Text.isText(n) && !!n.searchResult
            });
            if (searchResult) {
                Editor.removeMark(editor, 'searchResult');
            }
            if (!editor.selection) {
                Transforms.select(editor, {
                    anchor: { offset: 0, path: [0, 0] },
                    focus: { offset: 0, path: [0, 0] }
                });
            }
        }
        if (commandExecuted)
            e.preventDefault();
    }
};
export default commands;
//# sourceMappingURL=EditorCommands.js.map