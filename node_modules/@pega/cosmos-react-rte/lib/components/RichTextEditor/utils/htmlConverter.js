import { parse } from 'parse5';
import parseTextToCustomSlateNodes from './interactionRenderer';
const checkElement = (node) => !!node && node.nodeName !== '#text' && node.nodeName !== '#comment';
const checkTextNode = (node) => !!node && node.nodeName === '#text';
const checkComment = (node) => !!node && node.nodeName === '#comment';
// Mapping of HTML tags to slate types. b, del, i, and a tags are labeled as skip because they need special logic
export const htmlToSlateMap = {
    h1: 'heading-1',
    h2: 'heading-2',
    h3: 'heading-3',
    h4: 'heading-4',
    ul: 'unordered-list',
    ol: 'ordered-list',
    li: 'list-item',
    table: 'table',
    tr: 'table-row',
    td: 'table-cell',
    tbody: 'table-body',
    p: 'paragraph',
    img: 'image',
    b: 'skip',
    del: 'skip',
    i: 'skip',
    a: 'skip'
};
// Inline HTML tags to slate types
export const inlineHtmlToStyleMap = {
    b: 'bold',
    del: 'line-through',
    i: 'italic',
    a: 'href'
};
const getAttributes = (node) => {
    if (checkElement(node) && node.attrs.length) {
        switch (node.nodeName) {
            case 'li':
                return Object.fromEntries(node.attrs.flatMap(attr => {
                    // eslint-disable-next-line sonarjs/no-nested-switch
                    switch (attr.name) {
                        case 'data-id':
                            return [['id', attr.value]];
                        case 'data-parent-id':
                            return [['parentId', attr.value]];
                        case 'data-level':
                            return [['level', attr.value]];
                        case 'data-order':
                            return [['order', attr.value]];
                        default:
                            return [];
                    }
                }));
            case 'img': {
                const imgAttrs = ['src', 'alt'];
                const attrsObj = {};
                for (let i = 0; i < node.attrs.length; i += 1) {
                    const { name, value } = node.attrs[i];
                    if (imgAttrs.includes(name)) {
                        attrsObj[name] = value;
                    }
                }
                return attrsObj;
            }
            default:
                return {};
        }
    }
    return {};
};
const getSlateNode = (node, parentNode, interactionRenderers) => {
    if (checkTextNode(node)) {
        if (node.parentNode.nodeName === 'body') {
            return {
                node: {
                    type: 'paragraph',
                    children: [{ text: node.value }]
                }
            };
        }
        // Make sure to spread any parent style attributes for slates text nodes
        const children = parseTextToCustomSlateNodes(node.value, interactionRenderers);
        if (children.length === 1) {
            const tempParentNode = parentNode;
            if (children[0]?.type === 'custom') {
                delete tempParentNode?.text;
            }
            return { node: { ...tempParentNode, ...children[0] } };
        }
        return {
            node: {
                ...parentNode,
                children
            }
        };
    }
    const type = htmlToSlateMap[node.nodeName];
    // If the type of the HTML tag is an inline (b, i, del, a) we want to let the recursive function know
    // that it needs to collapse the next node, also we are setting the correct style mark to true
    if (type === 'skip') {
        const style = inlineHtmlToStyleMap[node.nodeName];
        let value = true;
        if (node.nodeName === 'a') {
            const hrefObj = node.attrs?.find(attr => attr.name === 'href');
            value = hrefObj ? hrefObj.value : value;
        }
        return {
            node: { ...parentNode, [style]: value, text: '' },
            collapseNext: true
        };
    }
    const attributes = getAttributes(node);
    const nodeObj = {
        type: type || 'paragraph',
        ...attributes,
        children: [{ text: '' }]
    };
    return { node: nodeObj };
};
// Recursive function that will convert Parse5Nodes into Slate compatible nodes
const convertNodes = (nodes, parentNode, interactionRenderers) => {
    const returnNodes = [];
    nodes.forEach(node => {
        const { node: slateNode, collapseNext } = getSlateNode(node, parentNode, interactionRenderers);
        if (!checkComment(node)) {
            let returnNode = slateNode;
            if (checkElement(node) && node.childNodes && node.childNodes.length) {
                if (collapseNext) {
                    returnNode = convertNodes(node.childNodes, slateNode, interactionRenderers)[0];
                }
                else {
                    slateNode.children = convertNodes(node.childNodes, undefined, interactionRenderers);
                    returnNode = slateNode;
                }
            }
            returnNodes.push(returnNode);
        }
    });
    return returnNodes;
};
const defaultValue = [{ type: 'paragraph', children: [{ text: '' }] }];
export const convertHtml = (html, interactionRenderers) => {
    // Wrap the html in another body in case the value given has no body
    const doc = parse(`<body>${html.replace('\n', '')}</body>`);
    let nodesToConvert = doc.childNodes;
    // If we have a root tag
    if (doc.childNodes.length === 1) {
        const root = doc.childNodes[0];
        if (!checkElement(root))
            return defaultValue;
        const body = root.childNodes[1];
        if (!checkElement(body))
            return defaultValue;
        nodesToConvert = body.childNodes;
    }
    return convertNodes(nodesToConvert, undefined, interactionRenderers);
};
//# sourceMappingURL=htmlConverter.js.map