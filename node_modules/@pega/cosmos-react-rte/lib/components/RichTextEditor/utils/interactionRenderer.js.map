{"version":3,"file":"interactionRenderer.js","sourceRoot":"","sources":["../../../../src/components/RichTextEditor/utils/interactionRenderer.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as slate from 'slate';\nimport { TLDs } from 'global-tld-list';\n\nimport { InteractionRenderers } from '../RichTextViewer.types';\n\ninterface RegexMatch extends InteractionRenderers {\n  start: number;\n  end: number;\n  match: RegExpExecArray;\n}\n\ninterface CheckRegexParams extends InteractionRenderers {\n  text: string;\n}\n\nconst parser = new DOMParser();\n\n// Checks a string for regex matches and returns an array of matches\nconst checkRegex = (params: CheckRegexParams) => {\n  const regexMatches: RegexMatch[] = [];\n  let res;\n  // eslint-disable-next-line no-cond-assign\n  while ((res = params.regexPattern.exec(params.text))) {\n    const start = res.index;\n    regexMatches.push({\n      start,\n      end: start + res[0].length,\n      match: res,\n      ...params\n    });\n  }\n  return regexMatches;\n};\n\n// Extracts all properties from an xml element represented as a string\nexport const getXMLAttributes = (element: string): Record<string, string> | undefined => {\n  const document = parser.parseFromString(element, 'application/xml');\n  if (document.querySelector('parsererror')) return undefined;\n  const attributes: Record<string, string> = {};\n\n  for (let i = 0; i < document.documentElement.attributes.length; i += 1) {\n    const attr = document.documentElement.attributes.item(i);\n    if (attr) {\n      attributes[attr.name] = attr.value;\n    }\n  }\n  attributes.rawText = element;\n\n  return attributes;\n};\n\n// Parses text node to custom slate node\nconst parseTextToCustomSlateNodes = (\n  text: string,\n  renderers?: InteractionRenderers[]\n): (slate.Element | slate.Text)[] => {\n  // Runs through an array of custom renderers and gets the matches\n  const positions: RegexMatch[] =\n    renderers?.flatMap(renderer => checkRegex({ text, ...renderer })) || [];\n\n  // Early exit when no matched positions\n  if (positions.length === 0) {\n    return [{ text }];\n  }\n\n  // Sorts the matches based on the start positions of the matches\n  positions.sort((a, b) => a.start - b.start);\n\n  const nodes: (slate.Element | slate.Text)[] = [];\n\n  // Use the regex match positions to slice the text into the correct text nodes and other custom nodes\n  let lastPos: RegexMatch;\n  positions.forEach((pos, i) => {\n    // If the first regex match isn't at the start of the text node,\n    // slice the text node up to the first match and insert it into the nodes array\n\n    if (i === 0 && pos.start !== 0) {\n      nodes.push({\n        text: text.slice(i, pos.start)\n      });\n    }\n\n    // If there was a last position, slice the text between the last position\n    // and the new position to insert it as a new text node\n    if (lastPos && lastPos.end < pos.start) {\n      nodes.push({\n        text: text.slice(lastPos.end, pos.start)\n      });\n    } else if (i !== 0) {\n      nodes.push({\n        text: ' '\n      });\n    }\n\n    if (pos.type === 'builtin-url' && pos.match.groups) {\n      const { leadingChar, url } = pos.match.groups;\n\n      try {\n        // Check for valid URL since the regex isn't exhaustive.\n        const { href } = new URL(pos.match.groups.protocol ? url : `https://${url}`);\n        if (!TLDs.includes(pos.match.groups.tld)) {\n          throw new Error('Invalid URL. Skipping formatting.');\n        }\n\n        if (leadingChar) {\n          nodes.push({ text: leadingChar });\n        }\n\n        nodes.push({\n          text: url,\n          href\n        });\n      } catch {\n        // Invalid URL, just render as text.\n        nodes.push({ text: pos.match[0] });\n      }\n    } else if (pos.xmlElement) {\n      const xmlAttributes = getXMLAttributes(pos.match[0]);\n\n      if (!xmlAttributes) {\n        // Invalid XML, just render as text.\n        nodes.push({ text: pos.match[0] });\n      } else if (pos.component) {\n        nodes.push({\n          type: 'custom',\n          component: pos.component,\n          content: xmlAttributes,\n          children: [{ text: '' }]\n        });\n      } else if (pos.getSearchAttributes) {\n        const searchResult = pos.getSearchAttributes(pos.xmlElement, pos.match[0]);\n        if (searchResult && searchResult.text) {\n          nodes.push({\n            text: searchResult.text,\n            searchResult: {\n              markdown: searchResult.markdown,\n              component: searchResult.component,\n              props: searchResult.props,\n              toJSON: () => undefined\n            }\n          });\n        } else {\n          nodes.push({ text: pos.match[0] });\n        }\n      }\n    }\n\n    // If we are at the end of the positions array, and there's still text left\n    // slice the text and add it as a new text node\n    if (i === positions.length - 1 && pos.end < text.length) {\n      nodes.push({\n        text: text.slice(pos.end, text.length)\n      });\n    }\n    lastPos = pos;\n  });\n\n  return nodes.length > 0 ? nodes : [{ text: '' }];\n};\n\nexport default parseTextToCustomSlateNodes;\n"]}