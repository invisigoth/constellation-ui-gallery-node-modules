{"version":3,"file":"htmlConverter.js","sourceRoot":"","sources":["../../../../src/components/RichTextEditor/utils/htmlConverter.ts"],"names":[],"mappings":"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","sourcesContent":["import { parse } from 'parse5';\n// Use namespaced types to more easily differentiate between similar types (ie, ChildNode from parse5 and Node from slate).\nimport type * as parse5 from 'parse5';\nimport type * as slate from 'slate';\n\nimport { RichTextViewerProps } from '../RichTextViewer.types';\n\nimport parseTextToCustomSlateNodes from './interactionRenderer';\n\nconst checkElement = (node: parse5.ChildNode | undefined): node is parse5.Element =>\n  !!node && node.nodeName !== '#text' && node.nodeName !== '#comment';\nconst checkTextNode = (node: parse5.ChildNode | undefined): node is parse5.TextNode =>\n  !!node && node.nodeName === '#text';\nconst checkComment = (node: parse5.ChildNode | undefined): node is parse5.TextNode =>\n  !!node && node.nodeName === '#comment';\n\n// Mapping of HTML tags to slate types. b, del, i, and a tags are labeled as skip because they need special logic\nexport const htmlToSlateMap = {\n  h1: 'heading-1',\n  h2: 'heading-2',\n  h3: 'heading-3',\n  h4: 'heading-4',\n  ul: 'unordered-list',\n  ol: 'ordered-list',\n  li: 'list-item',\n  table: 'table',\n  tr: 'table-row',\n  td: 'table-cell',\n  tbody: 'table-body',\n  p: 'paragraph',\n  img: 'image',\n  b: 'skip',\n  del: 'skip',\n  i: 'skip',\n  a: 'skip'\n} as const;\n\n// Inline HTML tags to slate types\nexport const inlineHtmlToStyleMap = {\n  b: 'bold',\n  del: 'line-through',\n  i: 'italic',\n  a: 'href'\n} as const;\n\n// Maps HTML Attributes to an object. Right now this is specifically used for list items.\n\ninterface InlineParentNodes extends slate.CosmosCustom.CustomElement {\n  href?: string;\n  italic?: boolean;\n  bold?: boolean;\n  text?: string;\n}\n\nconst getAttributes = (node: parse5.ChildNode) => {\n  if (checkElement(node) && node.attrs.length) {\n    switch (node.nodeName) {\n      case 'li':\n        return Object.fromEntries(\n          node.attrs.flatMap(attr => {\n            // eslint-disable-next-line sonarjs/no-nested-switch\n            switch (attr.name) {\n              case 'data-id':\n                return [['id', attr.value]];\n              case 'data-parent-id':\n                return [['parentId', attr.value]];\n              case 'data-level':\n                return [['level', attr.value]];\n              case 'data-order':\n                return [['order', attr.value]];\n              default:\n                return [];\n            }\n          })\n        );\n      case 'img': {\n        const imgAttrs = ['src', 'alt'];\n        const attrsObj: { [key: string]: string } = {};\n        for (let i = 0; i < node.attrs.length; i += 1) {\n          const { name, value } = node.attrs[i];\n          if (imgAttrs.includes(name)) {\n            attrsObj[name] = value;\n          }\n        }\n        return attrsObj;\n      }\n      default:\n        return {};\n    }\n  }\n  return {};\n};\n\nconst getSlateNode = (\n  node: parse5.ChildNode,\n  parentNode?: slate.Element | slate.Text,\n  interactionRenderers?: RichTextViewerProps['interactionRenderers']\n): { node: slate.Element | slate.Text; collapseNext?: boolean } => {\n  if (checkTextNode(node)) {\n    if (node.parentNode.nodeName === 'body') {\n      return {\n        node: {\n          type: 'paragraph',\n          children: [{ text: node.value }]\n        }\n      };\n    }\n    // Make sure to spread any parent style attributes for slates text nodes\n    const children = parseTextToCustomSlateNodes(\n      node.value,\n      interactionRenderers\n    ) as slate.CosmosCustom.CustomElement[];\n    if (children.length === 1) {\n      const tempParentNode = parentNode as InlineParentNodes;\n      if (children[0]?.type === 'custom') {\n        delete tempParentNode?.text;\n      }\n\n      return { node: { ...tempParentNode, ...children[0] } as slate.Text };\n    }\n    return {\n      node: {\n        ...parentNode,\n        children\n      } as slate.Element\n    };\n  }\n\n  const type = htmlToSlateMap[node.nodeName as keyof typeof htmlToSlateMap];\n  // If the type of the HTML tag is an inline (b, i, del, a) we want to let the recursive function know\n  // that it needs to collapse the next node, also we are setting the correct style mark to true\n  if (type === 'skip') {\n    const style = inlineHtmlToStyleMap[node.nodeName as 'b' | 'i' | 'del' | 'a'];\n    let value: string | boolean = true;\n    if (node.nodeName === 'a') {\n      const hrefObj = node.attrs?.find(attr => attr.name === 'href');\n      value = hrefObj ? hrefObj.value : value;\n    }\n    return {\n      node: { ...parentNode, [style]: value, text: '' } as slate.Text,\n      collapseNext: true\n    };\n  }\n\n  const attributes = getAttributes(node);\n  const nodeObj = {\n    type: type || 'paragraph',\n    ...attributes,\n    children: [{ text: '' }]\n  } as slate.Element;\n  return { node: nodeObj };\n};\n\n// Recursive function that will convert Parse5Nodes into Slate compatible nodes\nconst convertNodes = (\n  nodes: parse5.ChildNode[],\n  parentNode?: slate.Element | slate.Text,\n  interactionRenderers?: RichTextViewerProps['interactionRenderers']\n): (slate.Element | slate.Text)[] => {\n  const returnNodes: (slate.Element | slate.Text)[] = [];\n  nodes.forEach(node => {\n    const { node: slateNode, collapseNext } = getSlateNode(node, parentNode, interactionRenderers);\n    if (!checkComment(node)) {\n      let returnNode = slateNode;\n      if (checkElement(node) && node.childNodes && node.childNodes.length) {\n        if (collapseNext) {\n          returnNode = convertNodes(node.childNodes, slateNode, interactionRenderers)[0];\n        } else {\n          (slateNode as slate.Element).children = convertNodes(\n            node.childNodes,\n            undefined,\n            interactionRenderers\n          );\n          returnNode = slateNode;\n        }\n      }\n\n      returnNodes.push(returnNode);\n    }\n  });\n  return returnNodes;\n};\n\nconst defaultValue = [{ type: 'paragraph', children: [{ text: '' }] } as slate.Element];\n\nexport const convertHtml = (\n  html: string,\n  interactionRenderers?: RichTextViewerProps['interactionRenderers']\n): (slate.Element | slate.Text)[] => {\n  // Wrap the html in another body in case the value given has no body\n  const doc = parse(`<body>${html.replace('\\n', '')}</body>`);\n  let nodesToConvert = doc.childNodes;\n  // If we have a root tag\n  if (doc.childNodes.length === 1) {\n    const root = doc.childNodes[0];\n    if (!checkElement(root)) return defaultValue;\n\n    const body = root.childNodes[1];\n    if (!checkElement(body)) return defaultValue;\n\n    nodesToConvert = body.childNodes;\n  }\n  return convertNodes(nodesToConvert, undefined, interactionRenderers);\n};\n"]}