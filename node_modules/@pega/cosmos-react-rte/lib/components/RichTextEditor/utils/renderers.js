import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import styled from 'styled-components';
import { Text, Link, Image } from '@pega/cosmos-react-core';
import { Table, TableRow, TableCell, TableBody } from '../DecoratorComponents/Table';
// Renderer for block level elements
export const slateNodeRenderer = (props) => {
    switch (props.element.type) {
        case 'heading-1':
            return (_jsx(Text, { variant: 'h1', ...props.attributes, children: props.children }));
        case 'heading-2':
            return (_jsx(Text, { variant: 'h2', ...props.attributes, children: props.children }));
        case 'heading-3':
            return (_jsx(Text, { variant: 'h3', ...props.attributes, children: props.children }));
        case 'heading-4':
            return (_jsx(Text, { variant: 'h4', ...props.attributes, children: props.children }));
        case 'ordered-list':
            return _jsx("ol", { ...props.attributes, children: props.children });
        case 'unordered-list':
            return _jsx("ul", { ...props.attributes, children: props.children });
        case 'list-item':
            return (_jsx("li", { ...props.attributes, "data-order": props.element.order, "data-level": props.element.level, "data-id": props.element.id, "data-parent-id": props.element.parentId, children: props.children }));
        case 'custom': {
            const CustomComponent = props.element.component;
            let child = _jsx(CustomComponent, { ...props.attributes, children: props.element.content });
            if (props.element.href) {
                child = _jsx(Link, { href: props.element.href, children: child });
            }
            if (props.element.italic) {
                child = _jsx("em", { children: child });
            }
            if (props.element.bold) {
                child = _jsx("strong", { children: child });
            }
            if (props.element['line-through']) {
                child = _jsx("del", { children: child });
            }
            return child;
        }
        case 'override': {
            return props.element.component;
        }
        case 'table':
            return _jsx(Table, { ...props.attributes, children: props.children });
        case 'table-body':
            return _jsx(TableBody, { ...props.attributes, children: props.children });
        case 'table-row':
            return _jsx(TableRow, { ...props.attributes, children: props.children });
        case 'table-cell':
            return _jsx(TableCell, { ...props.attributes, children: props.children });
        case 'paragraph':
            return (_jsx("div", { children: _jsx(Text, { ...props.attributes, children: props.children }) }));
        case 'image':
            return (_jsxs("div", { ...props.attributes, children: [_jsx(Image, { src: props.element.src, alt: props.element.alt }), props.children] }));
        case 'image-placeholder':
            return _jsx("div", { ...props.attributes, children: props.children });
        default: {
            return _jsx("span", { ...props.attributes, children: props.children });
        }
    }
};
// Renderer for block level elements
export const nodeRenderer = (node) => {
    switch (node.type) {
        case 'heading-1':
            return _jsx(Text, { variant: 'h1', children: node.children });
        case 'heading-2':
            return _jsx(Text, { variant: 'h2', children: node.children });
        case 'heading-3':
            return _jsx(Text, { variant: 'h3', children: node.children });
        case 'heading-4':
            return _jsx(Text, { variant: 'h4', children: node.children });
        case 'ordered-list':
            return _jsx("ol", { children: node.children });
        case 'unordered-list':
            return _jsx("ul", { children: node.children });
        case 'list-item':
            return _jsx("li", { children: node.children });
        case 'custom': {
            const CustomComponent = node.component;
            let child = _jsx(CustomComponent, { children: node.content });
            if (node.href) {
                child = _jsx(Link, { href: node.href, children: child });
            }
            if (node.italic) {
                child = _jsx("em", { children: child });
            }
            if (node.bold) {
                child = _jsx("strong", { children: child });
            }
            if (node['line-through']) {
                child = _jsx("del", { children: child });
            }
            return child;
        }
        case 'override': {
            return node.component;
        }
        case 'table':
            return _jsx(Table, { children: node.children });
        case 'table-body':
            return _jsx(TableBody, { children: node.children });
        case 'table-row':
            return _jsx(TableRow, { children: node.children });
        case 'table-cell':
            return _jsx(TableCell, { children: node.children });
        case 'paragraph':
            return (_jsx("div", { children: _jsx(Text, { children: node.children }) }));
        case 'image':
            return (_jsxs("div", { children: [_jsx(Image, { src: node.src, alt: node.alt }), node.children] }));
        case 'image-placeholder':
            return _jsx("div", { children: node.children });
        case 'space':
            return _jsx("br", {});
        default: {
            return _jsx(_Fragment, { children: node.children });
        }
    }
};
// Renderer for inline elements
export const slateLeafRenderer = (props) => {
    let child = props.children;
    if (props.leaf.searchResult) {
        const CustomComponent = props.leaf.searchResult.component;
        return (_jsx("span", { ...props.attributes, children: _jsx(CustomComponent, { ...props.leaf.searchResult.props, children: child }) }));
    }
    if (props.leaf['line-through']) {
        child = _jsx("del", { children: child });
    }
    if (props.leaf.italic) {
        child = _jsx("em", { children: child });
    }
    if (props.leaf.bold) {
        child = _jsx("strong", { children: child });
    }
    if (props.leaf.href) {
        child = _jsx(Link, { href: props.leaf.href, children: child });
    }
    return _jsx("span", { ...props.attributes, children: child });
};
const StyledSpan = styled.span `
  white-space: pre-line;
`;
export const leafRenderer = (leaf) => {
    let child = leaf.text;
    if (leaf.searchResult) {
        const CustomComponent = leaf.searchResult.component;
        return (_jsx("span", { children: _jsx(CustomComponent, { ...leaf.searchResult.props, children: child }) }));
    }
    if (leaf['line-through']) {
        child = _jsx("del", { children: child });
    }
    if (leaf.italic) {
        child = _jsx("em", { children: child });
    }
    if (leaf.bold) {
        child = _jsx("strong", { children: child });
    }
    if (leaf.href) {
        child = _jsx(Link, { href: leaf.href, children: child });
    }
    return _jsx(StyledSpan, { children: child });
};
//# sourceMappingURL=renderers.js.map