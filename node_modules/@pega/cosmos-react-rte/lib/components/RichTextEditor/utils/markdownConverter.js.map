{"version":3,"file":"markdownConverter.js","sourceRoot":"","sources":["../../../../src/components/RichTextEditor/utils/markdownConverter.tsx"],"names":[],"mappings":"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","sourcesContent":["import { CosmosCustom, Element, Text } from 'slate';\nimport { marked } from 'marked';\n\nimport { hasProp } from '@pega/cosmos-react-core';\n\nimport { InteractionRenderers, RichTextViewerProps } from '../RichTextViewer.types';\n\nimport parseTextToCustomSlateNodes from './interactionRenderer';\n\nmarked.setOptions({ mangle: false });\n\nconst getNode = (\n  token: marked.Token,\n  interactionRenderers?: InteractionRenderers[],\n  markdownMap?: RichTextViewerProps['markdownMap']\n): Element | Text => {\n  if (!hasProp(token, 'type') || token.type === 'def')\n    return { type: 'paragraph', children: [{ text: '' }] };\n\n  let children;\n\n  if (hasProp(token, 'tokens')) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children = markDownToSlate(\n      (token.tokens as marked.Tokens.Link['tokens']) || [],\n      interactionRenderers,\n      markdownMap\n    );\n  } else if (hasProp(token, 'items')) {\n    // eslint-disable-next-line @typescript-eslint/no-use-before-define\n    children = markDownToSlate(token.items, interactionRenderers, markdownMap);\n  } else {\n    let mdText = '';\n\n    if (token.type === 'text') mdText = token.raw;\n    else if (hasProp(token, 'text')) mdText = token.text;\n\n    children = parseTextToCustomSlateNodes(mdText, interactionRenderers);\n  }\n\n  if (markdownMap?.[token.type]) {\n    // Typed as any since typescript is unaware that token type matches argument\n    const CustomComponent: any = markdownMap[token.type]?.(token as any);\n    if (CustomComponent)\n      return {\n        type: 'override',\n        component: <CustomComponent token={token} />,\n        children: [{ text: '' }]\n      };\n  }\n\n  if (!children.length) {\n    return {\n      type: 'paragraph',\n      children: [{ text: token.raw }]\n    };\n  }\n\n  switch (token.type) {\n    case 'paragraph': {\n      return {\n        type: token.type,\n        children\n      };\n    }\n    case 'heading': {\n      return {\n        type:\n          token.depth && token.depth <= 4\n            ? (`heading-${token.depth}` as `heading-${1 | 2 | 3 | 4}`)\n            : 'heading-4',\n        children\n      };\n    }\n    case 'link': {\n      return {\n        href: token.href,\n        text: token.text || ''\n      };\n    }\n    case 'em': {\n      return {\n        italic: true,\n        text: token.text || ''\n      };\n    }\n    case 'strong': {\n      return {\n        bold: true,\n        text: token.text || ''\n      };\n    }\n    case 'del': {\n      return {\n        'line-through': true,\n        text: token.text || ''\n      };\n    }\n    case 'list': {\n      return {\n        type: token.ordered ? 'ordered-list' : 'unordered-list',\n        children: children as CosmosCustom.ListItemElement[]\n      };\n    }\n    case 'list_item': {\n      return {\n        type: 'list-item',\n        children: children as Element[]\n      };\n    }\n    case 'image': {\n      return {\n        type: 'image',\n        alt: token.text,\n        src: token.href,\n        children: [{ text: '' }]\n      };\n    }\n    default: {\n      return {\n        type: token.type,\n        children\n      } as Element;\n    }\n  }\n};\n\nconst markDownToSlate = (\n  tokens: marked.Token[],\n  interactionRenderers?: InteractionRenderers[],\n  markdownMap?: RichTextViewerProps['markdownMap']\n): (Element | Text)[] => {\n  return tokens.map(token => {\n    return getNode(token, interactionRenderers, markdownMap);\n  });\n};\n\nexport const convertMarkdownForEditor = (\n  md = '',\n  searchRenderers?: InteractionRenderers[]\n): (Element | Text)[] => {\n  return [\n    {\n      type: 'paragraph',\n      children: parseTextToCustomSlateNodes(md, searchRenderers)\n    }\n  ];\n};\n\n// Converts markdown into Slate compatible nodes, also takes regex used\n// in Feed Component to pass them down to custom elements\nconst convertMarkdown = (\n  md: string,\n  interactionRenderers?: InteractionRenderers[],\n  markdownMap?: RichTextViewerProps['markdownMap']\n): (Element | Text)[] => {\n  const lexer = new marked.Lexer({ gfm: false });\n  const output = lexer.lex(md);\n  return markDownToSlate(output, interactionRenderers, markdownMap);\n};\n\nexport default convertMarkdown;\n"]}