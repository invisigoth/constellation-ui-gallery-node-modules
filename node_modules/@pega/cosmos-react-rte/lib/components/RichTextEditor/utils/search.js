import { Editor, Range } from 'slate';
// eslint-disable-next-line import/prefer-default-export
export const onSearchChange = (editor, { groupId, regex, trigger }) => {
    const { selection } = editor;
    let collapsed;
    // Prevents error on triple clicks
    try {
        collapsed = selection ? Range.isCollapsed(selection) : false;
    }
    catch (e) {
        collapsed = false;
    }
    if (selection && collapsed) {
        // Gets the cursor position in the RTE
        const [cursorPos] = Range.edges(selection);
        // Gets the Slate node at the search trigger
        const [searchNode] = Editor.node(editor, cursorPos);
        // If the search is triggered from within a searchResult node, ignore the search
        if (searchNode?.searchResult)
            return;
        // Gets the point before the line that is currently being typed in the RTE
        const posBeforeWord = Editor.before(editor, cursorPos, { unit: 'line' });
        // Gets the range before the line up to the cursor position
        const lineRange = posBeforeWord && Editor.range(editor, posBeforeWord, cursorPos);
        // Gets all of the text on the current line
        const lineText = lineRange && Editor.string(editor, lineRange);
        // Matches the text on the current line with the regex provided
        const beforeMatch = lineText && lineText.match(regex);
        if (beforeMatch && typeof beforeMatch.groups?.[groupId] === 'string') {
            const matchLength = beforeMatch.groups.match.length;
            // Gets the range of the matching text to place the popover correctly
            const targetRange = Editor.range(editor, { ...cursorPos, offset: cursorPos.offset - matchLength }, cursorPos);
            return { search: beforeMatch.groups[groupId], target: targetRange, trigger };
        }
    }
};
//# sourceMappingURL=search.js.map