import { jsx as _jsx } from "react/jsx-runtime";
import { marked } from 'marked';
import { hasProp } from '@pega/cosmos-react-core';
import parseTextToCustomSlateNodes from './interactionRenderer';
marked.setOptions({ mangle: false });
const getNode = (token, interactionRenderers, markdownMap) => {
    if (!hasProp(token, 'type') || token.type === 'def')
        return { type: 'paragraph', children: [{ text: '' }] };
    let children;
    if (hasProp(token, 'tokens')) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        children = markDownToSlate(token.tokens || [], interactionRenderers, markdownMap);
    }
    else if (hasProp(token, 'items')) {
        // eslint-disable-next-line @typescript-eslint/no-use-before-define
        children = markDownToSlate(token.items, interactionRenderers, markdownMap);
    }
    else {
        let mdText = '';
        if (token.type === 'text')
            mdText = token.raw;
        else if (hasProp(token, 'text'))
            mdText = token.text;
        children = parseTextToCustomSlateNodes(mdText, interactionRenderers);
    }
    if (markdownMap?.[token.type]) {
        // Typed as any since typescript is unaware that token type matches argument
        const CustomComponent = markdownMap[token.type]?.(token);
        if (CustomComponent)
            return {
                type: 'override',
                component: _jsx(CustomComponent, { token: token }),
                children: [{ text: '' }]
            };
    }
    if (!children.length) {
        return {
            type: 'paragraph',
            children: [{ text: token.raw }]
        };
    }
    switch (token.type) {
        case 'paragraph': {
            return {
                type: token.type,
                children
            };
        }
        case 'heading': {
            return {
                type: token.depth && token.depth <= 4
                    ? `heading-${token.depth}`
                    : 'heading-4',
                children
            };
        }
        case 'link': {
            return {
                href: token.href,
                text: token.text || ''
            };
        }
        case 'em': {
            return {
                italic: true,
                text: token.text || ''
            };
        }
        case 'strong': {
            return {
                bold: true,
                text: token.text || ''
            };
        }
        case 'del': {
            return {
                'line-through': true,
                text: token.text || ''
            };
        }
        case 'list': {
            return {
                type: token.ordered ? 'ordered-list' : 'unordered-list',
                children: children
            };
        }
        case 'list_item': {
            return {
                type: 'list-item',
                children: children
            };
        }
        case 'image': {
            return {
                type: 'image',
                alt: token.text,
                src: token.href,
                children: [{ text: '' }]
            };
        }
        default: {
            return {
                type: token.type,
                children
            };
        }
    }
};
const markDownToSlate = (tokens, interactionRenderers, markdownMap) => {
    return tokens.map(token => {
        return getNode(token, interactionRenderers, markdownMap);
    });
};
export const convertMarkdownForEditor = (md = '', searchRenderers) => {
    return [
        {
            type: 'paragraph',
            children: parseTextToCustomSlateNodes(md, searchRenderers)
        }
    ];
};
// Converts markdown into Slate compatible nodes, also takes regex used
// in Feed Component to pass them down to custom elements
const convertMarkdown = (md, interactionRenderers, markdownMap) => {
    const lexer = new marked.Lexer({ gfm: false });
    const output = lexer.lex(md);
    return markDownToSlate(output, interactionRenderers, markdownMap);
};
export default convertMarkdown;
//# sourceMappingURL=markdownConverter.js.map