import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useState, useRef, useMemo, useEffect, useCallback, useImperativeHandle } from 'react';
// Import the Slate editor factory.
import { createEditor, Editor, Node, Transforms } from 'slate';
// Import the Slate components and React plugin.
import { Slate, Editable, withReact, ReactEditor } from 'slate-react';
import { withHistory } from 'slate-history';
import styled from 'styled-components';
import { FormField, FormControl, StyledPopover, useTheme, useUID, createUID, debounce, Popover, Menu, useOuterEvent } from '@pega/cosmos-react-core';
import StyledRichTextEditor, { StyledEditorContainer } from './RichTextEditor.styles';
import Toolbar from './Toolbar/Toolbar';
import { slateNodeRenderer, slateLeafRenderer } from './utils/renderers';
import { onSearchChange } from './utils/search';
import EditorCommands from './utils/EditorCommands';
import ListCommands from './utils/ListCommands';
import { convertHtml } from './utils/htmlConverter';
import { convertSlateToHtml } from './utils/slateConverter';
import { RichTextEditorContext } from './RichTextEditor.context';
import { convertMarkdownForEditor } from './utils/markdownConverter';
const withVoids = (editor) => {
    editor.isVoid = element => {
        return element.type === 'image' || element.type === 'image-placeholder';
    };
    return editor;
};
const StyledSearchPopover = styled(StyledPopover) `
  min-width: 20rem;
`;
const RichTextEditor = forwardRef(function RichTextEditor(props, ref) {
    const { components: { 'text-area': { 'min-height': minHeight } } } = useTheme();
    const uid = useUID();
    const labelId = useUID();
    const { id = uid, label, labelHidden, info, status, required, disabled, readOnly, additionalInfo, onChange, onFocus, onBlur, placeholder, toolbar, onImageAdded, markdownOnly, searchTriggers, onSearch, getSearchItemReplacement, searchRenderers, menu, height = { min: minHeight }, defaultValue, autoFocus, ...restProps } = props;
    const formFieldRef = useRef(null);
    const editor = useMemo(() => withVoids(withReact(withHistory(createEditor()))), []);
    const [value, setValue] = useState(() => defaultValue && !markdownOnly
        ? convertHtml(defaultValue)
        : convertMarkdownForEditor(defaultValue, searchRenderers));
    const [focus, setFocus] = useState(autoFocus);
    const [toolbarPopover, setToolbarPopover] = useState(false);
    const [toolbarSticky, setToolbarSticky] = useState(false);
    const [focusableToolbarBtn, setFocusableToolbarBtn] = useState(null);
    const [popoverTarget, setPopoverTarget] = useState(null);
    const [searchEl, setSearchEl] = useState(null);
    const updateToolbarStyle = () => {
        if ((formFieldRef.current?.offsetHeight || 0) > window.innerHeight) {
            setToolbarSticky(true);
        }
        else {
            setToolbarSticky(false);
        }
    };
    const debouncedUpdateToolbarStyle = debounce(updateToolbarStyle, 200);
    const getPlainText = () => {
        return value
            .map(node => {
            if (markdownOnly && node.children) {
                return node.children
                    .map(child => {
                    let textNode = child;
                    if (child.type === 'text') {
                        const children = child.children;
                        // When input is copied and pasted text nodes can be split into multiple texts, this handles that case
                        if (children.length === 1) {
                            textNode = children[0];
                        }
                        else {
                            return children
                                .map(subChild => {
                                const childText = subChild;
                                if (childText.searchResult) {
                                    return childText.searchResult.markdown;
                                }
                                return childText.text;
                            })
                                .join('');
                        }
                    }
                    return textNode.searchResult?.markdown || textNode.text;
                })
                    .join('');
            }
            return Node.string(node);
        })
            .join('\n');
    };
    const onEditorFocus = ({ event, force, focusEditor, runAfterFocus }) => {
        if (focusEditor) {
            setTimeout(() => {
                if (!ReactEditor.isFocused(editor)) {
                    ReactEditor.focus(editor);
                    setFocus(true);
                    if (!editor.selection) {
                        Transforms.select(editor, {
                            anchor: Editor.end(editor, [0]),
                            focus: Editor.end(editor, [0])
                        });
                    }
                    onFocus?.();
                }
            }, 0);
        }
        if (runAfterFocus && (force || (!disabled && !toolbarPopover))) {
            setTimeout(runAfterFocus, 0);
        }
        else {
            event?.stopPropagation();
        }
    };
    const blurEditor = (force) => {
        if (force)
            ReactEditor.blur(editor);
        if (ReactEditor.isFocused(editor)) {
            onBlur?.();
        }
        setFocus(false);
        setPopoverTarget(null);
    };
    useOuterEvent('click', [formFieldRef.current], () => blurEditor());
    useImperativeHandle(ref, () => ({
        focus: () => {
            onEditorFocus({ focusEditor: true });
        },
        getPlainText: () => {
            return getPlainText();
        },
        getRichText: () => {
            return JSON.stringify(value);
        },
        getHtml: () => {
            return convertSlateToHtml(value);
        },
        clear: () => {
            const point = { path: [0, 0], offset: 0 };
            editor.selection = { anchor: point, focus: point };
            editor.children = [
                {
                    type: 'paragraph',
                    children: [{ text: '' }]
                }
            ];
            setValue(editor.children);
        },
        appendImage: ({ src, alt }, imageId) => {
            const path = EditorCommands.appendImage(editor, { src, alt }, imageId);
            if (path) {
                Transforms.select(editor, { anchor: path, focus: path });
                ReactEditor.focus(editor);
                setFocus(true);
            }
        },
        insertText: (text) => {
            editor.insertText(text);
        },
        insertHtml: (html, overwrite = false) => {
            if (overwrite) {
                const point = { path: [0, 0], offset: 0 };
                editor.selection = { anchor: point, focus: point };
                editor.children = convertHtml(html !== '' ? html : '<p></p>');
            }
            else {
                editor.children = [...value, ...convertHtml(html)];
            }
            setValue(editor.children);
        }
    }), [editor, value]);
    const onMenuItemClick = (itemId, e) => {
        // MenuItem expects actual click events, but we don't have reference to actual menu item element to trigger a click.
        menu?.onItemClick?.(itemId, e);
        const replacement = getSearchItemReplacement?.(itemId);
        if (replacement) {
            let node;
            if (replacement.markdown && replacement.component && replacement.props) {
                node = {
                    text: replacement.text,
                    searchResult: {
                        markdown: replacement.markdown,
                        component: replacement.component,
                        props: replacement.props,
                        // Prevents copying searchResult attribute onPaste
                        toJSON: () => undefined
                    }
                };
            }
            else {
                node = { text: replacement.text };
            }
            EditorCommands.replaceWithNodes(editor, popoverTarget, node);
            Transforms.insertNodes(editor, { text: ' ' });
        }
    };
    const onKeyDown = useCallback((event) => {
        if (popoverTarget && menu) {
            if (event.key === 'Escape') {
                event.preventDefault();
                setPopoverTarget(null);
            }
            if (['Enter', 'ArrowDown', 'ArrowUp'].includes(event.key)) {
                event.preventDefault();
            }
        }
        else if (event.key === 'Tab' && !event.shiftKey) {
            if (focusableToolbarBtn) {
                focusableToolbarBtn.focus();
                event.preventDefault();
            }
        }
        else {
            ListCommands.checkListEnter(editor, event);
            EditorCommands.checkLinkBreak(editor, event);
            EditorCommands.checkSearchDownKeys(editor, event);
            EditorCommands.checkImageEnter(editor, event);
            EditorCommands.checkKeyCommands(editor, event, markdownOnly);
        }
    }, [menu, popoverTarget, focusableToolbarBtn]);
    const onKeyUp = (event) => {
        EditorCommands.checkSearchUpKeys(editor, event);
    };
    // Adds an image placeholder to be replaced later in time by an image
    const addImage = (file) => {
        const placeholderId = EditorCommands.appendImagePlaceholder(editor);
        if (placeholderId)
            onImageAdded?.(file, placeholderId);
    };
    const onPaste = (e) => {
        let image;
        for (let i = 0; i < e.clipboardData.items.length; i += 1) {
            const item = e.clipboardData.items[i];
            if (item.type.startsWith('image')) {
                image = item.getAsFile();
            }
        }
        if (image) {
            e.preventDefault();
            addImage(image);
        }
    };
    const onDrop = (e) => {
        e.preventDefault();
        if (e.dataTransfer) {
            Array.from(e.dataTransfer.files).forEach(file => {
                if (file.type.includes('image')) {
                    addImage(file);
                }
            });
        }
    };
    const selectAll = () => {
        const elements = Array.from(Node.elements(editor));
        const firstPath = elements[0][1];
        const lastPath = elements[elements.length - 1][1];
        Transforms.select(editor, {
            anchor: Editor.start(editor, firstPath),
            focus: Editor.end(editor, lastPath)
        });
    };
    useEffect(() => {
        if (popoverTarget) {
            setSearchEl(ReactEditor.toDOMRange(editor, popoverTarget));
        }
    }, [popoverTarget]);
    useEffect(() => {
        onChange?.();
    }, [value]);
    useEffect(() => {
        if (autoFocus) {
            setTimeout(() => {
                ReactEditor.focus(editor);
                setFocus(true);
            }, 0);
        }
    }, []);
    return (_jsx(RichTextEditorContext.Provider
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    , { 
        // eslint-disable-next-line react/jsx-no-constructed-context-values
        value: {
            addImage,
            setPopoverOpen: setToolbarPopover,
            onEditorFocus,
            disabled: disabled || false
        }, children: _jsx(FormField, { toolbar: !!(!markdownOnly && toolbar?.length), label: 
            // eslint-disable-next-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events
            _jsx("span", { onClick: () => onEditorFocus({ focusEditor: true }), children: label }), labelHidden: labelHidden, labelFor: '', labelId: labelId, id: id, info: info, status: status, required: required, disabled: disabled, additionalInfo: additionalInfo, readOnly: readOnly, onDrop: onDrop, onFocus: (e) => {
                if (e.target === formFieldRef.current && !disabled) {
                    onEditorFocus({ focusEditor: true });
                }
            }, ref: formFieldRef, "aria-label": `${label} ${!markdownOnly && !readOnly && toolbar?.length ? 'Hit tab to edit toolbar below' : ''}`, tabIndex: disabled ? -1 : undefined, children: _jsxs(Slate, { editor: editor, value: value, onChange: newValue => {
                    if (!disabled) {
                        setValue(newValue);
                        debouncedUpdateToolbarStyle();
                        if (searchTriggers && onSearch && markdownOnly) {
                            const res = searchTriggers.flatMap(({ trigger, regex }) => {
                                for (let i = 0; i < 10; i += 1) {
                                    try {
                                        const groupId = createUID();
                                        return [
                                            {
                                                trigger,
                                                groupId: `g${groupId}`,
                                                regex: new RegExp(String.raw `(?:^|\s)(?<match>${trigger}(?<g${groupId}>${regex || String.raw `\w*`}))$`)
                                            }
                                        ];
                                    }
                                    catch (e) {
                                        if (!(e instanceof SyntaxError))
                                            throw e;
                                    }
                                }
                                // Failsafe
                                return [];
                            });
                            let search;
                            for (let i = 0; i < res.length; i += 1) {
                                search = onSearchChange(editor, res[i]);
                                if (search)
                                    break;
                            }
                            if (search) {
                                setPopoverTarget(search.target);
                                onSearch({ search: search.search, trigger: search.trigger });
                            }
                            else {
                                setPopoverTarget(null);
                            }
                        }
                    }
                }, children: [_jsxs(FormControl, { ...restProps, ref: ref, ariaLabel: label, required: required, disabled: disabled, readOnly: readOnly, status: status, as: StyledRichTextEditor, onClick: () => {
                            onEditorFocus({ focusEditor: true });
                        }, focused: focus, tabIndex: readOnly ? 0 : undefined, children: [_jsx(StyledEditorContainer, { containerHeight: height, onClick: () => {
                                    if (!disabled) {
                                        onEditorFocus({ focusEditor: true });
                                    }
                                }, children: _jsx(Editable, { id: id, renderElement: slateNodeRenderer, renderLeaf: slateLeafRenderer, onKeyDown: onKeyDown, onKeyUp: onKeyUp, placeholder: placeholder, onFocus: (event) => {
                                        onEditorFocus({ focusEditor: true, event });
                                    }, onBlur: () => blurEditor(), disabled: disabled, readOnly: readOnly, onPaste: onPaste, tabIndex: disabled ? -1 : undefined, onClick: e => {
                                        if (e.detail === 3) {
                                            e.preventDefault();
                                            selectAll();
                                        }
                                    }, "aria-labelledby": labelId }) }), !markdownOnly && !readOnly && toolbar?.length ? (_jsx(Toolbar, { features: toolbar, sticky: toolbarSticky, setFocusableBtn: el => {
                                    setFocusableToolbarBtn(el);
                                } })) : null] }), _jsx(Popover, { show: !!popoverTarget && !!menu, strategy: 'fixed', target: searchEl, placement: 'bottom-start', children: menu && (_jsx(Menu, { ...menu, as: StyledSearchPopover, focusControlEl: formFieldRef.current?.querySelector('[role="textbox"]') || undefined, mode: 'action', onItemClick: onMenuItemClick })) })] }) }) }));
});
export default RichTextEditor;
//# sourceMappingURL=RichTextEditor.js.map