import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import tinymce from 'tinymce/tinymce';
import 'tinymce/icons/default';
import 'tinymce/themes/silver';
import 'tinymce/plugins/advlist';
import 'tinymce/plugins/lists';
import 'tinymce/plugins/autolink';
import 'tinymce/models/dom';
import { forwardRef, useEffect, useRef, useState, useLayoutEffect, useImperativeHandle, useCallback, useMemo } from 'react';
import styled, { css } from 'styled-components';
import { compile, serialize, stringify } from 'stylis';
import { stripUnit } from 'polished';
import { createUID, FormControl, FormField, useAfterInitialEffect, useTheme, useUID, useI18n, useConsolidatedRef, defaultThemeProp, useAutoResize, useConfiguration, documentIsAvailable, getActiveElement } from '@pega/cosmos-react-core';
import { getHtmlStyles } from '@pega/cosmos-react-core/lib/components/HTML/HTML';
import { createGlobalBodyStyles, createGlobalRootStyles, globalSpacingStyles } from '@pega/cosmos-react-core/lib/styles/GlobalStyle';
import StyledRichTextEditor from '../RichTextEditor/RichTextEditor.styles';
import Toolbar from './Toolbar/Toolbar';
import EditorContext from './Editor.context';
import { getTextFormats } from './Toolbar/TextSelect';
import ImageEditor, { imgHoverClass } from './ImageEditor';
import { offscreenSelectionStyles, placeholderStyles, mceContentBodyStyles, StyledEditorContainer } from './Editor.styles';
const getFileFromUrl = async (url, name) => {
    const response = await fetch(url);
    const data = await response.blob();
    return new File([data], name, {
        type: data.type
    });
};
export const getImageStyles = (theme) => {
    return `
    img:hover,
    img.${imgHoverClass} {
      box-shadow: 0 0 0 0.06125rem ${theme.base.palette['primary-background']},
        0 0 0 0.125rem ${theme.base.palette.interactive}, 0 0 0 0.25rem rgba(0, 118, 209, 0.3);
    }
  `;
};
export const StyledInnerEditor = styled.div(({ theme, showPlaceholder }) => {
    return css `
      ${showPlaceholder &&
        css `
        ::before {
          color: ${theme.base.colors.slate.medium};
          position: absolute;
          content: attr(data-mce-placeholder);
        }
      `}
    `;
});
StyledInnerEditor.defaultProps = defaultThemeProp;
const Editor = forwardRef(function Editor(props, ref) {
    const { components: { 'text-area': { 'min-height': textAreaMinHeight } } } = useTheme();
    const theme = useTheme();
    const { styleSheetTarget } = useConfiguration();
    const [editor, setEditor] = useState();
    const [focused, setFocused] = useState(false);
    const t = useI18n();
    const uid = useUID();
    const labelId = useUID();
    const editorRef = useConsolidatedRef(ref);
    const tinyMceRef = useRef(null);
    const tinyMceContainerRef = useRef(null);
    const initialized = useRef(false);
    const { id = uid, toolbar = [], label, labelHidden, info, status, required, disabled, readOnly, onChange, onKeyDown, onFocus, onBlur, onImageAdded, onInit, defaultValue, customComponents = [], height, customActions, placeholder, children, spellcheck = true, ...restProps } = props;
    const baseHeight = {
        min: height?.min ?? stripUnit(textAreaMinHeight) * 16,
        max: height?.max ?? undefined
    };
    const getHeight = (type) => {
        if (typeof baseHeight === 'number') {
            return stripUnit(baseHeight);
        }
        if (baseHeight[type]) {
            return stripUnit(baseHeight[type]);
        }
        return undefined;
    };
    const imagesEnabled = toolbar.includes('images');
    const maxHeight = getHeight('max');
    const minHeight = getHeight('min');
    const [autoResizeRef, resizeEditor] = useAutoResize(maxHeight, minHeight);
    const formFieldRef = useRef(null);
    const value = useRef(defaultValue);
    const renderToolbar = editor && toolbar.length > 0 && !readOnly && !disabled;
    const processPastedImgUrls = async (infoArr) => {
        const files = await Promise.all(infoArr.map(({ id: imgId, url }) => getFileFromUrl(url, imgId)));
        files.forEach((file, i) => {
            onImageAdded?.(file, infoArr[i].id);
        });
    };
    const pastePreprocess = (plugin, args) => {
        const isImg = args.content.includes('<img');
        if (!imagesEnabled && isImg) {
            args.content = args.content.replace(/<img(.*)\/>/g, '');
        }
        if (imagesEnabled && isImg) {
            const pastedHtml = new DOMParser().parseFromString(args.content, 'text/html').body;
            const imgInfo = [];
            pastedHtml.querySelectorAll('img').forEach(imgEl => {
                const imgId = createUID();
                const url = imgEl.src;
                imgInfo.push({ id: imgId, url });
                imgEl.setAttribute('id', imgId);
                imgEl.setAttribute('src', '');
            });
            args.content = pastedHtml.innerHTML;
            processPastedImgUrls(imgInfo);
        }
    };
    useImperativeHandle(editorRef, () => ({
        focus: () => {
            editor?.focus();
        },
        getPlainText: () => {
            return editor ? editor.getContent({ format: 'text' }) : '';
        },
        getRichText: () => {
            return editor ? JSON.stringify(editor.getContent({ format: 'raw' })) : '';
        },
        getHtml: () => {
            return editor ? editor.getContent({ format: 'html' }) : '';
        },
        clear: () => {
            editor?.setContent('');
        },
        appendImage: ({ src, alt }, imageId) => {
            if (editor) {
                const editorEl = editor.getDoc();
                const imageEl = editorEl.querySelector(`#${imageId}`);
                if (imageEl) {
                    imageEl.setAttribute('src', src);
                    imageEl.setAttribute('alt', alt);
                    resizeEditor();
                }
            }
        },
        insertText: (text) => {
            let activeElement = null;
            if (documentIsAvailable) {
                activeElement = getActiveElement();
            }
            editor?.insertContent(text);
            if (activeElement)
                activeElement.focus();
        },
        setCursorLocationToStart: () => {
            editor?.selection.setCursorLocation();
            editor?.selection.getNode().scrollIntoView();
        },
        insertHtml: (html, overwrite = false) => {
            let activeElement = null;
            if (documentIsAvailable) {
                activeElement = getActiveElement();
            }
            if (overwrite) {
                editor?.setContent('');
            }
            editor?.insertContent(html);
            if (activeElement)
                activeElement.focus();
        },
        getEditor: () => {
            return editor;
        },
        element: formFieldRef.current || undefined
    }), [editor]);
    useLayoutEffect(() => {
        if (!tinyMceRef.current || !tinyMceContainerRef.current)
            return;
        const styles = serialize(compile(getHtmlStyles(theme)), stringify);
        const imageStyles = serialize(compile(getImageStyles(theme)), stringify);
        tinymce
            .init({
            readonly: readOnly || disabled,
            skin: false,
            target: tinyMceRef.current,
            toolbar: false,
            min_height: 60,
            height: 60,
            menubar: false,
            plugins: 'lists advlist autolink',
            paste_block_drop: true,
            paste_data_images: true,
            lists_indent_on_tab: true,
            icons: '',
            branding: false,
            elementpath: false,
            placeholder,
            content_css: false,
            browser_spellcheck: spellcheck,
            paste_preprocess: pastePreprocess,
            content_style: `${createGlobalRootStyles(theme)} ${globalSpacingStyles} ${createGlobalBodyStyles(theme)} body { min-height: 3rem; padding: ${theme.base.spacing}; } html { overflow: hidden; } ${offscreenSelectionStyles} ${mceContentBodyStyles} ${placeholderStyles} ${imageStyles} ${styles}`,
            init_instance_callback: initializedEditor => {
                const iframeWindow = (tinyMceContainerRef.current?.querySelector('iframe')).contentWindow;
                const editorCustomElements = iframeWindow?.customElements;
                if (editorCustomElements) {
                    customComponents.forEach(({ name, createCustomElement: customElementCreator, style }) => {
                        if (!editorCustomElements.get(name)) {
                            editorCustomElements.define(name, customElementCreator(iframeWindow));
                        }
                        if (style) {
                            const styleEl = document.createElement('style');
                            styleEl.innerText = style;
                            initializedEditor.getDoc().head.appendChild(styleEl);
                        }
                    });
                }
            },
            extended_valid_elements: `${customComponents
                .map(comp => `${comp.name}${comp.extensionAttributes ? `[${comp.extensionAttributes.join('|')}]` : ''}`)
                .join(',')}`,
            custom_elements: customComponents.map(comp => `~${comp.name}`).join('~,'),
            setup: editorSettings => {
                editorSettings.on('keydown', e => {
                    onKeyDown?.(e);
                });
                getTextFormats().forEach((format, i) => {
                    editorSettings.addShortcut(`meta+alt+${i}`, `${t('rte_change_text_format')} ${format.text}`, () => {
                        editorSettings.execCommand('FormatBlock', false, format.type);
                    });
                });
                editorSettings.addShortcut('meta+shift+b', t('rte_bold'), () => {
                    editorSettings.execCommand('Bold');
                });
                editorSettings.addShortcut('meta+shift+i', t('rte_italic'), () => {
                    editorSettings.execCommand('Italic');
                });
                editorSettings.addShortcut('meta+shift+x', t('rte_strike_through'), () => {
                    editorSettings.execCommand('Strikethrough');
                });
                editorSettings.addShortcut('meta+shift+l', t('rte_toggle_unordered_list'), () => {
                    editorSettings.execCommand('InsertUnorderedList');
                });
                editorSettings.addShortcut('alt+m', t('rte_indent_selection'), () => {
                    editorSettings.execCommand('Indent');
                });
                editorSettings.addShortcut('alt+shift+m', t('rte_unindent_selection'), () => {
                    editorSettings.execCommand('Outdent');
                });
                customActions?.forEach(action => {
                    if (action.shortcut) {
                        editorSettings.addShortcut(action.shortcut.pattern, action.shortcut.description, () => {
                            action.shortcut?.command(editorSettings);
                        });
                    }
                });
            }
        })
            .then(tinymceEditors => {
            setEditor(tinymceEditors[0]);
            tinymceEditors[0].editorContainer?.setAttribute('style', '');
            const iframe = tinyMceContainerRef.current?.querySelector('iframe');
            if (iframe) {
                const globalStyles = styleSheetTarget?.querySelectorAll('[data-cosmos-global-style]') ??
                    [];
                const extraStyles = document.querySelectorAll('[data-cosmos-global-style]') ?? [];
                const iframeContentHead = iframe?.contentDocument?.querySelector('head');
                [...globalStyles, ...extraStyles].forEach(sheet => {
                    iframeContentHead?.appendChild(sheet.cloneNode(true));
                });
                autoResizeRef.current = iframe;
                resizeEditor();
            }
        });
    }, []);
    useEffect(() => {
        if (editor) {
            editor.options.set('paste_preprocess', pastePreprocess);
        }
    }, [imagesEnabled]);
    useEffect(() => {
        if (!editor || initialized.current)
            return;
        initialized.current = true;
        onInit?.(editor);
    }, [editor, onInit]);
    useEffect(() => {
        if (!editor)
            return;
        const onChangeEvents = ['input', 'paste', 'FormatApply', 'FormatRemove', 'ExecCommand'];
        const onEditorKeyDown = (event) => {
            resizeEditor();
            if (event.key === 'Enter') {
                editor.selection.getNode().scrollIntoView(false);
            }
        };
        const onEditorChange = (event) => {
            if (event.type !== 'execcommand' || event.command !== 'mceFocus') {
                onChange?.(editor);
            }
        };
        const onEditorFocus = () => {
            setFocused(true);
            onFocus?.();
        };
        const onEditorBlur = () => {
            setFocused(false);
            onBlur?.();
        };
        onChangeEvents.forEach(event => {
            editor.on(event, onEditorChange);
        });
        editor.on('keydown', onEditorKeyDown);
        editor.on('paste', resizeEditor);
        editor.on('focus', onEditorFocus);
        editor.on('blur', onEditorBlur);
        return () => {
            onChangeEvents.forEach(event => {
                editor.off(event, onEditorChange);
            });
            editor.off('keydown', onEditorKeyDown);
            editor.off('paste', resizeEditor);
            editor.off('focus', onEditorFocus);
            editor.off('blur', onEditorBlur);
        };
    }, [editor, onFocus, onBlur]);
    useAfterInitialEffect(() => {
        editor?.mode.set(readOnly || disabled ? 'readonly' : 'design');
    }, [readOnly, disabled]);
    const addImage = useCallback((image) => {
        if (editor) {
            const imageId = createUID();
            editor.insertContent(`<br/><img src='' id='${imageId}' style="max-width: 100%;"/><br/>`);
            onImageAdded?.(image, imageId);
        }
    }, [editor]);
    const ctx = useMemo(() => ({ addImage, editor: editor || {} }), [editor, addImage]);
    useEffect(() => {
        const onEditorDrop = (e) => {
            e.preventDefault();
            if (e.dataTransfer) {
                Array.from(e.dataTransfer.files).forEach(file => {
                    if (file.type.includes('image') && imagesEnabled) {
                        addImage(file);
                    }
                });
            }
        };
        editor?.on('drop', onEditorDrop);
        const body = editor?.getDoc().body;
        const resizeObserver = new ResizeObserver(() => {
            resizeEditor();
        });
        if (body) {
            resizeObserver.observe(body);
        }
        return () => {
            editor?.off('drop', onEditorDrop);
            resizeObserver.disconnect();
        };
    }, [editor, resizeEditor]);
    return (_jsxs(EditorContext.Provider, { value: ctx, children: [_jsx(FormField, { toolbar: renderToolbar, label: 
                // eslint-disable-next-line jsx-a11y/no-static-element-interactions, jsx-a11y/click-events-have-key-events
                _jsx("span", { onClick: () => {
                        editor?.focus();
                    }, children: label }), labelFor: '', labelId: labelId, labelHidden: labelHidden, id: id, info: info, status: status, required: required, disabled: disabled, readOnly: readOnly, onFocus: (e) => {
                    if (e.target === formFieldRef.current && !disabled) {
                        editor?.focus();
                    }
                }, ref: formFieldRef, tabIndex: disabled ? -1 : undefined, children: _jsxs(FormControl, { ...restProps, ref: editorRef, required: required, disabled: disabled, readOnly: readOnly, status: status, as: StyledRichTextEditor, focused: focused, tabIndex: readOnly ? 0 : undefined, children: [_jsxs(StyledEditorContainer, { onClick: () => {
                                if (!disabled) {
                                    editor?.focus();
                                }
                            }, ref: tinyMceContainerRef, children: [_jsx("textarea", { id: id, value: value.current || '', onChange: () => { }, "aria-label": `${label}${renderToolbar ? `. ${t('rte_toolbar_instructions')}.` : ''}`, "aria-labelledby": labelId, ref: tinyMceRef }), tinyMceContainerRef.current && editor && !readOnly && (_jsx(ImageEditor, { editor: editor, editorEl: tinyMceContainerRef.current, onChange: () => onChange?.(editor) }))] }), renderToolbar && (_jsx(Toolbar, { features: toolbar, editor: editor, customActions: customActions }))] }) }), children] }));
});
export default Editor;
//# sourceMappingURL=Editor.js.map