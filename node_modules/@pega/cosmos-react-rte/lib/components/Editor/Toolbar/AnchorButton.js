import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useState, useEffect, useLayoutEffect } from 'react';
import { Button, CardContent, Grid, Icon, registerIcon, Input, Popover, useOuterEvent, Form, useI18n } from '@pega/cosmos-react-core';
import * as chainIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/chain.icon';
import ToolbarButton from '../../RichTextEditor/Toolbar/ToolbarButton';
import { getKeyCommand } from '../../RichTextEditor/Toolbar/utils';
registerIcon(chainIcon);
const AnchorButton = ({ osx, editor, ...restProps }) => {
    const t = useI18n();
    const buttonRef = useRef(null);
    const textInputRef = useRef(null);
    const urlInputRef = useRef(null);
    const popoverRef = useRef(null);
    const [selectedText, setSelectedText] = useState('');
    const [selection, setSelection] = useState();
    const [url, setUrl] = useState('');
    const [urlMatch, setUrlMatch] = useState(false);
    const [anchorMenu, setAnchorMenu] = useState(false);
    const [shouldFocusInput, setShouldFocusInput] = useState(false);
    const tooltip = getKeyCommand(osx, ({ ctrl }) => `${t('rte_link')} (${ctrl}K)`);
    const openMenu = (opts = {}) => {
        setAnchorMenu(true);
        if (opts.focusInput) {
            setShouldFocusInput(true);
        }
    };
    const resetMenu = () => {
        setSelection(undefined);
        setSelectedText('');
        setUrl('');
        setUrlMatch(true);
        setAnchorMenu(false);
    };
    useOuterEvent('mousedown', [popoverRef, buttonRef], () => {
        if (anchorMenu) {
            resetMenu();
        }
    });
    const createLink = () => {
        if (url && selection) {
            editor.focus();
            editor.selection = selection;
            if (selection.getNode().tagName === 'A') {
                const anchorEl = editor.selection.getNode();
                anchorEl.setAttribute('href', url);
                anchorEl.setAttribute('data-mce-href', url);
                anchorEl.textContent = selectedText;
            }
            else {
                editor.insertContent(`<a href='${new URL(/^[a-z][a-z0-9.+-]*:/i.test(url) ? url : `https:${url}`).href}'>${selectedText}</a>`);
            }
            resetMenu();
        }
    };
    useEffect(() => {
        if (anchorMenu) {
            if (editor.selection) {
                const selectedEl = editor.selection.getNode();
                if (selectedEl?.tagName === 'A') {
                    setSelectedText(selectedEl.textContent || '');
                    setUrl(selectedEl.getAttribute('href') || '');
                }
                else {
                    setSelectedText(editor.selection.getContent({ format: 'text' }));
                }
                setSelection({ ...editor.selection });
            }
        }
        else {
            resetMenu();
        }
    }, [anchorMenu]);
    const preventDef = (e) => {
        e.preventDefault();
        e.stopPropagation();
    };
    const isLinkActive = () => {
        return editor.selection.getNode().tagName === 'A' && editor.hasFocus();
    };
    const cancelAnchorCreation = (event) => {
        if (((event?.type === 'keydown' && event?.key === 'Enter') ||
            event?.type === 'mousedown' ||
            !event) &&
            anchorMenu) {
            event?.preventDefault();
            resetMenu();
            buttonRef.current?.focus();
        }
    };
    useEffect(() => {
        const keyCommandListener = (e) => {
            if (e.key === 'k' && (e.metaKey || e.ctrlKey) && editor.hasFocus()) {
                e.preventDefault();
                openMenu({ focusInput: true });
            }
            if (e.key === 'Escape') {
                cancelAnchorCreation();
            }
        };
        editor.getDoc().addEventListener('keydown', keyCommandListener);
        return () => {
            editor.getDoc().removeEventListener('keydown', keyCommandListener);
        };
    }, []);
    useLayoutEffect(() => {
        if (anchorMenu && shouldFocusInput) {
            textInputRef.current?.focus();
            setShouldFocusInput(false);
        }
    }, [textInputRef.current]);
    useEffect(() => {
        // These events must be added here so they run before the native event in useArrows (used in the toolbar).
        const onKeyDown = (e) => {
            e.stopPropagation();
        };
        textInputRef.current?.addEventListener('keydown', onKeyDown);
        urlInputRef.current?.addEventListener('keydown', onKeyDown);
        return () => {
            textInputRef.current?.removeEventListener('keydown', onKeyDown);
            urlInputRef.current?.removeEventListener('keydown', onKeyDown);
        };
    }, [textInputRef.current, urlInputRef.current]);
    return (_jsxs(_Fragment, { children: [_jsx(ToolbarButton, { ref: buttonRef, onMouseDown: e => {
                    e.preventDefault();
                    openMenu();
                }, onKeyDown: (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        openMenu({ focusInput: true });
                    }
                }, active: isLinkActive(), tooltip: tooltip, label: t('rte_link'), ...restProps, children: _jsx(Icon, { name: 'chain' }) }), _jsx(Popover, { show: anchorMenu, target: buttonRef.current, ref: popoverRef, placement: 'bottom', children: _jsx(CardContent, { children: _jsx(Form, { as: 'div', actions: _jsxs(_Fragment, { children: [_jsx(Button, { variant: 'secondary', onKeyDown: cancelAnchorCreation, onMouseDown: cancelAnchorCreation, type: 'button', children: "Cancel" }), _jsx(Button, { disabled: !url || !urlMatch, name: 'apply', variant: 'primary', onClick: (e) => {
                                        e.preventDefault();
                                        createLink();
                                    }, children: "Apply" })] }), children: _jsxs(Grid, { container: { rowGap: 2 }, children: [_jsx(Input, { label: 'Text', value: selectedText, onClick: preventDef, onChange: (e) => {
                                        setSelectedText(e.target.value);
                                    }, ref: textInputRef }), _jsx(Input, { label: 'URL', value: url, onClick: preventDef, onChange: (e) => {
                                        const urlInput = e.target.value;
                                        setUrl(urlInput);
                                        if (!urlMatch) {
                                            try {
                                                // eslint-disable-next-line no-new
                                                new URL(/^[a-z][a-z0-9+.-]*:/i.test(urlInput) ? urlInput : `https:${urlInput}`);
                                                setUrlMatch(true);
                                            }
                                            catch {
                                                setUrlMatch(false);
                                            }
                                        }
                                    }, onBlur: () => {
                                        try {
                                            // eslint-disable-next-line no-new
                                            new URL(/^[a-z][a-z0-9+.-]*:/i.test(url) ? url : `https:${url}`);
                                            setUrlMatch(true);
                                        }
                                        catch {
                                            setUrlMatch(false);
                                        }
                                    }, info: !urlMatch ? t('rte_invalid_url') : '', status: !urlMatch ? 'error' : undefined, ref: urlInputRef })] }) }) }) })] }));
};
export default AnchorButton;
//# sourceMappingURL=AnchorButton.js.map