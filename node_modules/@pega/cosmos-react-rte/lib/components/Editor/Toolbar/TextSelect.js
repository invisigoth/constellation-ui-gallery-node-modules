import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useState, useMemo } from 'react';
import styled, { css } from 'styled-components';
import { Popover, Icon, registerIcon, useOuterEvent, Menu, Button, defaultThemeProp, useI18n, Tooltip, calculateFontSize } from '@pega/cosmos-react-core';
import * as arrowMicroDownIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/arrow-micro-down.icon';
import { getKeyCommand } from '../../RichTextEditor/Toolbar/utils';
registerIcon(arrowMicroDownIcon);
const StyledTextSelect = styled(Button)(({ theme }) => {
    const fontSizes = calculateFontSize(theme.base['font-size'], theme.base['font-scale']);
    return css `
    color: ${theme.base.palette['foreground-color']};
    display: inline-flex;
    align-items: center;
    border-radius: calc(0.25 * ${theme.base['border-radius']});
    height: calc(4 * ${theme.base.spacing});
    padding: calc(0.5 * ${theme.base.spacing});
    font-size: ${fontSizes.xxs};

    span {
      white-space: nowrap;
    }

    :focus {
      box-shadow: ${theme.base.shadow.focus};
    }
  `;
});
StyledTextSelect.defaultProps = defaultThemeProp;
const StyledSelectMenu = styled.div `
  min-width: 20ch;
`;
const textMapping = {
    p: 'Normal',
    h1: 'Heading 1',
    h2: 'Heading 2',
    h3: 'Heading 3',
    h4: 'Heading 4',
    '': 'Normal',
    div: 'Normal'
};
const getTextCommand = (num, osx) => {
    return getKeyCommand(osx, ({ ctrl, alt }) => `${ctrl}${alt}${num}`);
};
export const getTextFormats = (osx = false) => {
    return [
        { text: 'Normal', subText: getTextCommand(0, osx), type: 'p' },
        { text: 'Heading 1', subText: getTextCommand(1, osx), type: 'h1' },
        { text: 'Heading 2', subText: getTextCommand(2, osx), type: 'h2' },
        { text: 'Heading 3', subText: getTextCommand(3, osx), type: 'h3' },
        { text: 'Heading 4', subText: getTextCommand(4, osx), type: 'h4' }
    ];
};
const TextSelect = ({ osx, editor }) => {
    const t = useI18n();
    const [open, setOpen] = useState(false);
    const selecting = useRef(false);
    const openedByClick = useRef(false);
    const buttonRef = useRef(null);
    const popoverRef = useRef(null);
    const menuRef = useRef(null);
    const textFormats = useMemo(() => {
        return getTextFormats(osx);
    }, [osx]);
    useOuterEvent('click', [buttonRef, popoverRef, menuRef], () => {
        setOpen(false);
    });
    const onTextSelect = (type, e) => {
        e.stopPropagation();
        e.preventDefault();
        editor.execCommand('FormatBlock', false, type);
        if (!openedByClick.current) {
            buttonRef.current?.focus();
        }
        setOpen(false);
        selecting.current = true;
        setTimeout(() => {
            if (!editor.hasFocus() && openedByClick.current) {
                editor.focus();
            }
        }, 0);
    };
    const getParentTextFormat = (el) => {
        const elTagName = el.nodeName.toLowerCase();
        if (textMapping[elTagName]) {
            return elTagName;
        }
        if (el.parentNode) {
            return getParentTextFormat(el.parentNode);
        }
        return undefined;
    };
    const activeFormat = () => {
        return editor.hasFocus()
            ? getParentTextFormat(editor.selection.getNode())
            : editor.contentDocument?.body?.firstChild?.nodeName.toLowerCase();
    };
    const getFormatText = () => {
        const activeFormatType = activeFormat();
        const format = activeFormatType ? textMapping[activeFormatType] : 'Unknown';
        return format || 'Unknown';
    };
    return (_jsxs(_Fragment, { children: [_jsxs(StyledTextSelect, { variant: 'simple', type: 'button', icon: false, ref: buttonRef, onMouseDown: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    setOpen(true);
                    openedByClick.current = true;
                }, onKeyDown: (e) => {
                    if (e.key === 'Enter' && !selecting.current) {
                        e.preventDefault();
                        setOpen(true);
                        openedByClick.current = false;
                    }
                    else if (e.key === 'Enter') {
                        e.preventDefault();
                        selecting.current = false;
                    }
                    else if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        setOpen(false);
                    }
                }, onFocus: (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                }, onClick: (e) => e.stopPropagation(), "aria-expanded": open, "aria-label": `${t('rte_text_formatting_toolbar')}. ${t('rte_heading_style')}. ${getFormatText()} ${t('selected').toLocaleLowerCase()}`, "aria-haspopup": true, children: [_jsx("span", { children: getFormatText() }), _jsx(Icon, { name: 'arrow-micro-down' })] }), buttonRef.current && (_jsx(Tooltip, { target: buttonRef.current, showDelay: 'none', hideDelay: 'none', children: t('rte_heading_style') })), _jsx(Popover, { show: open, as: StyledSelectMenu, target: buttonRef.current, placement: 'bottom-start', ref: popoverRef, children: _jsx(Menu, { items: textFormats.map(({ text, type, subText }) => ({
                        id: type,
                        primary: text,
                        secondary: [subText],
                        selected: type === activeFormat()
                    })), focusControlEl: buttonRef.current ?? undefined, mode: 'single-select', ref: menuRef, onItemClick: onTextSelect }) })] }));
};
export default TextSelect;
//# sourceMappingURL=TextSelect.js.map