import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useEffect, useRef, useCallback } from 'react';
import styled, { css } from 'styled-components';
import { Flex, Icon, useArrows, useI18n, defaultThemeProp, registerIcon, useOS, navigatorIsAvailable } from '@pega/cosmos-react-core';
import * as indentIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/indent.icon';
import * as unindentIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/unindent.icon';
import ToolbarButton from '../../RichTextEditor/Toolbar/ToolbarButton';
import { getKeyCommand } from '../../RichTextEditor/Toolbar/utils';
import ImageButton from './ImageButton';
import TextSelect from './TextSelect';
import AnchorButton from './AnchorButton';
registerIcon(indentIcon, unindentIcon);
const StyledToolbar = styled.div(({ sticky, theme }) => {
    return css `
    background-color: ${theme.base.palette['primary-background']};
    border-radius: calc(0.25 * ${theme.base['border-radius']});
    overflow: auto;
    padding: calc(0.5 * ${theme.base.spacing});
    ${sticky &&
        css `
      position: sticky;
      bottom: 0;
    `}

    &:has(:focus-visible) {
      box-shadow: ${theme.base.shadow['focus-group']};
    }
  `;
});
StyledToolbar.defaultProps = defaultThemeProp;
const isMobile = navigatorIsAvailable && navigator.userAgent.includes('Mobile');
// Function that returns the text styling buttons
function renderStyleButtons(editor, t, activeStyles, osx) {
    const inlineStyleButtons = [
        {
            style: 'BOLD',
            text: 'B',
            format: 'Bold',
            label: t('rte_bold'),
            element: 'strong',
            tooltip: isMobile
                ? `${t('rte_bold')}`
                : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_bold')} (${ctrl}B, ${ctrl}${shift}B)`)
        },
        {
            style: 'ITALIC',
            text: 'I',
            format: 'Italic',
            label: t('rte_italic'),
            element: 'i',
            tooltip: isMobile
                ? `${t('rte_italic')}`
                : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_italic')} (${ctrl}I, ${ctrl}${shift}I)`)
        },
        {
            style: 'STRIKE-THROUGH',
            text: 'S',
            format: 'Strikethrough',
            element: 's',
            label: t('rte_strike_through'),
            tooltip: isMobile
                ? `${t('rte_strike_through')}`
                : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_strike_through')} (${ctrl}${shift}X)`)
        }
    ];
    return inlineStyleButtons.map(({ format, style, text, label, tooltip }) => {
        return (_jsx(ToolbarButton, { onMouseDown: e => {
                e.preventDefault();
                if (editor.hasFocus()) {
                    editor.execCommand(format);
                }
                else {
                    editor.focus();
                    setTimeout(() => {
                        editor.execCommand(format);
                    }, 0);
                }
            }, styleType: style, active: activeStyles[format.toLowerCase()], tooltip: tooltip, label: label, children: text }, style));
    });
}
// Takes the features array and transforms it into a map for faster lookup
function createActiveFeaturesMap(features) {
    return features.reduce((acc, feature) => {
        return { ...acc, [feature]: true };
    }, {});
}
const Toolbar = ({ features, sticky, editor, customActions }) => {
    const t = useI18n();
    const { macintosh: osx } = useOS();
    const toolbarRef = useRef(null);
    useArrows(toolbarRef, { selector: 'button, input[type="file"]', dir: 'left-right' });
    const [activeFeatures, setActiveFeatures] = useState(() => createActiveFeaturesMap(features));
    const [activeStyles, setActiveStyles] = useState(() => ({
        bold: false,
        italic: false,
        strikethrough: false,
        unorderedList: false,
        orderedList: false
    }));
    const getIndentationToolTip = (type) => getKeyCommand(osx, ({ shift, alt }) => type === 'indent' ? `${t('rte_indent')} (${alt}M)` : `${t('rte_unindent')} (${alt}${shift}M)`);
    const tooltipMobile = (type) => type === 'indent' ? `${t('rte_indent')}` : `${t('rte_unindent')}`;
    useEffect(() => {
        setActiveFeatures(createActiveFeaturesMap(features));
    }, [features]);
    const getActiveStyles = useCallback(() => {
        if (editor.hasFocus()) {
            setActiveStyles({
                bold: editor.queryCommandState('Bold'),
                italic: editor.queryCommandState('Italic'),
                strikethrough: editor.queryCommandState('Strikethrough'),
                unorderedList: editor.queryCommandState('InsertUnorderedList'),
                orderedList: editor.queryCommandState('InsertOrderedList')
            });
        }
        else {
            setActiveStyles({
                bold: false,
                italic: false,
                strikethrough: false,
                unorderedList: false,
                orderedList: false
            });
        }
    }, [editor, setActiveStyles]);
    useEffect(() => {
        getActiveStyles();
        editor.on('SelectionChange', getActiveStyles);
        return () => {
            editor.off('SelectionChange', getActiveStyles);
        };
    }, [editor, getActiveStyles]);
    return (_jsxs(Flex, { as: StyledToolbar, sticky: sticky, container: { justify: 'between' }, ref: toolbarRef, children: [_jsxs(Flex, { container: { alignItems: 'end' }, children: [_jsx(TextSelect, { osx: osx, editor: editor }), activeFeatures['inline-styling'] && renderStyleButtons(editor, t, activeStyles, osx), activeFeatures.lists && (_jsxs(_Fragment, { children: [_jsx(ToolbarButton, { onMouseDown: e => {
                                    e.preventDefault();
                                    editor.execCommand('InsertUnorderedList');
                                }, active: activeStyles.unorderedList, tooltip: isMobile
                                    ? `${t('rte_bulleted_list')}`
                                    : getKeyCommand(osx, ({ ctrl, shift }) => `${t('rte_bulleted_list')} (${ctrl}${shift}L)`), label: t('rte_bulleted_list'), children: _jsx(Icon, { name: 'list' }) }), _jsx(ToolbarButton, { onMouseDown: e => {
                                    e.preventDefault();
                                    editor.execCommand('InsertOrderedList');
                                }, active: activeStyles.orderedList, tooltip: t('rte_numbered_list'), label: t('rte_numbered_list'), children: _jsx(Icon, { name: 'list-number' }) })] })), activeFeatures.indentation && (_jsxs(_Fragment, { children: [_jsx(ToolbarButton, { onMouseDown: e => {
                                    e.preventDefault();
                                    editor.execCommand('Indent');
                                }, label: t('rte_indent'), tooltip: isMobile ? tooltipMobile('indent') : getIndentationToolTip('indent'), children: _jsx(Icon, { name: 'indent' }) }), _jsx(ToolbarButton, { onMouseDown: e => {
                                    e.preventDefault();
                                    editor.execCommand('Outdent');
                                }, label: t('rte_unindent'), tooltip: isMobile ? tooltipMobile('unindent') : getIndentationToolTip('unindent'), children: _jsx(Icon, { name: 'unindent' }) })] }))] }), _jsxs(Flex, { container: { alignItems: 'end' }, children: [customActions?.map(action => {
                        return (_jsx(ToolbarButton, { onMouseDown: e => {
                                e.preventDefault();
                                action.onMouseDown(e);
                            }, tooltip: action.text, label: action.text, active: action.active?.(editor) || false, children: _jsx(Icon, { name: action.icon }) }, action.icon));
                    }), activeFeatures.links && _jsx(AnchorButton, { editor: editor, osx: osx }), activeFeatures.images && _jsx(ImageButton, { editor: editor })] })] }));
};
export default Toolbar;
//# sourceMappingURL=Toolbar.js.map