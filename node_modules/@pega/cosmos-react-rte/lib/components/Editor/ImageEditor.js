import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef, useState, useLayoutEffect } from 'react';
import styled from 'styled-components';
import { Button, CardContent, CardHeader, Checkbox, createUID, Flex, Form, Grid, Icon, Input, NumberInput, Popover, Text, useAfterInitialEffect, useElement, useI18n, useOuterEvent, useUID, VisuallyHiddenText } from '@pega/cosmos-react-core';
const IgnoreMouseEventsIcon = styled.svg `
  pointer-events: none;
`;
export const imgHoverClass = createUID();
const ImageEditor = ({ editorEl, editor, onChange }) => {
    const t = useI18n();
    const id = useUID();
    const [showImagePopover, setShowImagePopover] = useState(false);
    const [imageEditHover, setImageEditHover] = useState(false);
    const [imageEditFocus, setImageEditFocus] = useState(false);
    const [canShowEditButton, setCanShowEditButton] = useState(false);
    const [imgEl, setImageEl] = useState(null);
    const [imgElements, setImageElements] = useState([]);
    const [buttonEl, setButtonEl] = useElement(null);
    const [width, setWidth] = useState(0);
    const [height, setHeight] = useState(0);
    const [aspectRatio, setAspectRatio] = useState(0);
    const [altText, setAltText] = useState('');
    const [customSize, setCustomSize] = useState(false);
    const [keyCommandText, setKeyCommandText] = useState('');
    const imagePopoverRef = useRef(null);
    const altTextInputRef = useRef(null);
    const editorOpenedWithEnter = useRef(false);
    const [btnStyle, setBtnStyle] = useState({});
    const onImageClick = (e) => {
        e.preventDefault();
        e.stopPropagation();
        setShowImagePopover(true);
    };
    const calculateBtnStyles = (el) => {
        const elementRect = el.getBoundingClientRect();
        return {
            position: 'absolute',
            top: elementRect.top + (elementRect.height / 2 - (buttonEl?.scrollHeight || 0) / 2),
            left: elementRect.left + (elementRect.width / 2 - (buttonEl?.scrollWidth || 0) / 2)
        };
    };
    const onImageMouseEnter = (e) => {
        if (!showImagePopover) {
            const el = e.target;
            setImageEditHover(true);
            setImageEl(el);
        }
    };
    const onImageMouseLeave = (e) => {
        if (e.relatedTarget && e.relatedTarget.id !== id && !showImagePopover) {
            setImageEl(null);
            setImageEditHover(false);
        }
    };
    const setImageState = () => {
        if (imgEl) {
            let imgHeight;
            let imgWidth;
            let hasHeightOrWidthAttribute = false;
            if (imgEl.getAttribute('height')) {
                imgHeight = parseInt(imgEl.getAttribute('height'), 10);
                hasHeightOrWidthAttribute = true;
            }
            else {
                imgHeight = imgEl.naturalHeight;
            }
            if (imgEl.getAttribute('width')) {
                imgWidth = parseInt(imgEl.getAttribute('width'), 10);
                hasHeightOrWidthAttribute = true;
            }
            else {
                imgWidth = imgEl.naturalWidth;
            }
            setAltText(imgEl.getAttribute('alt') || '');
            setHeight(imgHeight);
            setWidth(imgWidth);
            setAspectRatio(imgWidth / imgHeight);
            setCustomSize(hasHeightOrWidthAttribute);
        }
    };
    useOuterEvent('mousedown', [imagePopoverRef], () => {
        setImageState();
        setShowImagePopover(false);
    });
    const onCheckBoxClick = (e) => {
        e.stopPropagation();
    };
    const onInputClick = (e) => {
        e.stopPropagation();
        e.preventDefault();
    };
    const onInputFocus = (e) => {
        e.stopPropagation();
    };
    const onAltTextChange = (e) => {
        setAltText(e.target.value);
    };
    // The next two functions handle changing the height and width of the selected image element.
    // If the value entered is too small, the value will be defaulted.
    // When the height is input, a new width will be calculated and vice versa.
    const onHeightChange = (incomingValue) => {
        const inputHeight = parseInt(incomingValue, 10);
        setHeight(inputHeight);
        setWidth(inputHeight * aspectRatio);
    };
    const onWidthChange = (incomingValue) => {
        const inputWidth = parseInt(incomingValue, 10);
        setWidth(inputWidth);
        setHeight(inputWidth / aspectRatio);
    };
    const onImageChangeSubmit = (e) => {
        e.preventDefault();
        if (imgEl) {
            if (customSize) {
                if (Number.isNaN(height) || Number.isNaN(width)) {
                    imgEl.removeAttribute('height');
                    imgEl.removeAttribute('width');
                    setHeight(imgEl.naturalHeight);
                    setWidth(imgEl.naturalWidth);
                }
                else {
                    imgEl.setAttribute('height', height.toString());
                    imgEl.setAttribute('width', width.toString());
                }
            }
            else {
                imgEl.removeAttribute('height');
                imgEl.removeAttribute('width');
            }
            imgEl.setAttribute('alt', altText);
        }
        editor.selection.select(editor.dom.select(`img[src="${imgEl?.src}"]`)[0]);
        setImageEl(null);
        setShowImagePopover(false);
        onChange();
    };
    const onImageChangeCancel = () => {
        setImageEl(null);
        setShowImagePopover(false);
    };
    const onImageDelete = () => {
        if (imgEl) {
            imgEl.remove();
        }
        setImageEl(null);
        setShowImagePopover(false);
        onChange();
    };
    // Keeps the imageElements state up to date with existing and newly added img tags inside of TinyMCE
    useEffect(() => {
        const iframeDoc = editor.getDoc();
        const imageElements = iframeDoc?.querySelectorAll('img') ?? [];
        setImageElements(() => {
            return [...imageElements];
        });
        const observer = new MutationObserver(mutations => {
            mutations.forEach(mutation => {
                if (mutation.type === 'childList' &&
                    (mutation.addedNodes.length || mutation.removedNodes.length)) {
                    const newImageElements = iframeDoc?.querySelectorAll('img') ?? [];
                    setImageElements(() => [...newImageElements]);
                }
            });
        });
        if (iframeDoc) {
            observer.observe(iframeDoc.body, { childList: true, subtree: true });
        }
        return () => {
            observer.disconnect();
        };
    }, [editorEl, editor, setImageElements]);
    // Adds event listeners to HTML img elements inside of TinyMCE
    // This has to be done because there are no react components for these images
    useEffect(() => {
        imgElements.forEach(imgElement => {
            imgElement.addEventListener('mouseenter', onImageMouseEnter);
            imgElement.addEventListener('mouseout', onImageMouseLeave);
            imgElement.addEventListener('click', onImageClick);
        });
        return () => {
            imgElements.forEach(imgElement => {
                imgElement.removeEventListener('mouseenter', onImageMouseEnter);
                imgElement.removeEventListener('mouseout', onImageMouseLeave);
                imgElement.removeEventListener('click', onImageClick);
            });
        };
    }, [imgElements, onImageMouseEnter, onImageMouseLeave, onImageClick]);
    useEffect(() => {
        setImageState();
        imgEl?.setAttribute('class', imgHoverClass);
        if (imgEl && imgEl.clientHeight > 36 && imgEl.clientWidth > 36) {
            setCanShowEditButton(true);
        }
        else {
            setCanShowEditButton(false);
        }
        return () => {
            imgEl?.removeAttribute('class');
        };
    }, [imgEl]);
    useEffect(() => {
        const onKeyUp = () => {
            const selection = editor.selection.getSel();
            let nextToImg = false;
            // If your selection is next to an image on it's own line (not breaking text)
            if (selection &&
                selection.anchorNode?.childNodes.length === 1 &&
                selection.anchorNode?.firstChild?.nodeName === 'IMG' &&
                selection.anchorOffset === 0) {
                setImageEl(selection.anchorNode.firstChild);
                setImageEditFocus(true);
                nextToImg = true;
                // If your selection is next to an image that breaks text up inside of a paragraph
            }
            else if (selection && selection.anchorNode?.nextSibling?.nodeName === 'IMG') {
                setImageEl(selection.anchorNode.nextSibling);
                setImageEditFocus(true);
                nextToImg = true;
            }
            else if (selection && imgEl && imageEditFocus) {
                setImageEl(null);
                setImageEditFocus(false);
                setKeyCommandText('');
            }
            if (nextToImg) {
                setKeyCommandText(t('rte_image_key_command'));
            }
        };
        const onKeyDown = (e) => {
            if (e.key === 'Enter' && imageEditFocus) {
                e.stopPropagation();
                e.preventDefault();
                editorOpenedWithEnter.current = true;
                setShowImagePopover(true);
            }
            else if (e.key === 'Del' && imageEditFocus) {
                onImageDelete();
            }
        };
        editor.on('keyup', onKeyUp);
        editor.on('keydown', onKeyDown, true);
        return () => {
            editor.off('keyup', onKeyUp);
            editor.off('keydown', onKeyDown);
        };
    }, [editor, imgEl, imageEditFocus]);
    useAfterInitialEffect(() => {
        if (showImagePopover) {
            editor.selection.getSel()?.collapseToEnd();
            if (editorOpenedWithEnter.current) {
                altTextInputRef.current?.focus();
                editorOpenedWithEnter.current = false;
            }
        }
        else {
            editor.focus();
        }
    }, [showImagePopover]);
    useLayoutEffect(() => {
        if (imgEl && buttonEl) {
            setBtnStyle(calculateBtnStyles(imgEl));
        }
    }, [imgEl, buttonEl]);
    return (_jsxs(_Fragment, { children: [(imageEditFocus || imageEditHover) && imgEl && canShowEditButton && (_jsx(Button, { id: id, icon: true, variant: 'primary', ref: setButtonEl, onClick: () => {
                    setShowImagePopover(true);
                }, style: { ...btnStyle }, children: _jsx(Icon, { name: 'pencil-solid', as: IgnoreMouseEventsIcon }) })), _jsx(VisuallyHiddenText, { "aria-live": 'polite', children: keyCommandText }), showImagePopover && (buttonEl || !canShowEditButton) && imgEl && (_jsxs(Popover, { target: canShowEditButton ? buttonEl : imgEl, strategy: 'fixed', arrow: true, ref: imagePopoverRef, onClick: (e) => e.stopPropagation(), children: [_jsx(CardHeader, { actions: _jsx(Button, { variant: 'simple', icon: true, onClick: onImageChangeCancel, label: t('close'), children: _jsx(Icon, { name: 'times' }) }), children: _jsx(Text, { variant: 'h3', children: t('rte_image_settings') }) }), _jsx(CardContent, { children: _jsx(Form, { as: 'div', actions: _jsxs(Flex, { container: { justify: 'between' }, item: { grow: 1 }, children: [_jsxs(Flex, { item: { grow: 1 }, children: [_jsx(Button, { onClick: onImageChangeCancel, children: t('cancel') }), _jsx(Button, { onClick: onImageDelete, children: t('delete') })] }), _jsx(Button, { variant: 'primary', onClick: onImageChangeSubmit, children: t('submit') })] }), children: _jsxs(Grid, { container: {
                                    gap: 2,
                                    areas: customSize
                                        ? '"desc desc" "radio radio" "width height"'
                                        : '"desc desc" "radio radio"'
                                }, children: [_jsx(Grid, { item: { area: 'desc' }, children: _jsx(Input, { label: t('description'), value: altText, onClick: onInputClick, onChange: onAltTextChange, onFocus: onInputFocus, info: t('rte_image_description_info'), ref: altTextInputRef }) }), _jsx(Grid, { item: { area: 'radio' }, children: _jsx(Checkbox, { checked: customSize, label: t('rte_image_custom_size'), onClick: onCheckBoxClick, onChange: (e) => {
                                                setCustomSize(e.target.checked);
                                            } }) }), customSize && (_jsxs(_Fragment, { children: [_jsx(Grid, { item: { area: 'width' }, children: _jsx(NumberInput, { label: t('rte_width_in_pixels'), value: Math.floor(Math.max(width, 1)).toString(), onClick: onInputClick, onChange: onWidthChange }) }), _jsx(Grid, { item: { area: 'height' }, children: _jsx(NumberInput, { label: t('rte_height_in_pixels'), value: Math.floor(Math.max(height, 1)).toString(), onClick: onInputClick, onChange: onHeightChange }) })] }))] }) }) })] }))] }));
};
export default ImageEditor;
//# sourceMappingURL=ImageEditor.js.map