{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/types/types.ts"],"names":[],"mappings":"","sourcesContent":["import type { DOMAttributes, ElementType, MouseEvent, Ref } from 'react';\n\nexport interface BaseProps {\n  /** Additional CSS classes. */\n  className?: string;\n}\n\nexport type TestIdsRecord<Elements extends readonly string[] | undefined> = {\n  root: string;\n} & {\n  [Key in NonNullable<Elements>[number] as KebabToCamel<Key>]: string;\n};\n\nexport interface TestIdProp<Elements extends readonly string[] | undefined = undefined> {\n  /**\n   * Applies a data-testid attribute to a component's root element and may be utilized as a prefix for descendant elements.\n   * Descendant element data-testid attributes are applied in a component to component specific manner.\n   */\n  testId?: Elements extends undefined ? string : string | Partial<TestIdsRecord<Elements>>;\n}\n\nexport interface ForwardProps {\n  [prop: string]: unknown;\n}\n\nexport interface NoChildrenProp {\n  children?: never;\n}\n\nexport type HTMLTag = keyof JSX.IntrinsicElements;\nexport interface AsProp {\n  /** HTML tag or React Component to render the component as. */\n  as?: ElementType;\n  /** HTML tag or React Component to finally render the component as. */\n  forwardedAs?: ElementType;\n}\n\nexport interface Action extends ForwardProps {\n  /** A string to uniquely identify this Action within the onClick handler. */\n  id: string;\n  /** The text content of the Action. */\n  text: string;\n  /** The name of the Cosmos Icon to render, if any. */\n  icon?: string;\n  /** A location to navigate to. Passing an href will render a Link styled as a Button. */\n  href?: string;\n  /** Called when the Action is clicked. */\n  onClick?: (\n    id: string,\n    e: MouseEvent<HTMLButtonElement | HTMLAnchorElement | HTMLInputElement>,\n    /**\n     * If the action was rendered as an item in a menu the associated menuButton element will be provided.\n     * Often necessary for focus purposes.\n     */\n    menuButton?: HTMLButtonElement\n  ) => void;\n  /** Determines if the Action will be disabled. */\n  disabled?: boolean;\n}\n\nexport type ExcludeStrict<T, U extends T> = T extends U ? never : T;\n\nexport type KnownKeys<T> = keyof {\n  [K in keyof T as string extends K ? never : number extends K ? never : K]: unknown;\n};\n\n// Modified from https://github.com/microsoft/TypeScript/issues/31153#issuecomment-487872268\nexport type OmitStrict<T, K extends KnownKeys<T>> = Pick<T, ExcludeStrict<KnownKeys<T>, K>> &\n  (number extends keyof T ? { [k: number]: T[number] } : unknown) &\n  (string extends keyof T ? { [k: string]: T[string] } : unknown);\n\nexport type PartialByKey<T extends object, K extends KnownKeys<T>> = OmitStrict<T, K> &\n  Partial<Pick<T, K>>;\n\nexport type RequiredByKey<T extends object, K extends KnownKeys<T>> = OmitStrict<T, K> &\n  Required<Pick<T, K>>;\n\nexport type DeepPartial<T> = T extends (infer U)[]\n  ? DeepPartial<U>[]\n  : T extends object\n  ? { [K in keyof T]?: DeepPartial<T[K]> }\n  : T;\n\nexport type DeepRequired<T> = T extends (infer U)[]\n  ? DeepRequired<U>[]\n  : T extends Function\n  ? T\n  : T extends object\n  ? { [K in keyof T]-?: DeepRequired<T[K]> }\n  : T;\n\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n};\n\n// https://stackoverflow.com/a/49725198\nexport type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<\n  T,\n  ExcludeStrict<keyof T, Keys>\n> &\n  {\n    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, ExcludeStrict<Keys, K>>>;\n  }[Keys];\n\n// Lowers type inference precedence without changing the type.\n// https://github.com/Microsoft/TypeScript/issues/14829#issue-216577598\nexport type DeferInfer<T> = T & { [K in keyof T]: T[K] };\n\nexport type PropsWithDefaults<\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Props extends object = {},\n  Defaults extends KnownKeys<Props> = never\n> = OmitStrict<Props, Defaults> & Required<Pick<Props, Defaults>>;\n\n// Modified from https://github.com/microsoft/TypeScript/pull/40336\nexport type KebabToPascal<S extends string> = S extends `${infer T}-${infer U}`\n  ? `${Capitalize<T>}${KebabToPascal<U>}`\n  : Capitalize<S>;\n\nexport type KebabToCamel<S extends string> = string extends S\n  ? string\n  : S extends `-${infer T}`\n  ? KebabToCamel<T>\n  : S extends `${infer T}-${infer U}`\n  ? `${T}${KebabToPascal<U>}`\n  : S;\n\nexport type HeadingTag = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';\n\nexport type ElementTag = keyof JSX.IntrinsicElements;\n\nexport type AttributesWithoutRef<T extends ElementTag> = OmitStrict<\n  JSX.IntrinsicElements[T],\n  // Don't use the built-in ref property to avoid legacy string refs.\n  | 'ref'\n  // Don't implicitly allow, must be enabled manually if needed.\n  | 'dangerouslySetInnerHTML'\n>;\n\nexport type Attributes<T extends ElementTag> = AttributesWithoutRef<T> &\n  (JSX.IntrinsicElements[T] extends DOMAttributes<infer E> ? { ref?: Ref<E> | undefined } : never);\n\nexport type RefElement<T extends { ref?: Ref<any> | undefined }> = T['ref'] extends\n  | Ref<infer E>\n  | undefined\n  ? E\n  : never;\n\nexport type PrettyPrint<T> = T extends object\n  ? {\n      [K in keyof T]: T[K];\n    }\n  : T;\n"]}