import type { DOMAttributes, ElementType, MouseEvent, Ref } from 'react';
export interface BaseProps {
    /** Additional CSS classes. */
    className?: string;
}
export type TestIdsRecord<Elements extends readonly string[] | undefined> = {
    root: string;
} & {
    [Key in NonNullable<Elements>[number] as KebabToCamel<Key>]: string;
};
export interface TestIdProp<Elements extends readonly string[] | undefined = undefined> {
    /**
     * Applies a data-testid attribute to a component's root element and may be utilized as a prefix for descendant elements.
     * Descendant element data-testid attributes are applied in a component to component specific manner.
     */
    testId?: Elements extends undefined ? string : string | Partial<TestIdsRecord<Elements>>;
}
export interface ForwardProps {
    [prop: string]: unknown;
}
export interface NoChildrenProp {
    children?: never;
}
export type HTMLTag = keyof JSX.IntrinsicElements;
export interface AsProp {
    /** HTML tag or React Component to render the component as. */
    as?: ElementType;
    /** HTML tag or React Component to finally render the component as. */
    forwardedAs?: ElementType;
}
export interface Action extends ForwardProps {
    /** A string to uniquely identify this Action within the onClick handler. */
    id: string;
    /** The text content of the Action. */
    text: string;
    /** The name of the Cosmos Icon to render, if any. */
    icon?: string;
    /** A location to navigate to. Passing an href will render a Link styled as a Button. */
    href?: string;
    /** Called when the Action is clicked. */
    onClick?: (id: string, e: MouseEvent<HTMLButtonElement | HTMLAnchorElement | HTMLInputElement>, 
    /**
     * If the action was rendered as an item in a menu the associated menuButton element will be provided.
     * Often necessary for focus purposes.
     */
    menuButton?: HTMLButtonElement) => void;
    /** Determines if the Action will be disabled. */
    disabled?: boolean;
}
export type ExcludeStrict<T, U extends T> = T extends U ? never : T;
export type KnownKeys<T> = keyof {
    [K in keyof T as string extends K ? never : number extends K ? never : K]: unknown;
};
export type OmitStrict<T, K extends KnownKeys<T>> = Pick<T, ExcludeStrict<KnownKeys<T>, K>> & (number extends keyof T ? {
    [k: number]: T[number];
} : unknown) & (string extends keyof T ? {
    [k: string]: T[string];
} : unknown);
export type PartialByKey<T extends object, K extends KnownKeys<T>> = OmitStrict<T, K> & Partial<Pick<T, K>>;
export type RequiredByKey<T extends object, K extends KnownKeys<T>> = OmitStrict<T, K> & Required<Pick<T, K>>;
export type DeepPartial<T> = T extends (infer U)[] ? DeepPartial<U>[] : T extends object ? {
    [K in keyof T]?: DeepPartial<T[K]>;
} : T;
export type DeepRequired<T> = T extends (infer U)[] ? DeepRequired<U>[] : T extends Function ? T : T extends object ? {
    [K in keyof T]-?: DeepRequired<T[K]>;
} : T;
export type Mutable<T> = {
    -readonly [P in keyof T]: T[P];
};
export type RequireAtLeastOne<T, Keys extends keyof T = keyof T> = Pick<T, ExcludeStrict<keyof T, Keys>> & {
    [K in Keys]-?: Required<Pick<T, K>> & Partial<Pick<T, ExcludeStrict<Keys, K>>>;
}[Keys];
export type DeferInfer<T> = T & {
    [K in keyof T]: T[K];
};
export type PropsWithDefaults<Props extends object = {}, Defaults extends KnownKeys<Props> = never> = OmitStrict<Props, Defaults> & Required<Pick<Props, Defaults>>;
export type KebabToPascal<S extends string> = S extends `${infer T}-${infer U}` ? `${Capitalize<T>}${KebabToPascal<U>}` : Capitalize<S>;
export type KebabToCamel<S extends string> = string extends S ? string : S extends `-${infer T}` ? KebabToCamel<T> : S extends `${infer T}-${infer U}` ? `${T}${KebabToPascal<U>}` : S;
export type HeadingTag = 'h1' | 'h2' | 'h3' | 'h4' | 'h5' | 'h6';
export type ElementTag = keyof JSX.IntrinsicElements;
export type AttributesWithoutRef<T extends ElementTag> = OmitStrict<JSX.IntrinsicElements[T], 'ref' | 'dangerouslySetInnerHTML'>;
export type Attributes<T extends ElementTag> = AttributesWithoutRef<T> & (JSX.IntrinsicElements[T] extends DOMAttributes<infer E> ? {
    ref?: Ref<E> | undefined;
} : never);
export type RefElement<T extends {
    ref?: Ref<any> | undefined;
}> = T['ref'] extends Ref<infer E> | undefined ? E : never;
export type PrettyPrint<T> = T extends object ? {
    [K in keyof T]: T[K];
} : T;
//# sourceMappingURL=types.d.ts.map