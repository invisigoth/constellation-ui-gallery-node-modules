import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, createContext, useMemo, useContext, useCallback, useState, useEffect, useRef } from 'react';
import Progress from '../Progress';
import { useConsolidatedRef, useDirection, useFocusWithin } from '../../hooks';
import Flex from '../Flex';
import Actions from '../Actions';
import { cap } from '../../utils';
import Button from '../Button';
import { StyledStandardTreeParent, StyledToggleIcon, StyledToggleIconWrapper, StyledStandardTreeItemSubTree, StyledStandardTreeLeaf, StyledStandardTree, StyledNodeInteraction, StyledStandardTreeNode, StyledNodeActions, StyledLabelContent, StyledNodeIcon, StyledNodeText } from './StandardTree.styles';
import helpers from './helpers';
const StandardTreeContext = createContext({
    currentNodeId: undefined,
    lined: false,
    onNodeClick: () => { },
    onNodeToggle: () => { },
    firstNodeId: undefined,
    lastNodeId: undefined,
    focusedNodeId: undefined,
    changeFocusedNodeId: () => { },
    selectableParents: true
});
const NodeRenderer = ({ id, label, icon, depth, hasParentSibling, nodes, expanded = false, loading = false, subTree, actions, onClick, href }) => {
    const { currentNodeId, onNodeClick, onNodeToggle, lined, focusedNodeId, changeFocusedNodeId, firstNodeId, lastNodeId, selectableParents } = useContext(StandardTreeContext);
    const current = currentNodeId === id;
    const focusedEl = focusedNodeId === id;
    const firstNode = firstNodeId === id;
    const { start, end } = useDirection();
    const ariaCurrent = useMemo(() => {
        return href ? 'page' : 'true';
    }, [href]);
    const tabIndex = useMemo(() => {
        let index = -1;
        if (focusedNodeId) {
            index = focusedEl ? 0 : -1;
        }
        else if (currentNodeId && nodes && helpers.getNode(nodes, currentNodeId)) {
            index = current ? 0 : -1;
        }
        else {
            index = firstNode ? 0 : -1;
        }
        return index;
    }, [focusedNodeId, currentNodeId, current, focusedEl]);
    const handleParentClick = useCallback((e) => {
        onNodeClick?.(id, e);
        changeFocusedNodeId(id);
    }, [id, onNodeClick, changeFocusedNodeId]);
    const handleParentToggle = useCallback((e) => {
        e.preventDefault();
        e.stopPropagation();
        onNodeToggle?.(id, e);
        changeFocusedNodeId(id);
    }, [id, onNodeToggle, changeFocusedNodeId]);
    const onKeyDown = useCallback((e) => {
        if (['ArrowUp', 'ArrowDown', 'Home', 'End'].includes(e.key))
            e.preventDefault();
        if (e.key === 'Enter' && !href)
            e.preventDefault();
        switch (e.key) {
            case 'ArrowUp':
                changeFocusedNodeId(id, 'up');
                break;
            case 'ArrowDown':
                changeFocusedNodeId(id, 'down');
                break;
            case `Arrow${cap(end)}`:
                if (nodes) {
                    if (expanded) {
                        changeFocusedNodeId(id, 'right');
                    }
                    else {
                        onNodeToggle?.(id);
                    }
                }
                break;
            case `Arrow${cap(start)}`:
                if (expanded) {
                    onNodeToggle?.(id);
                }
                else {
                    changeFocusedNodeId(id, 'left');
                }
                break;
            case 'Enter':
                onClick?.(id, e);
                if (nodes) {
                    if (selectableParents) {
                        handleParentClick(e);
                    }
                    else {
                        handleParentToggle(e);
                    }
                }
                else {
                    onNodeClick?.(id, e);
                    changeFocusedNodeId(id);
                }
                break;
            case 'Home':
                if (firstNodeId)
                    changeFocusedNodeId(firstNodeId);
                break;
            case 'End':
                if (lastNodeId)
                    changeFocusedNodeId(lastNodeId);
                break;
            default:
        }
    }, [id, end, nodes, expanded, actions, firstNodeId, lastNodeId, changeFocusedNodeId]);
    const actionsJSX = useMemo(() => {
        // since Actions may render a frag of buttons and we need a wrapper for flex space-between.
        return actions ? (_jsx(StyledNodeActions, { children: _jsx(Actions, { items: actions.map(action => {
                    return {
                        ...action,
                        onClick: (actionId, e) => {
                            e.stopPropagation();
                            e.preventDefault();
                            action?.onClick?.(actionId, e);
                        },
                        onKeyDown: (e) => {
                            if (e.key === 'Enter')
                                e.stopPropagation();
                        }
                    };
                }), menuAt: 3, menuButtonProps: {
                    onClick: (e) => {
                        e.stopPropagation();
                        e.preventDefault();
                    },
                    onKeyDown: (e) => {
                        e.stopPropagation();
                        if (['ArrowUp', 'ArrowDown'].includes(e.key)) {
                            e.preventDefault();
                        }
                    }
                } }) })) : null;
    }, [actions]);
    const elRef = useRef(null);
    useEffect(() => {
        if (focusedEl) {
            elRef?.current?.focus();
        }
    }, [focusedEl]);
    const labelContent = useMemo(() => {
        const internal = (
        // Wrapping in a div for handling of flex space-between when there are node actions.
        _jsxs(Flex, { container: { alignItems: 'center', gap: 0.5 }, as: StyledLabelContent, children: [icon && _jsx(StyledNodeIcon, { name: icon }), _jsx(StyledNodeText, { children: label })] }));
        return !nodes && (onClick ?? onNodeClick) ? (_jsxs(Flex, { container: { alignItems: 'center', justify: 'between', gap: 2 }, as: StyledNodeInteraction, forwardedAs: href ? 'a' : 'div', role: 'treeitem', "aria-current": current ? ariaCurrent : undefined, tabIndex: tabIndex, onClick: (e) => {
                onClick?.(id, e);
                onNodeClick?.(id, e);
                changeFocusedNodeId(id);
            }, href: href, onKeyDown: onKeyDown, ref: elRef, children: [internal, actionsJSX] })) : (internal);
    }, [
        id,
        label,
        icon,
        nodes,
        actions,
        onClick,
        onNodeClick,
        current,
        focusedEl,
        tabIndex,
        changeFocusedNodeId,
        onKeyDown
    ]);
    return (_jsx(StyledStandardTreeNode, { id: id, style: {
            '--depth': depth,
            '--has-parent': depth ? 1 : 0,
            '--has-parent-sibling': hasParentSibling ? 1 : 0
        }, "aria-busy": loading, children: nodes ? (_jsxs(_Fragment, { children: [_jsxs(Flex, { container: { alignItems: 'center', justify: 'between', gap: 2 }, as: StyledStandardTreeParent, forwardedAs: href ? 'a' : 'div', role: 'treeitem', "aria-current": current ? ariaCurrent : undefined, tabIndex: tabIndex, variant: 'text', onClick: selectableParents ? handleParentClick : handleParentToggle, href: selectableParents ? href : undefined, "aria-expanded": expanded ? 'true' : 'false', "aria-owns": `${id}-subtree`, "aria-label": label, onKeyDown: onKeyDown, ref: elRef, children: [_jsxs(Flex, { container: { alignItems: 'center' }, as: 'span', children: [selectableParents ? (_jsx(Button, { variant: 'simple', tabIndex: -1, icon: true, compact: true, onClick: handleParentToggle, children: _jsx(StyledToggleIcon, { name: 'caret-right' }) })) : (_jsx(Flex, { as: StyledToggleIconWrapper, container: { justify: 'center', alignItems: 'center' }, children: _jsx(StyledToggleIcon, { name: 'caret-right' }) })), labelContent] }), actionsJSX] }), _jsxs(StyledStandardTreeItemSubTree, { lined: lined, id: `${id}-subtree`, children: [subTree, loading && _jsx(Progress, { variant: 'ring', placement: 'inline' })] })] })) : (_jsx(StyledStandardTreeLeaf, { children: labelContent })) }));
};
const StandardTreeWithNodes = forwardRef(function StandardTreeWithNodes({ nodes, currentNodeId, onNodeClick, onNodeToggle, lined = false, selectableParents = true, ...restProps }, ref) {
    const [focusedNodeId, setFocusedNodedId] = useState();
    const treeRef = useConsolidatedRef(ref);
    const lastNodeId = useMemo(() => {
        return helpers.getDeepestNode(nodes, nodes[nodes.length - 1].id)?.id;
    }, [nodes]);
    const changeFocusedNodeId = useCallback((id, type) => {
        switch (type) {
            case 'up': {
                const previousNode = helpers.getPreviousNode(nodes, id);
                if (previousNode)
                    setFocusedNodedId(previousNode.id);
                break;
            }
            case 'down': {
                const nextNode = helpers.getNextNode(nodes, id);
                if (nextNode)
                    setFocusedNodedId(nextNode.id);
                break;
            }
            case 'left': {
                const parentNode = helpers.getParentNode(nodes, id);
                if (parentNode)
                    setFocusedNodedId(parentNode.id);
                break;
            }
            case 'right': {
                const childNode = helpers.getFirstChildNode(nodes, id);
                if (childNode)
                    setFocusedNodedId(childNode.id);
                break;
            }
            default: {
                if (id !== focusedNodeId)
                    setFocusedNodedId(id);
                break;
            }
        }
    }, [nodes]);
    const onFocusChange = (focused) => {
        if (!focused)
            setFocusedNodedId('');
    };
    useFocusWithin([treeRef], onFocusChange);
    return (_jsx(StandardTreeContext.Provider, { value: useMemo(() => ({
            currentNodeId,
            focusedNodeId,
            lastNodeId,
            firstNodeId: nodes[0].id,
            changeFocusedNodeId,
            onNodeClick,
            onNodeToggle,
            lined,
            selectableParents
        }), [
            currentNodeId,
            onNodeClick,
            lined,
            focusedNodeId,
            lastNodeId,
            onNodeToggle,
            selectableParents
        ]), children: _jsx(StyledStandardTree, { ...restProps, ref: treeRef, nodes: nodes, nodeRenderer: NodeRenderer }) }));
});
const StandardTree = forwardRef(function StandardTree(props, ref) {
    return props.nodes.length > 0 ? _jsx(StandardTreeWithNodes, { ...props, ref: ref }) : null;
});
export default StandardTree;
//# sourceMappingURL=StandardTree.js.map