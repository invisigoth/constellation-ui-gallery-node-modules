import { jsx as _jsx } from "react/jsx-runtime";
import { forwardRef, useRef } from 'react';
import styled, { css } from 'styled-components';
import { defaultThemeProp } from '../../theme';
import Flex from '../Flex';
import Link from '../Link';
import Count from '../Badges/Count';
import { useAfterInitialEffect, useConsolidatedRef } from '../../hooks';
import Tab from './Tab';
export const StyledTabs = styled.div(({ type, theme }) => css `
    position: relative;
    overflow: ${type === 'horizontal' ? 'auto' : 'visible'};
    ${type === 'horizontal' &&
    css `
      border-bottom: 0.0625rem solid ${theme.base.palette['border-line']};
      height: max-content;
    `}

    &:has(:focus-visible) {
      box-shadow: ${type === 'vertical'
    ? theme.base.shadow['focus-group-inset']
    : theme.base.shadow['focus-group']};
    }
  `);
StyledTabs.defaultProps = defaultThemeProp;
/**
 * The tabs component will take a list of tab data objects and render out a list of tabs in either vertical or horizontal direction.
 * The tabs component handles which tab is active but will give you a callback function that allows you to make changes when a new tab is activated
 */
const Tabs = forwardRef(function Tabs({ tabs = [], type = 'horizontal', currentTabId, onTabClick, ...restProps }, ref) {
    const wrapperRef = useConsolidatedRef(ref);
    // Used to keep a reference for every tab in order to focus them with key presses
    const tabRefs = useRef([]);
    // Handles arrow keypresses for changing the focus
    const changeTabFocus = (event, index) => {
        if (tabRefs.current?.length) {
            const { key } = event;
            if (key === 'ArrowRight' || key === 'ArrowDown') {
                const nextIndex = index + 1 < tabs.length ? index + 1 : 0;
                const nextTab = tabRefs.current[nextIndex];
                if (!nextTab?.disabled) {
                    nextTab?.focus();
                }
                else {
                    changeTabFocus(event, nextIndex);
                }
            }
            else if (key === 'ArrowLeft' || key === 'ArrowUp') {
                const prevIndex = index === 0 ? tabs.length - 1 : index - 1;
                const prevTab = tabRefs.current[prevIndex];
                if (!prevTab?.disabled) {
                    prevTab?.focus();
                }
                else {
                    changeTabFocus(event, prevIndex);
                }
            }
        }
    };
    useAfterInitialEffect(() => {
        const event = new Event('cosmos-tab-changed', { bubbles: true, composed: true });
        wrapperRef.current?.dispatchEvent(event);
    }, [currentTabId]);
    return (_jsx(Flex, { ...restProps, container: {
            direction: type !== 'horizontal' ? 'column' : undefined
        }, item: { shrink: 0 }, as: StyledTabs, ref: wrapperRef, type: type, role: 'tablist', "aria-orientation": type, children: tabs.map((tab, i) => {
            const { href, name, count, id, disabled, errors } = tab;
            const selected = id === currentTabId;
            return (_jsx(Tab, { id: id, "aria-selected": selected, "aria-controls": `${id}-panel`, content: name, count: typeof count === 'number' && _jsx(Count, { children: count }), href: href, selected: selected, onClick: (event) => {
                    onTabClick?.(id, event);
                }, role: 'tab', ref: (el) => {
                    tabRefs.current[i] = el;
                }, onKeyDown: (e) => {
                    if (['ArrowRight', 'ArrowDown', 'ArrowLeft', 'ArrowUp'].includes(e.key)) {
                        e.preventDefault();
                        changeTabFocus(e, i);
                    }
                }, as: href ? Link : undefined, tabIndex: selected ? undefined : -1, "aria-label": name, type: type, disabled: disabled, errors: errors }, id));
        }) }));
});
export default Tabs;
//# sourceMappingURL=Tabs.js.map