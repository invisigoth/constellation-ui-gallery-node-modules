import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useState, useCallback, useEffect, useRef } from 'react';
import Icon, { registerIcon } from '../Icon';
import * as searchIcon from '../Icon/icons/search.icon';
import { useConsolidatedRef, useEscape, useI18n, useOuterEvent, useLiveLog, useUID } from '../../hooks';
import Flex from '../Flex';
import Popover from '../Popover';
import { sameWidth } from '../Popover/modifiers';
import Menu from '../Menu';
import Link from '../Link';
import Text from '../Text';
import { createStringMatcher } from '../../utils';
import VisuallyHiddenText from '../VisuallyHiddenText';
import { StyledCancelButton, StyledResultsPopover, StyledSearchButton, StyledSearchFilterText, StyledSearchInput, StyledSearchMenu, StyledSearchResultsContainer, StyledSearchTextInput, StyledMenuButton } from './SearchInput.styles';
registerIcon(searchIcon);
const SearchInput = forwardRef(function SearchInput(props, ref) {
    const t = useI18n();
    const { value = '', defaultFilter, filters, onFilterChange, searchResults, recentSearches, loading: loadingProp, advancedSearchLink, placeholder = t('search_placeholder_default'), onSearchChange, onSearchSubmit, searchInputAriaLabel, resultsPopover = true, ...restProps } = props;
    const instructionTextId = useUID();
    const { announcePolite } = useLiveLog();
    const inputRef = useConsolidatedRef(ref);
    const filterButtonRef = useRef(null);
    const filtersRef = useRef(null);
    const searchResultsRef = useRef(null);
    const [searchMenuOpen, setSearchMenuOpen] = useState(false);
    const [searchResultItems, setSearchResultItems] = useState(undefined);
    const [selectedFilter, setSelectedFilter] = useState(defaultFilter ?? '');
    const [downPressed, setDownPressed] = useState(false);
    const completeFilters = [t('all'), ...(filters ?? [])];
    const hasFilters = completeFilters.length > 1;
    const hasSearchResults = !!(searchResults && searchResults.length);
    const hasRecentSearches = !!(recentSearches && recentSearches.length);
    const showSearchMenu = (value || recentSearches?.length) && (searchResultItems || loadingProp);
    const useRecents = hasRecentSearches && !value;
    const loading = useRecents ? false : !!loadingProp;
    const [selectedFilterValue, setSelectedFilterValue] = useState('All');
    const searchMenuVisible = (resultsPopover && showSearchMenu && searchMenuOpen) || (!resultsPopover && showSearchMenu);
    useEscape(e => {
        if (searchMenuOpen) {
            e.preventDefault();
            e.stopPropagation();
            setSearchMenuOpen(false);
        }
    });
    const onKeyDown = useCallback((e) => {
        if (e.key === 'Enter' && !downPressed) {
            onSearchSubmit?.(value);
        }
        if (e.key === 'ArrowDown') {
            setDownPressed(true);
        }
    }, [onSearchSubmit, downPressed, value]);
    useOuterEvent('click', [searchResultsRef, inputRef, filtersRef], () => {
        setSearchMenuOpen(false);
    });
    useEffect(() => {
        setDownPressed(false);
    }, [value]);
    useEffect(() => {
        let items = [];
        if (hasSearchResults && value) {
            items = searchResults;
        }
        else if (useRecents) {
            items = recentSearches;
        }
        else if (!searchResults && (!recentSearches || recentSearches.length === 0)) {
            items = undefined;
        }
        setSearchResultItems(items);
    }, [searchResults, recentSearches, searchMenuOpen, hasSearchResults, hasRecentSearches, value]);
    // Announce results
    useEffect(() => {
        if (!searchMenuVisible || loading)
            return;
        const timeout = setTimeout(() => {
            announcePolite({
                message: t(useRecents ? 'recent_results_count' : 'results_count', [searchResultItems?.length ?? 0], {
                    count: searchResultItems?.length ?? 0
                }),
                type: 'status'
            });
        }, 1000);
        return () => {
            clearTimeout(timeout);
        };
    }, [loading, searchMenuVisible, searchResultItems]);
    const searchMenu = (_jsx(Menu, { as: StyledSearchMenu, header: recentSearches && !value ? (_jsx(Text, { variant: 'secondary', children: t('recent_searches') })) : undefined, mode: 'action', items: searchResultItems ?? [], loading: loading, footer: advancedSearchLink ? (_jsx(Link, { ...advancedSearchLink, children: t('advanced_search') })) : undefined, accent: hasSearchResults ? createStringMatcher(value, undefined, 'gi') : undefined, focusControlEl: (downPressed && inputRef.current) || undefined, "aria-label": searchInputAriaLabel || t('search') }));
    return (_jsxs(_Fragment, { children: [_jsxs(Flex, { container: true, as: StyledSearchInput, hasFilters: hasFilters, children: [hasFilters ? (_jsx(StyledMenuButton, { text: selectedFilterValue, variant: 'text', icon: 'search', "aria-label": selectedFilterValue === 'All'
                            ? t('select_search_filter')
                            : t('selected_search_filter', [selectedFilterValue]), menu: {
                            mode: 'single-select',
                            items: completeFilters.map(filter => ({
                                primary: filter,
                                id: filter,
                                selected: filter === t('all') ? selectedFilter === '' : selectedFilter === filter,
                                onClick: () => {
                                    setSelectedFilterValue(filter);
                                    setSelectedFilter(filter === t('all') ? '' : filter);
                                    onFilterChange?.(filter);
                                    inputRef.current?.focus();
                                }
                            }))
                        } })) : (_jsxs(Flex, { as: StyledSearchButton, ref: filterButtonRef, forwardedAs: hasFilters ? undefined : 'div', container: {
                            justify: 'center',
                            alignItems: 'center',
                            gap: selectedFilter ? 0.5 : undefined
                        }, decoupled: hasFilters, "aria-label": hasFilters ? t('select_search_filter') : undefined, children: [_jsx(Icon, { name: 'search' }), selectedFilter && _jsx(StyledSearchFilterText, { children: selectedFilter }), hasFilters && _jsx(Icon, { name: 'arrow-micro-down' })] })), _jsx(StyledSearchTextInput, { ref: inputRef, type: 'search', "aria-label": searchInputAriaLabel, placeholder: placeholder, ...restProps, "aria-describedby": searchMenuVisible ? instructionTextId : undefined, value: value, onChange: (e) => {
                            onSearchChange?.(e.target.value);
                            if (e.target.value)
                                setSearchMenuOpen(true);
                        }, onKeyDown: onKeyDown, onFocus: () => {
                            setSearchMenuOpen(true);
                        }, decoupled: hasFilters, onBlur: () => {
                            setDownPressed(false);
                            if (!advancedSearchLink) {
                                setSearchMenuOpen(false);
                            }
                        }, autoComplete: 'off' }), value && (_jsx(StyledCancelButton, { icon: true, onClick: () => {
                            onSearchChange?.('');
                            inputRef.current?.focus();
                        }, variant: 'simple', compact: true, label: t('clear'), children: _jsx(Icon, { name: 'times' }) }))] }), showSearchMenu && resultsPopover && (_jsx(Popover, { as: StyledResultsPopover, target: inputRef.current, show: searchMenuOpen, placement: 'bottom-start', modifiers: [sameWidth], ref: searchResultsRef, children: searchMenu })), !resultsPopover && showSearchMenu && (_jsx(StyledSearchResultsContainer, { children: searchMenu })), searchMenuVisible && (_jsx(VisuallyHiddenText, { id: instructionTextId, children: `${t('search_instructions')} ` }))] }));
});
export default SearchInput;
//# sourceMappingURL=SearchInput.js.map