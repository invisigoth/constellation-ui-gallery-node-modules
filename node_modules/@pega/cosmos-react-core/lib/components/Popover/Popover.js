import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useContext, useRef, useEffect, useMemo, useState, useLayoutEffect } from 'react';
import { createPortal } from 'react-dom';
import { usePopper } from 'react-popper';
import { useAfterInitialEffect, useConfiguration, useConsolidatedRef, useElement, useUID } from '../../hooks';
import { getRelativeOffset, popoverMap, windowIsAvailable } from '../../utils';
import { BackdropContext } from '../Backdrop/Backdrop';
import { PopoverManagerContext } from './PopoverContext';
import { StyledPopover, StyledPopoverArrow } from './Popover.styles';
import { placeAndContain } from './modifiers';
const delays = {
    none: 0,
    short: 500,
    long: 1000
};
const Popover = forwardRef(function Popover({ show = true, portal = true, target, placement = 'bottom', strategy = 'fixed', style, modifiers = [], arrow = false, groupId, showDelay = 'none', hideDelay = 'none', hideOnTargetHidden = false, children, onHide, ...restProps }, ref) {
    const { portalTarget: configurationPortal } = useConfiguration();
    const { el: backdropPortal } = useContext(BackdropContext);
    const { checkActive, setActive, popovers } = useContext(PopoverManagerContext);
    const [popperEl, setPopperEl] = useElement();
    const popperRef = useConsolidatedRef(ref, setPopperEl);
    const arrowRef = useRef(null);
    const forceUpdateRef = useRef();
    const initialOffset = useRef(null);
    const [showPopover, setShowPopover] = useState(show);
    const timeout = useRef();
    const uid = useUID();
    const pointerId = useUID();
    const resolvedTarget = target instanceof Element ? target : target?.contextElement;
    const portalTarget = typeof portal === 'boolean' ? backdropPortal ?? configurationPortal : portal;
    const memoedModifiers = useMemo(() => {
        const flipEnabled = !!modifiers
            .slice()
            .reverse()
            .find(modifier => modifier.name === 'flip' && modifier.enabled !== undefined)?.enabled;
        return [
            {
                name: 'computeStyles',
                options: {
                    gpuAcceleration: false
                }
            },
            {
                name: 'offset',
                options: {
                    offset: [0, arrow ? 5.5 : 2]
                }
            },
            { name: 'hide', enabled: hideOnTargetHidden },
            { name: 'arrow', enabled: arrow, options: { element: arrowRef.current } },
            {
                name: 'preventOverflow',
                options: {
                    tether: !modifiers.find(m => m.name === 'sameWidth'),
                    padding: 16
                }
            },
            {
                ...placeAndContain,
                enabled: !flipEnabled
            },
            ...modifiers
        ];
    }, [arrow, hideOnTargetHidden, modifiers]);
    const offset = useMemo(() => {
        const offsetModifier = [...memoedModifiers]
            .reverse()
            .find(m => m.name === 'offset' && m.enabled !== false);
        return Array.isArray(offsetModifier?.options?.offset)
            ? offsetModifier?.options?.offset[1] ?? 0
            : 0;
    }, [memoedModifiers]);
    const { styles, attributes, forceUpdate } = usePopper(target, popperEl, {
        placement,
        strategy,
        modifiers: memoedModifiers
    });
    if (forceUpdate)
        forceUpdateRef.current = forceUpdate;
    // Setter-less useState to avoid re-running these constructors on every render with useRef.
    const [ac] = useState(() => new AbortController());
    const [observedSet] = useState(() => new WeakSet());
    const [ro] = useState(() => new ResizeObserver(entries => {
        let updateQueued = false;
        for (const { target: resizeTarget } of entries) {
            // Ignore the first ResizeObserver event for each element since ResizeObserver always fires once when calling .observe().
            if (!observedSet.has(resizeTarget)) {
                observedSet.add(resizeTarget);
            }
            else if (!updateQueued) {
                updateQueued = true;
                if (!ac.signal.aborted) {
                    forceUpdateRef.current?.();
                }
            }
        }
    }));
    useEffect(() => {
        return () => {
            ac.abort();
            ro.disconnect();
        };
    }, []);
    useEffect(() => {
        if (!popperEl)
            return;
        ro.observe(popperEl);
        return () => {
            ro.unobserve(popperEl);
        };
    }, [popperEl]);
    useEffect(() => {
        if (!resolvedTarget)
            return;
        ro.observe(resolvedTarget);
        return () => {
            ro.unobserve(resolvedTarget);
        };
    }, [resolvedTarget]);
    useLayoutEffect(() => {
        if (resolvedTarget) {
            initialOffset.current = getRelativeOffset(resolvedTarget, document.documentElement);
        }
        else {
            initialOffset.current = null;
        }
    }, [resolvedTarget]);
    useEffect(() => {
        if (!showPopover || !resolvedTarget)
            return;
        let rafId;
        const checkCoords = () => {
            if (resolvedTarget && initialOffset.current) {
                const newOffset = getRelativeOffset(resolvedTarget, document.documentElement);
                if (initialOffset.current.x !== newOffset.x || initialOffset.current.y !== newOffset.y) {
                    initialOffset.current = newOffset;
                    forceUpdateRef.current?.();
                }
                else {
                    rafId = requestAnimationFrame(checkCoords);
                }
            }
        };
        rafId = requestAnimationFrame(checkCoords);
        return () => {
            cancelAnimationFrame(rafId);
        };
    }, [showPopover, resolvedTarget]);
    useEffect(() => {
        if (groupId && show)
            setActive(uid, groupId);
        if (windowIsAvailable) {
            if (timeout.current)
                clearTimeout(timeout.current);
            timeout.current = window.setTimeout(() => {
                setShowPopover(show);
            }, delays[show ? showDelay : hideDelay]);
        }
        else {
            setShowPopover(show);
        }
    }, [show]);
    useEffect(() => {
        return () => clearTimeout(timeout.current);
    }, []);
    useAfterInitialEffect(() => {
        if (!showPopover) {
            onHide?.();
        }
    }, [showPopover]);
    useEffect(() => {
        if (groupId && popovers[groupId] && popovers[groupId] !== uid) {
            setShowPopover(false);
        }
    }, [groupId ? popovers[groupId] : undefined]);
    useEffect(() => {
        if (!portal || !resolvedTarget)
            return;
        if (!popoverMap.has(resolvedTarget)) {
            popoverMap.set(resolvedTarget, new Set());
        }
        resolvedTarget.toggleAttribute('data-popover-target', true);
        popoverMap.get(resolvedTarget).add(pointerId);
        return () => {
            if (!popoverMap.has(resolvedTarget))
                return;
            popoverMap.get(resolvedTarget).delete(pointerId);
            if (popoverMap.get(resolvedTarget).size === 0) {
                popoverMap.delete(resolvedTarget);
                resolvedTarget.removeAttribute('data-popover-target');
            }
        };
    }, [portal, resolvedTarget, pointerId]);
    const content = (_jsxs(StyledPopover, { ...restProps, "data-popover-id": pointerId, portal: !!(portal && portalTarget), offset: offset, ref: popperRef, style: { ...style, ...styles.popper }, ...attributes.popper, children: [arrow && _jsx(StyledPopoverArrow, { ref: arrowRef, style: { ...styles.arrow } }), children] }));
    if (!target || !showPopover || (groupId && !checkActive(uid, groupId)))
        return null;
    return portal && portalTarget ? createPortal(content, portalTarget) : content;
});
export default Popover;
//# sourceMappingURL=Popover.js.map