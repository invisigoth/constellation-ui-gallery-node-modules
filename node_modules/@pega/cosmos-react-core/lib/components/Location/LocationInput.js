import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useCallback, useContext, useEffect, useState } from 'react';
import styled from 'styled-components';
import ComboBox from '../ComboBox';
import { useI18n, useTestIds } from '../../hooks';
import { createUID, withTestIds } from '../../utils';
import FormField from '../FormField';
import Flex from '../Flex';
import PoweredByGoogleImage from './PoweredByGoogleImage';
import CurrentLocationButton from './CurrentLocationButton';
import MapsContext from './MapsContext';
import { getPlaceById, getPlacePredictions, loadMapsAPI } from './utils';
import LocationView, { StyledLocationView } from './LocationView';
import { getLocationInputTestIds } from './Location.test-ids';
const StyledLocationMap = styled.div `
  ${StyledLocationView} {
    border-top-left-radius: 0;
    border-top-right-radius: 0;
  }
`;
const LocationInput = forwardRef(function LocationInput(props, ref) {
    const { testId, label, labelHidden, id = createUID(), location = '', value = '', info, status, required, readOnly, disabled, additionalInfo, onSelect, onError, onChange, bias, showMap, defaultToCurrentLocation, centerMapOnChange, height, zoomLevel, onClick, onBlur, ...restProps } = props;
    const testIds = useTestIds(testId, getLocationInputTestIds);
    const { name, ...providerOpts } = useContext(MapsContext);
    const t = useI18n();
    const [placePredictionMenu, setPlacePredictionMenu] = useState({ items: [] });
    const [filterValue, setFilterValue] = useState('');
    useEffect(() => {
        const mapApiPromise = loadMapsAPI(name, providerOpts).catch(error => onError?.(error));
        if (filterValue) {
            mapApiPromise
                .then(() => getPlacePredictions(filterValue, bias))
                .then(({ placePredictions, token }) => {
                setPlacePredictionMenu({
                    items: placePredictions.map(item => ({
                        id: item.place_id,
                        primary: item.structured_formatting.main_text,
                        secondary: [item.structured_formatting.secondary_text]
                    })),
                    emptyText: t('location_not_found_text'),
                    onItemClick: itemId => getPlaceById(itemId, token).then(arg => {
                        setFilterValue('');
                        onSelect?.(arg);
                    })
                });
            })
                .catch(error => {
                setPlacePredictionMenu({ items: [] });
                onError?.(error);
            });
        }
        else {
            setPlacePredictionMenu({ items: [] });
        }
    }, [filterValue, bias, onError, onSelect]);
    const onInputChange = useCallback((e) => {
        setFilterValue(e.target.value);
        onChange?.(e.target.value);
    }, [onChange]);
    const onMapClick = useCallback((placeInfo) => {
        onSelect?.(placeInfo);
        onClick?.(placeInfo);
    }, [onSelect, onClick]);
    const Comp = (_jsxs(_Fragment, { children: [_jsx(ComboBox, { "data-testid": testIds.control, placeholder: t('location_input_placeholder'), menu: filterValue
                    ? {
                        ...placePredictionMenu,
                        items: placePredictionMenu.items.concat({
                            id: createUID(),
                            primary: t('use_input_value', [filterValue])
                        }),
                        mode: 'action',
                        footer: !showMap && (_jsx(Flex, { container: { justify: 'end' }, children: _jsx(PoweredByGoogleImage, {}) }))
                    }
                    : undefined, actions: !disabled &&
                    !readOnly && (_jsx(CurrentLocationButton, { ...{ defaultToCurrentLocation, onError, onChange: onSelect } })), onChange: onInputChange, onBlur: () => {
                    setFilterValue('');
                    onBlur?.(value);
                }, value: value, ...{
                    required,
                    disabled,
                    readOnly,
                    status,
                    ...restProps
                } }), showMap && (_jsx(StyledLocationMap, { children: _jsx(LocationView, { ...{
                        location,
                        onClick: onMapClick,
                        onError,
                        bias,
                        disabled,
                        readOnly,
                        centerMapOnChange,
                        height,
                        zoomLevel
                    } }) }))] }));
    return label ? (_jsx(FormField, { ...{
            testId: testIds,
            label,
            labelHidden,
            id,
            info,
            status,
            ref,
            required,
            disabled,
            additionalInfo
        }, children: Comp })) : (Comp);
});
export default withTestIds(LocationInput, getLocationInputTestIds);
//# sourceMappingURL=LocationInput.js.map