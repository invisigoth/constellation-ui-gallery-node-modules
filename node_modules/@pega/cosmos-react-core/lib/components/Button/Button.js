import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useRef, useEffect, forwardRef } from 'react';
import styled, { css } from 'styled-components';
import { meetsContrastGuidelines, mix, readableColor } from 'polished';
import { defaultThemeProp } from '../../theme';
import { tryCatch } from '../../utils';
import { getHoverColors, omitProps, readableHue } from '../../styles';
import { useElement, useConsolidatedRef } from '../../hooks';
import Tooltip from '../Tooltip';
import Progress, { StyledProgressRing } from '../Progress';
import { StyledBackdrop } from '../Backdrop';
import { StyledIcon } from '../Icon';
import { StyledPopover } from '../Popover';
const baseStyles = (theme) => {
    const { base: { spacing, animation: { speed, timing: { ease } }, 'disabled-opacity': disabledOpacity }, components: { button: { 'focus-shadow': focusShadow } } } = theme;
    return css `
    outline: none;
    text-decoration: none;
    transition-property: background-color, color, box-shadow;
    transition-duration: calc(0.5 * ${speed});
    transition-timing-function: ${ease};
    cursor: pointer;

    & + & {
      margin-inline-start: ${spacing};
    }

    /* Not able to combine with selector above. Stylis bug? */
    & + ${StyledPopover} + & {
      margin-inline-start: ${spacing};
    }

    &:disabled,
    &[disabled] {
      opacity: ${disabledOpacity};
      cursor: not-allowed;
      pointer-events: none;
    }

    &:enabled:focus,
    &:not([disabled]):focus {
      box-shadow: ${focusShadow};
    }
  `;
};
export const StyledButton = styled.button.withConfig(omitProps('loading'))(({ variant, icon, loading, compact, theme }) => {
    const { base: { spacing, 'border-radius': baseBorderRadius, palette: { 'primary-background': backgroundColor }, 'hit-area': { 'mouse-min': hitAreaMouse, 'finger-min': hitAreaFinger, 'compact-min': hitAreaCompact }, animation: { speed } }, components: { button: { color, 'secondary-color': secondaryColor, padding, 'border-radius': borderRadius, 'border-width': borderWidth, touch: { padding: touchPadding } } } } = theme;
    const contrastColor = tryCatch(() => readableColor(color));
    // Base
    const base = baseStyles(theme);
    // Non-text base
    const nonTextual = css `
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-height: ${hitAreaMouse};
      min-width: ${hitAreaMouse};
      line-height: 1;
      border: ${borderWidth} solid transparent;
      border-radius: calc(${baseBorderRadius} * ${borderRadius});
      -webkit-user-select: none;
      user-select: none;

      ${!icon &&
        css `
        padding: ${padding};
      `}

      ${icon &&
        css `
        border-radius: calc(${baseBorderRadius} * ${borderRadius});

        > svg {
          display: block;
        }
      `}

      ${compact &&
        css `
        min-height: ${hitAreaCompact};
        min-width: ${hitAreaCompact};
      `}

      @media (pointer: coarse) {
        border-radius: calc(${baseBorderRadius} * ${borderRadius});

        ${!compact &&
        css `
          min-height: ${hitAreaFinger};
          min-width: ${hitAreaFinger};
        `}

        ${!icon &&
        css `
          padding: ${touchPadding};
        `}
      }
    `;
    // Primary
    const hoverColors = getHoverColors(color);
    const hoverPrimaryColor = hoverColors.background;
    const hoverContrastColor = hoverColors.foreground;
    const primary = css `
      --button-background-color: ${color};
      color: ${contrastColor};
      background-color: ${color};

      @media (hover: hover) {
        &:hover {
          background-color: ${hoverPrimaryColor};
          color: ${hoverContrastColor};
          text-decoration: none;
        }
      }
    `;
    // Secondary
    const backgroundUsable = meetsContrastGuidelines(color, secondaryColor).AA;
    const usableColor = backgroundUsable ? color : readableHue(color, secondaryColor);
    const secondaryHoverBackgroundColor = tryCatch(() => mix(0.85, secondaryColor, usableColor));
    const secondaryHoverForegroundColor = readableHue(usableColor, secondaryHoverBackgroundColor ?? 'transparent');
    const secondary = css `
      --button-background-color: ${secondaryColor};
      color: ${usableColor};
      background-color: ${secondaryColor};
      border-color: ${usableColor};

      @media (hover: hover) {
        &:hover {
          color: ${secondaryHoverForegroundColor};
          background-color: ${secondaryHoverBackgroundColor};
          text-decoration: none;
          border-color: ${secondaryHoverForegroundColor};
        }
      }
    `;
    // Simple
    const simple = css `
      --button-background-color: ${icon ? 'transparent' : backgroundColor};
      color: ${icon ? 'currentColor' : usableColor};
      background-color: ${icon ? 'transparent' : backgroundColor};

      @media (hover: hover) {
        &:hover {
          ${icon &&
        css `
            ::before {
              content: '';
              position: absolute;
              top: calc(${borderWidth} * -1);
              bottom: calc(${borderWidth} * -1);
              left: calc(${borderWidth} * -1);
              right: calc(${borderWidth} * -1);
              border-radius: inherit;
              background-color: currentColor;
              opacity: 0.15;
            }
          `}

          ${!icon &&
        css `
            background-color: ${secondaryHoverBackgroundColor};
            color: ${secondaryHoverForegroundColor};
            border-color: ${secondaryHoverForegroundColor};
            text-decoration: none;
          `}
        }
      }
    `;
    return css `
      ${base}
      ${nonTextual}
      ${variant === 'primary' && primary}
      ${variant === 'secondary' && secondary}
      ${variant === 'simple' && simple}

      ${loading &&
        css `
        ${StyledBackdrop} {
          background-color: var(--button-background-color);
          border-radius: inherit;
        }

        ${StyledProgressRing} {
          width: 1em;
          height: 1em;

          ${!icon &&
            css `
            margin-inline-end: calc(${spacing} / 2);
          `}

          circle:nth-child(2) {
            animation-duration: calc(${speed} * 2);
          }
        }
      `}
    `;
});
StyledButton.defaultProps = defaultThemeProp;
export const StyledButtonLink = styled.a.withConfig(omitProps('loading'))(({ theme, variant }) => {
    const { base: { palette: { 'foreground-color': textColor } }, components: { link: { color: linkColor } } } = theme;
    const base = baseStyles(theme);
    const textual = css `
      background-color: transparent;
      display: inline;
      text-align: start;
      border: none;

      @media (hover: hover) {
        &:hover {
          text-decoration: underline;
        }
      }

      > ${StyledIcon} {
        vertical-align: bottom;
      }
    `;
    const link = css `
      color: ${linkColor};
    `;
    const text = css `
      color: ${textColor};
    `;
    return css `
      ${base}
      ${textual}
      ${variant === 'link' && link}
      ${variant === 'text' && text}
    `;
});
StyledButtonLink.defaultProps = defaultThemeProp;
const Button = forwardRef(function Button({ variant = 'secondary', type = 'button', disabled = false, icon = false, compact = false, href, as, forwardedAs, label, 'aria-label': ariaLabel, loading = false, children, ...restProps }, ref) {
    const [buttonEl, setButtonEl] = useElement();
    const mouseDownEvent = useRef();
    const buttonRef = useConsolidatedRef(ref, setButtonEl);
    const isTextual = ['link', 'text'].includes(variant);
    const showProgress = loading && !isTextual;
    const StyledComp = isTextual ? StyledButtonLink : StyledButton;
    useEffect(() => {
        return () => {
            mouseDownEvent.current = undefined;
        };
    }, []);
    return (_jsxs(_Fragment, { children: [_jsxs(StyledComp, { ...restProps, ref: buttonRef, as: as || (href ? 'a' : 'button'), forwardedAs: forwardedAs || (href ? 'a' : 'button'), variant: variant, icon: icon, compact: compact, type: href ? undefined : type, href: href, disabled: disabled && !href, loading: showProgress, "aria-label": ariaLabel || label, onMouseDown: (e) => {
                    restProps.onMouseDown?.(e);
                    e.persist();
                    mouseDownEvent.current = e;
                }, onMouseUp: (e) => {
                    const shouldFocus = mouseDownEvent.current && !mouseDownEvent.current.defaultPrevented;
                    mouseDownEvent.current = undefined;
                    if (shouldFocus && buttonRef.current !== document.activeElement) {
                        buttonRef.current?.focus();
                    }
                    return restProps.onMouseUp?.(e);
                }, children: [showProgress && _jsx(Progress, { variant: 'ring', placement: 'inline' }), !icon || !showProgress ? children : null] }), buttonEl && label && (_jsx(Tooltip, { target: buttonEl, showDelay: 'none', hideDelay: 'none', describeTarget: false, children: label }))] }));
});
export default Button;
//# sourceMappingURL=Button.js.map