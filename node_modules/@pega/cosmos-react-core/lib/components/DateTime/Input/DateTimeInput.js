import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { forwardRef, useEffect, useImperativeHandle, useRef } from 'react';
import styled, { css } from 'styled-components';
import { StyledFormControl } from '../../FormControl';
import FormField from '../../FormField';
import { useConfiguration, useConsolidatedRef, useFocusWithin, useI18n, useOuterEvent, useTestIds } from '../../../hooks';
import Select, { Option } from '../../Select';
import Flex from '../../Flex';
import Button from '../../Button';
import Icon, { registerIcon } from '../../Icon';
import * as calendarIcon from '../../Icon/icons/calendar.icon';
import DatePicker from '../Picker/DatePicker';
import { hasProp, cap, withTestIds } from '../../../utils';
import Dialog from '../../Dialog/Dialog';
import { getDateTimeInputTestIds } from '../DateTime.test-ids';
import { getAdjustedUTCDateTime } from '../utils';
import StyledDateTime, { StyledClearNowButtonsContainer, StyledDialogContent, StyledInputContainer } from './DateTime.styles';
import { generatePickerButtonAriaLabel, getDateFormat, getTimeOptions, is12HClockFormat, parsePastedTextToDate, parseToDate, validateDate, validateTime } from './utils';
import useAutoFocusNextInput from './useAutoFocusNextInput';
import PartInput from './PartInput';
import usePickerButton from './usePickerButton';
registerIcon(calendarIcon);
export const StyledDateTimeInput = styled(StyledDateTime)(() => {
    return css `
    padding-inline-end: 0;
    min-width: 0;
  `;
});
const StyledDateTimeFieldset = styled.fieldset `
  min-width: 0;
`;
function getMeridiem(hour) {
    return hour >= 12 ? 'PM' : 'AM';
}
const convertTo12h = (hour) => {
    let converted = hour;
    if (hour > 12)
        converted = hour - 12;
    else if (hour === 0)
        converted = 12;
    return converted;
};
const convertTo24h = (hour, meridiem) => {
    let converted = hour;
    if (meridiem === 'PM' && hour < 12)
        converted = hour + 12;
    else if (meridiem === 'AM' && hour === 12)
        converted = 0;
    return converted;
};
const validateDateTime = (year, month, day, hour, minute, second, is12h) => {
    return validateDate(year, month, day) && validateTime(hour, minute, second, is12h);
};
const convertToCallbackParameter = (date, parts) => {
    const withSeconds = hasProp(parts, 'second');
    const { year, month: monthIndex, day, hour, minute, second = date.getUTCSeconds().toString(), dayPeriod: meridiem } = parts;
    const toValidate = withSeconds
        ? [year, monthIndex, day, hour, minute, second]
        : [year, monthIndex, day, hour, minute];
    if (toValidate.every(Boolean)) {
        const is12h = meridiem !== undefined;
        if (!validateDateTime(Number(year), Number(monthIndex) + 1, Number(day), Number(hour), Number(minute), Number(second), is12h)) {
            return {
                valueAsISOString: '',
                valueAsTimestamp: NaN,
                state: 'invalid'
            };
        }
        const resultDate = new Date(date);
        resultDate.setUTCFullYear(Number(year), Number(monthIndex), Number(day));
        resultDate.setUTCHours(is12h ? convertTo24h(Number(hour), meridiem) : Number(hour), Number(minute), Number(second));
        return {
            valueAsISOString: resultDate.toISOString(),
            valueAsTimestamp: resultDate.getTime()
        };
    }
    if (toValidate.every(p => !p)) {
        return {
            valueAsISOString: undefined,
            valueAsTimestamp: undefined
        };
    }
    return {
        valueAsISOString: '',
        valueAsTimestamp: NaN,
        state: 'incomplete'
    };
};
function dateOptions() {
    return {
        year: 'numeric',
        month: 'numeric',
        day: 'numeric'
    };
}
const DateTimeInput = forwardRef(function DateTimeInput(props, ref) {
    const { locale } = useConfiguration();
    const { testId, value, min, max, id, label, labelHidden, withSeconds = false, clockFormat, info = `${getDateFormat(locale).join('')} ${getDateFormat(locale, getTimeOptions(withSeconds), true).join('')}`, status, required, readOnly, disabled, showWeekNumber, pickerInterval = 30, onChange, onFocus, onBlur, onResolveSuggestion, additionalInfo, autoFocus, handle, ...restProps } = props;
    const testIds = useTestIds(testId, getDateTimeInputTestIds);
    const t = useI18n();
    const containerRef = useConsolidatedRef(ref);
    const dateTime = value !== undefined ? parseToDate(value) : undefined;
    const is12h = clockFormat ? clockFormat === 12 : is12HClockFormat(locale);
    const [yearInputRef, monthInputRef, dayInputRef, hourInputRef, minuteInputRef, secondInputRef, meridiemSelectRef] = [
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null),
        useRef(null)
    ];
    useAutoFocusNextInput([
        yearInputRef,
        monthInputRef,
        dayInputRef,
        hourInputRef,
        minuteInputRef,
        secondInputRef
    ]);
    const setMeridiem = (meridiem) => {
        if (meridiemSelectRef.current) {
            meridiemSelectRef.current.value = meridiem;
        }
    };
    useEffect(() => {
        if (is12h && meridiemSelectRef.current && dateTime?.getUTCHours()) {
            meridiemSelectRef.current.value = getMeridiem(dateTime?.getUTCHours());
        }
    }, [is12h, dateTime?.getUTCHours()]);
    const pickDateParts = () => {
        return {
            day: dayInputRef.current?.value || undefined,
            month: monthInputRef.current?.value
                ? (Number(monthInputRef.current.value) - 1).toString()
                : undefined,
            year: yearInputRef.current?.value || undefined
        };
    };
    const pickTimeParts = () => {
        const parts = {
            hour: hourInputRef.current?.value || undefined,
            minute: minuteInputRef.current?.value || undefined
        };
        if (withSeconds)
            parts.second = secondInputRef.current?.value;
        if (is12h)
            parts.dayPeriod = meridiemSelectRef.current?.value;
        return parts;
    };
    const pickParts = () => {
        return { ...pickDateParts(), ...pickTimeParts() };
    };
    const currentlySelectedDate = () => {
        const parts = pickDateParts();
        if (Object.values(parts).every(Boolean)) {
            const year = Number(parts.year);
            const month = Number(parts.month);
            const day = Number(parts.day);
            return validateDate(year, month + 1, day)
                ? new Date(Date.UTC(year, month, day))
                : undefined;
        }
    };
    const currentlySelectedTime = () => {
        const parts = pickParts();
        if (Object.values(parts).every(Boolean)) {
            const hour = Number(parts.hour);
            const minute = Number(parts.minute);
            const second = parts.second ? Number(parts.second) : 0;
            const current = dateTime ?? getAdjustedUTCDateTime();
            return validateTime(hour, minute, second, is12h)
                ? new Date(current.setUTCHours(is12h ? convertTo24h(hour, parts.dayPeriod) : hour, minute, second))
                : undefined;
        }
    };
    const currentlySelectedDateTime = () => {
        const selectedDate = currentlySelectedDate();
        const selectedTime = currentlySelectedTime();
        return selectedDate && selectedTime
            ? new Date(selectedDate.setUTCHours(selectedTime.getUTCHours(), selectedTime.getUTCMinutes(), selectedTime.getUTCSeconds()))
            : undefined;
    };
    const setDefaultTimeIfEmpty = () => {
        // set value to midnight if time empty, skip if date not fully set
        if (Object.values(pickDateParts()).every(Boolean) &&
            Object.values(pickTimeParts()).every(p => !p)) {
            if (hourInputRef.current)
                hourInputRef.current.value = is12h ? '12' : '00';
            if (minuteInputRef.current)
                minuteInputRef.current.value = '00';
            if (withSeconds && secondInputRef.current)
                secondInputRef.current.value = '00';
            if (is12h && meridiemSelectRef.current) {
                meridiemSelectRef.current.value = 'AM';
                setMeridiem('AM');
            }
        }
    };
    const [open, setOpen, , setPopoverRef, buttonEl, setButtonEl] = usePickerButton(setDefaultTimeIfEmpty);
    const onInputChange = () => {
        onChange?.(convertToCallbackParameter(dateTime ? new Date(dateTime) : new Date(), pickParts()));
        buttonEl?.setAttribute('aria-label', generatePickerButtonAriaLabel(currentlySelectedDateTime(), 'datetime', locale, t, open));
    };
    const setInputValue = (newValue) => {
        dayInputRef.current.value = newValue?.getUTCDate().toString().padStart(2, '0') ?? '';
        monthInputRef.current.value =
            (newValue && (newValue.getUTCMonth() + 1).toString().padStart(2, '0')) || '';
        yearInputRef.current.value = newValue?.getUTCFullYear().toString() ?? '';
        if (newValue) {
            const hours = newValue.getUTCHours();
            hourInputRef.current.value = (is12h ? convertTo12h(hours) : hours)
                .toString()
                .padStart(2, '0');
        }
        else {
            hourInputRef.current.value = '';
        }
        minuteInputRef.current.value = newValue?.getUTCMinutes().toString().padStart(2, '0') ?? '';
        if (withSeconds) {
            secondInputRef.current.value = newValue?.getUTCSeconds().toString().padStart(2, '0') ?? '';
        }
        if (meridiemSelectRef.current) {
            meridiemSelectRef.current.value = newValue ? getMeridiem(newValue.getUTCHours()) : 'AM';
        }
        setMeridiem(newValue ? getMeridiem(newValue.getUTCHours()) : 'AM');
    };
    const onPaste = (e) => {
        const text = e.clipboardData.getData('text');
        const date = parsePastedTextToDate(text, locale, dateTime || new Date());
        if (date) {
            e.preventDefault();
            setInputValue(date);
            onInputChange();
        }
    };
    const inputContainerRef = useRef(null);
    const onFocusChange = (focused) => {
        const callbackParam = convertToCallbackParameter(dateTime ? new Date(dateTime) : new Date(), pickParts());
        if (onFocus && focused)
            onFocus(callbackParam);
        if (!focused) {
            if (inputContainerRef.current)
                inputContainerRef.current.scrollTop = 0;
            onBlur?.(callbackParam);
        }
    };
    // autoclose picker on focusing out
    useOuterEvent('focusin', [containerRef], e => {
        if (containerRef.current?.contains(e.relatedTarget))
            setOpen(false);
    });
    useImperativeHandle(handle, () => ({
        clear: () => {
            if (dayInputRef.current)
                dayInputRef.current.value = '';
            if (monthInputRef.current)
                monthInputRef.current.value = '';
            if (yearInputRef.current)
                yearInputRef.current.value = '';
            if (hourInputRef.current)
                hourInputRef.current.value = '';
            if (minuteInputRef.current)
                minuteInputRef.current.value = '';
            if (secondInputRef.current)
                secondInputRef.current.value = '';
            if (meridiemSelectRef.current)
                meridiemSelectRef.current.value = '';
            onInputChange();
        }
    }), [onInputChange]);
    const displayNames = new Intl.DisplayNames(locale, { style: 'long', type: 'dateTimeField' });
    const DayInput = (_jsx(PartInput, { "data-testid": testIds.controlDay, placeholder: t('day_placeholder'), "aria-label": displayNames.of('day'), value: dateTime?.getUTCDate(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: 1, max: 31, ref: dayInputRef }, 'day'));
    const MonthInput = (_jsx(PartInput, { "data-testid": testIds.controlMonth, placeholder: t('month_placeholder'), "aria-label": displayNames.of('month'), value: dateTime ? dateTime.getUTCMonth() + 1 : undefined, onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: 1, max: 12, ref: monthInputRef }, 'month'));
    const YearInput = (_jsx(PartInput, { "data-testid": testIds.controlYear, placeholder: t('year_placeholder'), "aria-label": displayNames.of('year'), value: dateTime?.getUTCFullYear(), onChange: onInputChange, size: 4, maxLength: 4, padWithZeros: false, readOnly: readOnly, min: 1, ref: yearInputRef }, 'year'));
    const hour = dateTime && is12h ? convertTo12h(dateTime.getUTCHours()) : dateTime?.getUTCHours();
    const HourInput = (_jsx(PartInput, { "data-testid": testIds.controlHour, placeholder: t('hour_placeholder'), "aria-label": displayNames.of('hour'), value: hour, onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, min: is12h ? 1 : 0, max: is12h ? 12 : 23, ref: hourInputRef }, 'hour'));
    const MinuteInput = (_jsx(PartInput, { "data-testid": testIds.controlMinute, placeholder: t('minute_placeholder'), "aria-label": displayNames.of('minute'), value: dateTime?.getUTCMinutes(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, max: 59, ref: minuteInputRef }, 'minute'));
    const SecondInput = (_jsx(PartInput, { "data-testid": testIds.controlSecond, placeholder: t('second_placeholder'), "aria-label": displayNames.of('second'), value: dateTime?.getUTCSeconds(), onChange: onInputChange, size: 2, maxLength: 2, readOnly: readOnly, max: 59, ref: secondInputRef }, 'second'));
    const Period = (_jsxs(Select, { "data-testid": testIds.controlPeriod, ref: meridiemSelectRef, "aria-label": displayNames.of('dayPeriod'), required: required, disabled: disabled, onChange: () => {
            if (Object.values(pickParts()).every(Boolean))
                onInputChange();
        }, readOnly: readOnly, children: [_jsx(Option, { value: 'AM', children: t('meridiem_value_am') }), _jsx(Option, { value: 'PM', children: t('meridiem_value_pm') })] }, 'period'));
    const orderedRefs = [];
    const dateInputs = getDateFormat(locale, dateOptions()).map(part => {
        switch (part) {
            case 'DD':
                orderedRefs.push(dayInputRef);
                return DayInput;
            case 'MM':
                orderedRefs.push(monthInputRef);
                return MonthInput;
            case 'YYYY':
                orderedRefs.push(yearInputRef);
                return YearInput;
            default:
                return part;
        }
    });
    const timeInputs = getDateFormat(locale, getTimeOptions(withSeconds, is12h)).map(part => {
        switch (part) {
            case 'hh':
                orderedRefs.push(hourInputRef);
                return HourInput;
            case 'mm':
                orderedRefs.push(minuteInputRef);
                return MinuteInput;
            case 'ss':
                orderedRefs.push(secondInputRef);
                return SecondInput;
            case 'AM':
            case 'PM':
                return Period;
            default:
                return part;
        }
    });
    useEffect(() => {
        if (autoFocus)
            orderedRefs[0].current?.focus();
    }, [autoFocus]);
    useFocusWithin([containerRef], onFocusChange);
    const Picker = (_jsxs(_Fragment, { children: [_jsx(Button, { "data-testid": testIds.openClosePicker, variant: 'simple', icon: true, ref: setButtonEl, onClick: () => {
                    setOpen(cur => !cur);
                }, "aria-label": generatePickerButtonAriaLabel(currentlySelectedDateTime(), 'datetime', locale, t, open), readOnly: readOnly, disabled: disabled, children: _jsx(Icon, { name: 'calendar' }) }), open && buttonEl && (_jsx(Dialog, { ref: setPopoverRef, target: buttonEl, placement: 'bottom-end', ariaLabel: t('choose_date_and_time'), children: _jsxs(Flex, { container: { direction: 'column' }, as: StyledDialogContent, children: [_jsx(DatePicker, { testId: testIds.root, mode: 'datetime', selected: currentlySelectedDateTime(), onChange: selected => {
                                setInputValue(selected);
                                onInputChange();
                            }, min: min, max: max, showWeekNumber: showWeekNumber, pickerInterval: pickerInterval, withSeconds: withSeconds, clockFormat: clockFormat }), _jsxs(Flex, { as: StyledClearNowButtonsContainer, container: { justify: 'between' }, children: [_jsx(Button, { "data-testid": testIds.clearCurrentDateAndTime, "aria-label": t('clear_current_date_and_time'), onClick: () => {
                                        setInputValue(undefined);
                                        setOpen(false);
                                        setTimeout(() => buttonEl?.focus());
                                        onInputChange();
                                    }, children: t('clear') }), _jsx(Button, { "data-testid": testIds.setCurrentDateAndTime, "aria-label": t('set_current_date_and_time_a11y'), onClick: () => {
                                        setInputValue(getAdjustedUTCDateTime());
                                        setOpen(false);
                                        setTimeout(() => buttonEl?.focus());
                                        onInputChange();
                                    }, children: cap(new Intl.RelativeTimeFormat(locale, { numeric: 'auto' }).format(0, 'second')) })] })] }) }))] }));
    const Comp = (_jsxs(Flex, { "data-testid": testIds.root, as: StyledDateTimeInput, forwardedAs: StyledFormControl, hasSuggestion: status === 'pending' && !!onResolveSuggestion, container: { alignItems: 'center', wrap: 'nowrap' }, status: status, readOnly: readOnly, disabled: disabled, ref: containerRef, onClick: (e) => {
            if (e.target === containerRef.current)
                orderedRefs[0].current?.focus();
        }, ...restProps, children: [_jsxs(Flex, { ref: inputContainerRef, as: StyledInputContainer, container: { alignItems: 'center', wrap: 'wrap' }, onPaste: onPaste, children: [dateInputs, timeInputs] }), !readOnly && Picker] }));
    useAutoFocusNextInput(orderedRefs);
    return label ? (_jsx(FormField, { as: StyledDateTimeFieldset, labelAs: 'legend', "aria-labelledby": id, ref: ref, ...{
            testId: testIds,
            label,
            labelHidden,
            id,
            info,
            status,
            required,
            disabled,
            onResolveSuggestion,
            additionalInfo
        }, children: Comp })) : (Comp);
});
export default withTestIds(DateTimeInput, getDateTimeInputTestIds);
//# sourceMappingURL=DateTimeInput.js.map