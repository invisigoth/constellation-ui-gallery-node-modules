import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useRef, forwardRef, useCallback, useReducer, useImperativeHandle } from 'react';
import styled, { css } from 'styled-components';
import { useConsolidatedRef, useFocusWithin, useI18n, useTestIds } from '../../../hooks';
import { defaultThemeProp } from '../../../theme';
import Flex from '../../Flex';
import FormField, { StyledFormField } from '../../FormField/FormField';
import DateRangePicker from '../Picker/DateRangePicker';
import { StyledRangeInputContainer } from '../../Input/Input.styles';
import { getDateRangeInputTestIds } from '../DateTime.test-ids';
import { withTestIds } from '../../../utils';
import DateInput from './DateInput';
import { parseToDate } from './utils';
import StyledDateInput from './DateTime.styles';
const StyledDateRangeInput = styled.div(props => {
    const { theme: { components: { input } } } = props;
    return css `
    border: 0;
    min-width: min-content;

    ${StyledFormField} {
      &:last-child > ${StyledDateInput} {
        margin-inline-start: -${input['border-width']};
      }
      & legend {
        align-self: center;
      }
      &:focus,
      &:hover,
      &:focus-within {
        z-index: 2;
      }
    }
  `;
});
StyledDateRangeInput.defaultProps = defaultThemeProp;
const reducer = (prevState, { type, value }) => {
    switch (type) {
        case 'start': {
            return { ...prevState, start: value };
        }
        case 'end': {
            return { ...prevState, end: value };
        }
        default:
            return prevState;
    }
};
const convertToCallbackParameter = (v) => {
    return {
        valueAsISOString: v === undefined || Number.isNaN(v) ? undefined : new Date(v).toISOString(),
        valueAsTimestamp: v
    };
};
const prepareValue = (v, type) => {
    if (v === undefined || Number.isNaN(v)) {
        return v;
    }
    return type === 'start'
        ? new Date(v).setUTCHours(0, 0, 0, 0)
        : new Date(v).setUTCHours(23, 59, 59, 999);
};
const getSelected = (first, second) => {
    const selected = first ?? second;
    return selected ? parseToDate(selected) : undefined;
};
const parseValueToDate = (value) => {
    return value ? parseToDate(value) : undefined;
};
const DateRangeInput = forwardRef(function DateRangeInput({ testId, value = {}, min, max, label, fromLabel, toLabel, labelHidden, status, required, readOnly, disabled, onChange, onFocus, onBlur, showWeekNumber, autoFocus, fromAdditionalInfo, toAdditionalInfo, handle, ...restProps }, ref) {
    const testIds = useTestIds(testId, getDateRangeInputTestIds);
    const t = useI18n();
    const startDateHandle = useRef(null);
    const endDateHandle = useRef(null);
    const [state, dispatch] = useReducer(reducer, {
        start: value.start ? parseToDate(value.start).getTime() : undefined,
        end: value.end ? parseToDate(value.end).getTime() : undefined
    });
    // Need to keep the value in ref also, to be able to call onBlur with newest value
    const startDateRef = useRef(convertToCallbackParameter(prepareValue(state.start, 'start')));
    const endDateRef = useRef(convertToCallbackParameter(prepareValue(state.end, 'end')));
    useImperativeHandle(handle, () => ({
        clear: () => {
            startDateHandle.current?.clear();
            endDateHandle.current?.clear();
            const emptyCallbackParameter = convertToCallbackParameter(undefined);
            startDateRef.current = emptyCallbackParameter;
            endDateRef.current = emptyCallbackParameter;
            dispatch({ type: 'start', value: undefined });
            dispatch({ type: 'end', value: undefined });
            onChange({
                start: emptyCallbackParameter,
                end: emptyCallbackParameter
            });
        }
    }), [onChange]);
    const onFocusChange = useCallback((focused) => {
        (focused ? onFocus : onBlur)?.({
            start: startDateRef.current,
            end: endDateRef.current
        });
    }, [onFocus, onBlur]);
    const containerRef = useConsolidatedRef(ref);
    useFocusWithin([containerRef], onFocusChange);
    const onStartDateChange = (selectedDate) => {
        const selected = selectedDate?.getTime();
        let start;
        let end;
        if (state.end && selected && selected > state.end) {
            dispatch({ type: 'start', value: state.end });
            dispatch({ type: 'end', value: selected });
            onChange({
                start: convertToCallbackParameter(prepareValue(state.end, 'start')),
                end: convertToCallbackParameter(prepareValue(selected, 'end'))
            });
            start = state.end;
            end = selected;
        }
        else {
            dispatch({ type: 'start', value: selected });
            onChange({
                start: convertToCallbackParameter(prepareValue(selected, 'start')),
                end: convertToCallbackParameter(prepareValue(state.end, 'end'))
            });
            start = selected;
            end = state.end;
        }
        startDateRef.current = convertToCallbackParameter(prepareValue(start, 'start'));
        endDateRef.current = convertToCallbackParameter(prepareValue(end, 'end'));
        endDateHandle.current?.setOpen(true);
    };
    const onEndDateChange = (selectedDate) => {
        const selected = selectedDate?.getTime();
        let start;
        let end;
        if (state.start && selected && selected < state.start) {
            dispatch({ type: 'end', value: state.start });
            dispatch({ type: 'start', value: selected });
            onChange({
                start: convertToCallbackParameter(prepareValue(selected, 'start')),
                end: convertToCallbackParameter(prepareValue(state.start, 'end'))
            });
            start = selected;
            end = state.start;
        }
        else {
            dispatch({ type: 'end', value: selected });
            onChange({
                start: convertToCallbackParameter(prepareValue(state.start, 'start')),
                end: convertToCallbackParameter(prepareValue(selected, 'end'))
            });
            start = state.start;
            end = selected;
        }
        startDateRef.current = convertToCallbackParameter(prepareValue(start, 'start'));
        endDateRef.current = convertToCallbackParameter(prepareValue(end, 'end'));
    };
    const getSelectedRange = () => {
        const startDate = parseValueToDate(state.start);
        const endDate = parseValueToDate(state.end);
        if (startDate && endDate && startDate > endDate)
            return undefined;
        return {
            startDate,
            endDate
        };
    };
    const commonProps = {
        required,
        readOnly,
        disabled,
        min,
        max,
        status
    };
    return (_jsx(FormField, { testId: testIds, as: StyledDateRangeInput, ...restProps, ref: containerRef, container: { wrap: 'nowrap' }, labelHidden: labelHidden, label: label, labelAs: 'legend', required: required, readOnly: readOnly, status: status, disabled: disabled, children: _jsxs(Flex, { container: true, as: StyledRangeInputContainer, children: [_jsx(DateInput, { ...commonProps, testId: testIds.fromDate, value: state.start, handle: startDateHandle, picker: {
                        renderer: DateRangePicker,
                        rendererProps: {
                            selected: getSelected(state.start, state.end),
                            selectedRange: getSelectedRange(),
                            onChange: onStartDateChange
                        }
                    }, onBlur: changedValue => {
                        // invalid value stored only in ref, state holds undefined
                        dispatch({
                            type: 'start',
                            value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                        });
                        const newValue = changedValue.state
                            ? changedValue
                            : convertToCallbackParameter(prepareValue(changedValue.valueAsTimestamp, 'start'));
                        startDateRef.current = newValue;
                        onChange({
                            start: newValue,
                            end: convertToCallbackParameter(prepareValue(state.end, 'end'))
                        });
                    }, additionalInfo: fromAdditionalInfo, label: fromLabel, "aria-label": `${t('range_from_datetime') + (label ? ` - ${label}` : '')}`, autoFocus: autoFocus }), _jsx(DateInput, { ...commonProps, testId: testIds.toDate, value: state.end, handle: endDateHandle, picker: {
                        renderer: DateRangePicker,
                        rendererProps: {
                            selected: getSelected(state.end, state.start),
                            selectedRange: getSelectedRange(),
                            onChange: onEndDateChange
                        }
                    }, onBlur: changedValue => {
                        // invalid value stored only in ref, state holds undefined
                        dispatch({
                            type: 'end',
                            value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                        });
                        const newValue = changedValue.state
                            ? changedValue
                            : convertToCallbackParameter(prepareValue(changedValue.valueAsTimestamp, 'end'));
                        endDateRef.current = newValue;
                        onChange({
                            start: convertToCallbackParameter(prepareValue(state.start, 'start')),
                            end: newValue
                        });
                    }, additionalInfo: toAdditionalInfo, label: toLabel, "aria-label": `${t('range_to_datetime') + (label ? ` - ${label}` : '')}` })] }) }));
});
export default withTestIds(DateRangeInput, getDateRangeInputTestIds);
//# sourceMappingURL=DateRangeInput.js.map