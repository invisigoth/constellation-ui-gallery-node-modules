import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useCallback, useImperativeHandle, useReducer, useRef } from 'react';
import Flex from '../../Flex';
import { useConsolidatedRef, useFocusWithin, useI18n, useTestIds } from '../../../hooks';
import { StyledRangeInputContainer } from '../../Input/Input.styles';
import FormField from '../../FormField';
import { getTimeRangeInputTestIds } from '../DateTime.test-ids';
import { withTestIds } from '../../../utils';
import { parseToDate } from './utils';
import TimeInput from './TimeInput';
import DateTimeInput from './DateTimeInput';
const reducer = (prevState, { type, value }) => {
    switch (type) {
        case 'start': {
            return { ...prevState, start: value };
        }
        case 'end': {
            return { ...prevState, end: value };
        }
        default:
            return prevState;
    }
};
const convertToCallbackParameter = (v) => {
    return {
        valueAsISOString: v === undefined || Number.isNaN(v) ? undefined : new Date(v).toISOString(),
        valueAsTimestamp: v
    };
};
const TimeRangeInput = forwardRef(function TimeRangeInput({ testId, value = {}, onChange, onFocus, onBlur, label, fromLabel, toLabel, labelHidden, required, readOnly, disabled, min, max, withSeconds, pickerInterval, clockFormat, mode, status, fromAdditionalInfo, toAdditionalInfo, autoFocus, handle, ...restProps }, ref) {
    const testIds = useTestIds(testId, getTimeRangeInputTestIds);
    const t = useI18n();
    const startTimeInputRef = useRef(null);
    const endTimeInputRef = useRef(null);
    const startTimeClearHandle = useRef(null);
    const endTimeClearHandle = useRef(null);
    const [state, dispatch] = useReducer(reducer, {
        start: value.start ? parseToDate(value.start).getTime() : undefined,
        end: value.end ? parseToDate(value.end).getTime() : undefined
    });
    const startTimeRef = useRef(convertToCallbackParameter(state.start));
    const endTimeRef = useRef(convertToCallbackParameter(state.end));
    useImperativeHandle(handle, () => ({
        clear: () => {
            startTimeClearHandle.current?.clear();
            endTimeClearHandle.current?.clear();
            const emptyCallbackParameter = convertToCallbackParameter(undefined);
            startTimeRef.current = emptyCallbackParameter;
            endTimeRef.current = emptyCallbackParameter;
            dispatch({ type: 'start', value: undefined });
            dispatch({ type: 'end', value: undefined });
            onChange({
                start: emptyCallbackParameter,
                end: emptyCallbackParameter
            });
        }
    }), [onChange]);
    const onFocusChange = useCallback((focused) => {
        (focused ? onFocus : onBlur)?.({
            start: startTimeRef.current,
            end: endTimeRef.current
        });
    }, [onFocus, onBlur]);
    const containerRef = useConsolidatedRef(ref);
    useFocusWithin([containerRef], onFocusChange);
    const commonProps = {
        required,
        readOnly,
        disabled,
        min,
        max,
        status,
        withSeconds,
        pickerInterval,
        clockFormat
    };
    return (_jsx(FormField, { testId: testIds, as: 'fieldset', ...restProps, container: { wrap: 'nowrap' }, ref: containerRef, labelAs: 'legend', label: label, labelHidden: labelHidden, disabled: disabled, required: required, readOnly: readOnly, status: status, children: _jsx(Flex, { container: true, as: StyledRangeInputContainer, children: mode === 'time' ? (_jsxs(_Fragment, { children: [_jsx(TimeInput, { ...commonProps, testId: testIds.fromTime, value: state.start, onBlur: changedValue => {
                            dispatch({
                                type: 'start',
                                value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                            });
                            startTimeRef.current = changedValue;
                            onChange({
                                start: changedValue,
                                end: convertToCallbackParameter(state.end)
                            });
                        }, label: fromLabel, "aria-label": `${t('range_from_datetime') + (label ? ` - ${label}` : '')}`, additionalInfo: fromAdditionalInfo, autoFocus: autoFocus, ref: startTimeInputRef, handle: startTimeClearHandle }), _jsx(TimeInput, { ...commonProps, testId: testIds.toTime, value: state.end, onBlur: changedValue => {
                            dispatch({
                                type: 'end',
                                value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                            });
                            endTimeRef.current = changedValue;
                            onChange({
                                start: convertToCallbackParameter(state.start),
                                end: changedValue
                            });
                        }, label: toLabel, "aria-label": `${t('range_to_datetime') + (label ? ` - ${label}` : '')}`, additionalInfo: toAdditionalInfo, ref: endTimeInputRef, handle: endTimeClearHandle })] })) : (_jsxs(_Fragment, { children: [_jsx(DateTimeInput, { ...commonProps, testId: testIds.fromDateTime, value: state.start, onBlur: changedValue => {
                            dispatch({
                                type: 'start',
                                value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                            });
                            startTimeRef.current = changedValue;
                            onChange({
                                start: changedValue,
                                end: convertToCallbackParameter(state.end)
                            });
                        }, label: fromLabel, "aria-label": `${t('range_from_datetime') + (label ? ` - ${label}` : '')}`, additionalInfo: fromAdditionalInfo, ref: startTimeInputRef, handle: startTimeClearHandle }), _jsx(DateTimeInput, { testId: testIds.toDateTime, ...commonProps, value: state.end, onBlur: changedValue => {
                            dispatch({
                                type: 'end',
                                value: changedValue.state ? undefined : changedValue.valueAsTimestamp
                            });
                            endTimeRef.current = changedValue;
                            onChange({
                                start: convertToCallbackParameter(state.start),
                                end: changedValue
                            });
                        }, label: toLabel, "aria-label": `${t('range_to_datetime') + (label ? ` - ${label}` : '')}`, additionalInfo: toAdditionalInfo, ref: endTimeInputRef, handle: endTimeClearHandle })] })) }) }));
});
export default withTestIds(TimeRangeInput, getTimeRangeInputTestIds);
//# sourceMappingURL=TimeRangeInput.js.map