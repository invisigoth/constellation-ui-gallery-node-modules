import { cap } from '../../utils';
import { CALENDAR_TYPES } from './Input/local';
import { getEndOfWeek, getQuarter, getStartOfWeek, getWeek, getWeekYear } from './Input/utils';
const unitsInMs = {
    year: 24 * 60 * 60 * 1000 * 365,
    month: (24 * 60 * 60 * 1000 * 365) / 12,
    day: 24 * 60 * 60 * 1000,
    hour: 60 * 60 * 1000,
    minute: 60 * 1000,
    second: 1000
};
const timeShort = {
    hour: 'numeric',
    minute: 'numeric'
};
const timeShort12 = {
    ...timeShort,
    hour12: true
};
const timeShort24 = {
    ...timeShort,
    hour12: false
};
const timeLong = {
    ...timeShort,
    second: 'numeric'
};
const timeLong12 = {
    ...timeShort12,
    second: 'numeric'
};
const timeLong24 = {
    ...timeShort24,
    second: 'numeric'
};
const formatMapping = {
    date: {
        short: { year: 'numeric', month: 'short', day: 'numeric' },
        long: { year: 'numeric', month: 'long', day: 'numeric' },
        numeric: { year: 'numeric', month: 'numeric', day: 'numeric' }
    },
    datetime: {
        short: { year: 'numeric', month: 'short', day: 'numeric', ...timeShort },
        long: { year: 'numeric', month: 'long', day: 'numeric', ...timeLong },
        numeric: { year: 'numeric', month: 'numeric', day: 'numeric', ...timeShort }
    },
    datetime12: {
        short: { year: 'numeric', month: 'short', day: 'numeric', ...timeShort12 },
        long: { year: 'numeric', month: 'long', day: 'numeric', ...timeLong12 },
        numeric: { year: 'numeric', month: 'numeric', day: 'numeric', ...timeShort12 }
    },
    datetime24: {
        short: { year: 'numeric', month: 'short', day: 'numeric', ...timeShort24 },
        long: { year: 'numeric', month: 'long', day: 'numeric', ...timeLong24 },
        numeric: { year: 'numeric', month: 'numeric', day: 'numeric', ...timeShort24 }
    },
    time: {
        short: timeShort,
        long: timeLong,
        numeric: timeShort
    },
    time12: {
        short: timeShort12,
        long: timeLong12,
        numeric: timeShort12
    },
    time24: {
        short: timeShort24,
        long: timeLong24,
        numeric: timeShort24
    },
    month: {
        short: { month: 'short' },
        long: { month: 'long' },
        numeric: { month: 'numeric' }
    },
    monthyear: {
        short: { year: 'numeric', month: 'short' },
        long: { year: 'numeric', month: 'long' },
        numeric: { year: 'numeric', month: 'numeric' }
    },
    week: {
        short: { month: 'short', day: 'numeric' },
        long: { month: 'long', day: 'numeric' },
        numeric: { month: 'numeric', day: 'numeric' }
    },
    year: {
        short: { year: 'numeric' },
        long: { year: 'numeric' },
        numeric: { year: '2-digit' }
    },
    relative: {
        short: { style: 'long', numeric: 'auto' },
        long: { style: 'long', numeric: 'auto' },
        numeric: { style: 'short', numeric: 'auto' }
    }
};
const dateTimeFormatCache = {};
const relativeTimeFormatCache = {};
const displayNamesCache = {};
export function formatDateTime(value, { t, locale, format, variant, clockFormat, calendarType = CALENDAR_TYPES.ISO_8601, timeZone }) {
    const getFormattedDate = (date, dateVariant, overrideTimeZone) => {
        const resolvedVariant = dateVariant === 'time' || dateVariant === 'datetime'
            ? `${dateVariant}${clockFormat ?? ''}`
            : dateVariant;
        const resolvedTimeZone = overrideTimeZone ?? timeZone;
        const resolvedOptions = formatMapping[resolvedVariant][format];
        dateTimeFormatCache[locale] ??= {};
        dateTimeFormatCache[locale][`${resolvedTimeZone}`] ??= new Map();
        const map = dateTimeFormatCache[locale][`${resolvedTimeZone}`];
        if (!map.has(resolvedOptions)) {
            map.set(resolvedOptions, new Intl.DateTimeFormat(locale, {
                ...resolvedOptions,
                timeZone: resolvedTimeZone
            }));
        }
        return map.get(resolvedOptions).format(date);
    };
    const relativeTimeFormatter = (relativeValue, unit) => {
        const resolvedOptions = formatMapping.relative[format];
        relativeTimeFormatCache[locale] ??= new Map();
        const map = relativeTimeFormatCache[locale];
        if (!map.has(resolvedOptions)) {
            map.set(resolvedOptions, new Intl.RelativeTimeFormat(locale, resolvedOptions));
        }
        return map.get(resolvedOptions).format(relativeValue, unit);
    };
    const getUnitsElapsed = (date, unit) => {
        let amount;
        const now = new Date();
        switch (unit) {
            case 'year':
                amount = date.getUTCFullYear() - now.getUTCFullYear();
                break;
            case 'month':
                if (date.getUTCFullYear() === now.getUTCFullYear()) {
                    amount = date.getUTCMonth() - now.getUTCMonth();
                }
                else if (date < now) {
                    amount = (11 - date.getUTCMonth() + now.getUTCMonth() + 1) * -1;
                }
                else {
                    amount = 11 - now.getUTCMonth() + date.getUTCMonth() + 1;
                }
                break;
            case 'day':
                if (date.getUTCMonth() === now.getUTCMonth()) {
                    amount = date.getUTCDate() - now.getUTCDate();
                }
                else if (date < now) {
                    const maximalDayOfMonth = new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + 1, 0)).getUTCDate();
                    amount = (maximalDayOfMonth - date.getUTCDate() + now.getUTCDate()) * -1;
                }
                else {
                    const maximalDayOfMonth = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), 0)).getUTCDate();
                    amount = maximalDayOfMonth - now.getUTCDate() + date.getUTCDate() + 1;
                }
                break;
            case 'hour':
                if (date.getUTCDate() === now.getUTCDate()) {
                    amount = date.getUTCHours() - now.getUTCHours();
                }
                else if (date < now) {
                    amount = (23 - date.getUTCHours() + now.getUTCHours() + 1) * -1;
                }
                else {
                    amount = 23 - now.getUTCHours() + date.getUTCHours() + 1;
                }
                break;
            case 'minute':
                if (date.getUTCHours() === now.getUTCHours()) {
                    amount = date.getUTCMinutes() - now.getUTCMinutes();
                }
                else if (date < now) {
                    amount = (59 - date.getUTCMinutes() + now.getUTCMinutes() + 1) * -1;
                }
                else {
                    amount = 59 - now.getUTCMinutes() + date.getUTCMinutes() + 1;
                }
                break;
            default:
                amount = 0;
                break;
        }
        return amount;
    };
    const getRelativeTime = (date) => {
        let elapsed = date.getTime() - Date.now();
        // Deliberately reduce precision to 1 minute
        if (Math.abs(elapsed) < 60000)
            elapsed = 0;
        const unit = (Object.keys(unitsInMs).find(u => Math.abs(elapsed) >= unitsInMs[u]) ||
            'second');
        const amount = getUnitsElapsed(date, unit);
        return relativeTimeFormatter(amount, unit);
    };
    const getFormattedWeek = (date) => {
        displayNamesCache[locale] ??= new Intl.DisplayNames(locale, {
            style: 'long',
            type: 'dateTimeField'
        });
        const displayNames = displayNamesCache[locale];
        const adjustedUTCDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
        const startDate = getFormattedDate(getStartOfWeek(adjustedUTCDate, calendarType), 'week', 'UTC');
        const endDate = getFormattedDate(getEndOfWeek(adjustedUTCDate, calendarType), 'week', 'UTC');
        return `${cap(displayNames.of('weekOfYear'))} ${getWeek(adjustedUTCDate, calendarType)}, ${getWeekYear(adjustedUTCDate)} (${startDate} - ${endDate})`;
    };
    const getFormattedQuarterYear = (date) => {
        const formattedYear = getFormattedDate(date, 'year');
        const adjustedUTCDate = new Date(date.getTime() - date.getTimezoneOffset() * 60000);
        const quarterNumber = getQuarter(adjustedUTCDate);
        return `${t(`date_quarter_q${quarterNumber}`, [formattedYear])}`;
    };
    switch (variant) {
        case 'relative':
            return getRelativeTime(value);
        case 'week':
            return getFormattedWeek(value);
        case 'quarteryear':
            return getFormattedQuarterYear(value);
        default:
            return getFormattedDate(value, variant);
    }
}
const dayInMs = 24 * 60 * 60 * 1000;
const hourInMs = 60 * 60 * 1000;
const minuteInMs = 60 * 1000;
const secondInMs = 1000;
const numberFormatCache = {};
export function formatDuration(valueInMs, { locale, significantUnits, unitDisplay = 'narrow' }) {
    numberFormatCache[locale] ??= {};
    const sign = valueInMs < 0 ? '-' : '';
    const absMs = Math.abs(valueInMs);
    if (absMs < secondInMs) {
        numberFormatCache[locale].seconds ??= {};
        numberFormatCache[locale].seconds.narrow ??= new Intl.NumberFormat(locale, {
            style: 'unit',
            unit: 'second',
            unitDisplay: 'narrow'
        });
        return numberFormatCache[locale].seconds.narrow.format(0);
    }
    const durationParts = [
        { unit: 'day', value: Math.floor(absMs / dayInMs) },
        { unit: 'hour', value: Math.floor((absMs % dayInMs) / hourInMs) },
        { unit: 'minute', value: Math.floor((absMs % hourInMs) / minuteInMs) },
        { unit: 'second', value: Math.floor((absMs % minuteInMs) / secondInMs) }
    ];
    const result = [];
    for (let i = 0; result.length < significantUnits && i < durationParts.length; i += 1) {
        const { value, unit } = durationParts[i];
        if (value > 0) {
            numberFormatCache[locale][unit] ??= {};
            numberFormatCache[locale][unit][unitDisplay] ??= new Intl.NumberFormat(locale, {
                style: 'unit',
                unit,
                unitDisplay
            });
            result.push(numberFormatCache[locale][unit][unitDisplay].format(value));
        }
    }
    return `${sign}${result.join(' ')}`;
}
/**
 * @returns Current date and time value adjusted for local time zone.
 */
export const getAdjustedUTCDateTime = () => {
    const now = new Date();
    now.setTime(now.getTime() - now.getTimezoneOffset() * 60000);
    return now;
};
//# sourceMappingURL=utils.js.map