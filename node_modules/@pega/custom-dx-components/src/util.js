import fs from 'fs';
import { join } from 'path';
import { promisify } from 'util';
import https from 'https';
import crypto from 'node:crypto';
import { createRequire } from 'module';

import chalk from 'chalk';
import mustache from 'mustache';
import pascalCase from 'pascalcase';
import fetch from 'node-fetch';
import checkGit from 'check-git';

import * as currentPath from './currentPath.cjs';
import {
  COMPONENTS_DIRECTORY_PATH,
  TASKS_CONFIG_JSON_FILENAME,
  TOKEN_PATH,
  OOTB_COMPONENT_SERVICE_REST_ENDPOINT,
  DELETE_COMPONENT_SERVICE_REST_ENDPOINT,
  LP_DELETE_COMPONENT_SERVICE_REST_ENDPOINT,
  OOTB_COMPONENTS,
  USE_PROMOTED_WEB_PACK
} from './constants.js';

const access = promisify(fs.access);

export const checkPathAccess = async (path, options = {}, throwError = false) => {
  const { errorMessage } = options;

  try {
    await access(path, fs.constants.R_OK);
  } catch (err) {
    if (throwError) {
      throw new Error(err);
    } else {
      const message =
        errorMessage || `${chalk.red.bold('ERROR')} Could not able to access path - ${path}`;
      console.error(message);
      process.exit(1);
    }
  }
};

export const getUseWebPackPromotion = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  try {
    // force to throw error and not console log
    await checkPathAccess(pegaConfigJsonPath, {}, true);
  } catch (ex) {
    // when can't find it, always be false, assume no webpack override.
    // This is IMPORTANT for init (npx install)
    return false;
  }

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  if (data[USE_PROMOTED_WEB_PACK] == null) {
    // value doesn't exist in task config, so add it with default of false
    data[USE_PROMOTED_WEB_PACK] = false;
    await updateUseWebPackPromotion(false);
  }

  return data[USE_PROMOTED_WEB_PACK];
};

export const updateUseWebPackPromotion = async (useValue = false) => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  data.usePromotedWebPack = useValue;

  fs.writeFileSync(pegaConfigJsonPath, JSON.stringify(data, null, 4), { encoding: 'utf8' });
};

export const deleteLocalComponent = async componentKey => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  const directory = join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH], componentKey);

  try {
    fs.rmSync(directory, { recursive: true });
    console.log(`${chalk.red.bold(componentKey)} is deleted from Local`);
  } catch (err) {
    console.log('no file');
    throw new Error(`No such file ${componentKey}`);
  }
};

export const getHttpsAgent = serverConfig => {
  const agentOptions = { rejectUnauthorized: false };
  if (serverConfig.legacyTLS) {
    agentOptions.secureOptions = crypto.constants.SSL_OP_LEGACY_SERVER_CONNECT;
  }
  return new https.Agent(agentOptions);
};

export const deleteServerComponent = async componentKey => {
  const serverConfig = await getPegaServerConfig();
  const { server, user, password } = serverConfig;
  const url = constructCompleteUrl(server, DELETE_COMPONENT_SERVICE_REST_ENDPOINT);
  const [componentName, rulesetName, rulesetVersion] = componentKey.split('~|~');
  const deleteUrl = `${url}/${componentName}/rulesetname/${rulesetName}/rulesetversion/${rulesetVersion}`;
  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    if (OauthData) {
      const {
        access_token: accessToken,
        token_type: tokenType,
        refresh_token: refreshToken
      } = JSON.parse(OauthData);
      fetch(deleteUrl, {
        method: 'DELETE',
        agent: getHttpsAgent(serverConfig),
        headers: {
          Authorization: `${tokenType} ${accessToken}`
        }
      })
        .then(response => response.text())
        .then(resp => {
          let respData;
          try {
            respData = JSON.parse(resp);
          } catch (e) {
            console.log(chalk.bold.redBright(`Failure : ${resp}`));
            process.exit(1);
          }

          if (respData.status == 200) {
            console.log(chalk.bold.green(`Success : ${respData.message}`));
          } else {
            throw new Error(`${respData.message}`);
          }
        })
        .catch(e => Promise.reject(`${chalk.bold.red(e)}`));
    }
  } catch (error) {
    console.log(`\n${chalk.bold.red(error)}`);
  }
};

export const getComponents = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });

  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not find components directory path in config.json`
    );
    process.exit(1);
  }

  const directory = join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH]);
  return fs
    .readdirSync(directory, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
};

export const getSubComponents = async (directory, type) => {
  const subDirectory = join(directory, type);
  return fs
    .readdirSync(subDirectory, { withFileTypes: true })
    .filter(dirent => dirent.isDirectory())
    .map(dirent => dirent.name);
};

export const getDirectoryFiles = async directory => {
  return fs
    .readdirSync(directory, { withFileTypes: true })
    .filter(dirent => !dirent.isDirectory())
    .map(dirent => dirent.name);
};

export const getComponentsObj = async () => {
  const compList = [];

  // const componentList = await getDirectoryFiles(directory);
  const componentList = await getComponents();

  if (componentList.length > 0) {
    compList.push(
      ...componentList.map(name => {
        const container = {};
        container.name = name;
        container.value = name;

        return container;
      })
    );
  }

  return compList;
};

export const getPegaConfig = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  return data;
};

export const getPegaServerConfig = async () => {
  const config = await getPegaConfig();
  return config['server-config'];
};

export const getComponentDefaults = async () => {
  const config = await getPegaConfig();
  return config.component;
};

export const getServerType = async () => {
  const defaultPegaServerConfig = await getPegaServerConfig();
  return defaultPegaServerConfig.serverType;
};

export const setServerType = async serverType => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);
  const configData = await getPegaConfig();
  const serverConfig = configData['server-config'];
  serverConfig.serverType = serverType;

  // update file
  // stringify "4", makes the json string look like JSON in the file, formated instead of a single line
  fs.writeFileSync(pegaConfigJsonPath, JSON.stringify(configData, null, 4), { encoding: 'utf8' });
};

export const getComponentDirectoryPath = async componentKey => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  await checkPathAccess(pegaConfigJsonPath);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  return join(currentDirectory, data[COMPONENTS_DIRECTORY_PATH], componentKey);
};

export const compileMustacheTemplate = (file, data) => {
  const content = fs.readFileSync(file, 'utf8');
  return mustache.render(content, data);
};

export const isPascalCase = string => {
  return string === pascalCase(string);
};

export const convertIntoPascalCase = string => {
  return pascalCase(string);
};

export const constructCompleteUrl = (baseServer, endPoint) => {
  return baseServer.endsWith('/') ? `${baseServer}${endPoint}` : `${baseServer}/${endPoint}`;
};

export const sanitize = str => {
  /* Allow only numbers and case insensitive alphabets */
  str = str.replace(/[^a-zA-Z0-9 ]/g, '');
  /* spaces will be replaced by - */
  str = str.replace(/\s+/g, '-');
  return str;
};

export const validateSemver = str => {
  /* basic semver version validation - 0.0.1-dev */
  const regex = /^[0-9]\d*\.\d+\.\d+(?:-[a-zA-Z0-9]+)?$/g;
  return regex.test(str);
};

export const validateRulesetVersion = str => {
  /* Ruleset version range - 01-99 */
  if (str.indexOf('00') !== -1) {
    return false;
  }
  /* basic ruleset version validation - 01-01-01 */
  const regex = /^\d\d-\d\d-\d\d$/g;
  return regex.test(str);
};

export const standardizeStr = (str, length) => {
  return str.padEnd(length);
};

export const showVersion = () => {
  // get package version, so can display at start
  // const require = createRequire(import.meta.url);
  const require = createRequire(currentPath.default);

  const pData = require('@pega/custom-dx-components/package.json');

  console.log(chalk.green(`DX Component Builder v${pData.version}`));

  // do a check of node version, it should be 18 or greater
  const arNodeVersion = process.versions.node.split('.');

  const nodeMajorVersion = parseInt(arNodeVersion[0]);
  const nodeMinorVersion = parseInt(arNodeVersion[1]);

  if (nodeMajorVersion < 18) {
    console.log(
      chalk.redBright(
        `DX Component Builder - SDK requires node v18 or greater, current version: ${process.version}`
      )
    );
    process.exit(1);
  }

  const hasGit = checkGit(process.cwd());

  if (!hasGit) {
    console.log(chalk.redBright('DX Component Builder - Git needs to be installed.'));
    process.exit(1);
  }
};

export const getOOTBComponents = async () => {
  return new Promise(resolve => {
    fs.readFile(OOTB_COMPONENTS, 'utf-8', async (error, ootbComponentsData) => {
      if (error) {
        try {
          const serverConfig = await getPegaServerConfig();
          const { server } = serverConfig;
          const url = constructCompleteUrl(server, OOTB_COMPONENT_SERVICE_REST_ENDPOINT);
          const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');
          if (OauthData) {
            const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);
            fetch(url, {
              method: 'GET',
              agent: getHttpsAgent(serverConfig),
              headers: {
                Authorization: `${tokenType} ${accessToken}`
              }
            })
              .then(response => response.text())
              .then(data => {
                if (data.charAt() === '[') {
                  data = data.slice(1, -1);
                  data = data.replace(/\s/g, '');
                  fs.writeFile(OOTB_COMPONENTS, data, err => {
                    if (err) {
                      console.error(err);
                    }
                    resolve(data.split(','));
                  });
                } else {
                  data = JSON.parse(data);
                  if (data && data.errors) {
                    const errMessages = data.errors;
                    errMessages.forEach(msgArr => {
                      throw new Error(`Failed with error - ${JSON.stringify(msgArr.message)}`);
                    });
                  }
                }
              })
              // eslint-disable-next-line prefer-promise-reject-errors
              .catch(e => Promise.reject(`${chalk.bold.red(e)}`));
          }
        } catch (e) {
          throw new Error('Error occurred in validation', e);
        }
      } else {
        resolve(ootbComponentsData.split(','));
      }
    });
  });
};

export const deleteInfinityServerComponent = async componentKey => {
  const serverConfig = await getPegaServerConfig();
  const { server } = serverConfig;
  const url = constructCompleteUrl(server, DELETE_COMPONENT_SERVICE_REST_ENDPOINT);
  const [componentName, rulesetName, rulesetVersion] = componentKey.split('~|~');
  const deleteUrl = `${url}/${componentName}/rulesetname/${rulesetName}/rulesetversion/${rulesetVersion}`;
  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    let status = 500;

    if (OauthData) {
      const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);

      const response = await fetch(deleteUrl, {
        method: 'DELETE',
        agent: getHttpsAgent(serverConfig),
        headers: {
          Authorization: `${tokenType} ${accessToken}`
        }
      });

      status = response.status;
      if (!response.ok) {
        if (status === 401) {
          throw new Error('Error occurred in authentication. Please regenerate using authenticate');
          // console.log(accessTokenUri, refreshToken);
          /* TODO - Handle refresh_token */
        } else if (status === 404) {
          throw new Error('404: Server resource not found');
        } else if (status === 405) {
          throw new Error('405: Server method not allowed');
        } else if (status === 408) {
          throw new Error('408: Server timed out');
        } else if (response.status === 403) {
          throw new Error('Error forbidden: User does not have privileges to Publish.');
        }
      }

      try {
        const respData = await response.json();
        console.log(chalk.bold.green(`Success : ${respData.message}`));

        if (status === 500) {
          status = 999;
          throw new Error(respData.message);
        }
      } catch (err) {
        if (status === 500) {
          throw new Error(`Error occurred in authentication. Please regenerate using authenticate`);
        } else if (status === 999) {
          throw new Error(err);
        }
      }
    }
  } catch (error) {
    throw new Error(error);
  }
};

export const deleteLaunchpadServerComponent = async componentKey => {
  const { server, isolationId } = await getPegaServerConfig();
  const deleteUrl = constructCompleteUrl(
    server,
    LP_DELETE_COMPONENT_SERVICE_REST_ENDPOINT.replace('{isolationId}', isolationId || 'undefined')
  );
  const [componentName] = componentKey.split('~|~');

  try {
    const OauthData = fs.readFileSync(TOKEN_PATH, 'utf8');

    let status = 500;

    if (OauthData) {
      const { access_token: accessToken, token_type: tokenType } = JSON.parse(OauthData);

      const headers = {
        Authorization: `${tokenType} ${accessToken}`,
        cookie: `Pega-AAT=${accessToken}`,
        'Content-Type': 'application/json'
      };

      const apiBody = {
        type: 'CustomComponent',
        componentName
      };

      const response = await fetch(deleteUrl, {
        method: 'DELETE',
        agent: new https.Agent({ rejectUnauthorized: false }),
        headers,
        body: JSON.stringify(apiBody)
      });

      status = response.status;
      if (!response.ok) {
        if (status === 401) {
          throw new Error('Error occurred in authentication. Please regenerate using authenticate');
          // console.log(accessTokenUri, refreshToken);
          /* TODO - Handle refresh_token */
        } else if (status === 404) {
          throw new Error('404: Server resource not found');
        } else if (status === 405) {
          throw new Error('405: Server method not allowed');
        } else if (status === 408) {
          throw new Error('408: Server timed out');
        } else if (response.status === 403) {
          throw new Error('Error forbidden: User does not have privileges to Publish.');
        }
      }

      try {
        const respData = await response.text();
        console.log(chalk.bold.green(`Success : ${respData}`));

        if (status === 500) {
          status = 999;
          throw new Error(respData.message);
        }
      } catch (err) {
        if (status === 500) {
          throw new Error(`Error occurred in authentication. Please regenerate using authenticate`);
        } else if (status === 999) {
          throw new Error(err);
        }
      }
    }
  } catch (error) {
    throw new Error(error);
  }
};
