import fs from 'fs';
import path, {join} from 'path';

import chalk from 'chalk';
import inquirer from 'inquirer';
import ora from 'ora';

import {
  deleteInfinityServerComponent,
  deleteLaunchpadServerComponent,
  deleteLocalComponent,
  getComponents,
  getPegaServerConfig,
  standardizeStr,
  validateRulesetVersion
} from '../../util.js';
import { getComponentsFromServer } from '../list/helper.js';
import { TASKS_CONFIG_JSON_FILENAME, COMPONENTS_DIRECTORY_PATH, COMPONENTS_PATH } from '../../constants.js';

export const SOURCE_OF_COMPONENT_TYPES = {
  SERVER: 'Server',
  LOCAL: 'Local'
};

let library;
let organization;


export const getDeleteComponentsQuestions = async (options) => {
  const defaultPegaServerConfig = await getPegaServerConfig();

  return [
    {
      name: 'sourceOfComponents',
      type: 'rawlist',
      message: 'Delete components from Server or Local ?',
      choices: Object.values(SOURCE_OF_COMPONENT_TYPES),
      default: defaultPegaServerConfig.sourceOfComponents,
      when() {
        return !options.params[3];
      }
    }
  ];
};

export const getLaunchPadFilterQuestions = async () => {
  const currentDirectory = process.cwd();
  const pegaConfigJsonPath = join(currentDirectory, TASKS_CONFIG_JSON_FILENAME);

  let data = fs.readFileSync(pegaConfigJsonPath, { encoding: 'utf8' });
  data = data && JSON.parse(data);

  if (!data[COMPONENTS_DIRECTORY_PATH]) {
    console.error(
      `${chalk.red.bold('ERROR')} Could not able find components directory path in config.json`
    );
    process.exit(1);
  }

  const componentData = data[COMPONENTS_PATH];

  ({ library } = componentData);
  ({ organization } = JSON.parse(fs.readFileSync(path.resolve('package.json'), 'utf8')));

  return [
    {
      name: 'organization',
      message: 'Enter component organization (required)',
      default: organization,
      validate: value => {
        if (value) {
          return true;
        }
        return 'Please provide value for organization';
      }
    },
    {
      name: 'library',
      message: 'Enter library name (required)',
      default: library,
      validate: value => {
        if (value) {
          return true;
        }
        return 'Please provide value for library';
      }
    }
  ];
}

export const deleteLocalComponents = async (sourceOfComponents, options) => {
  const localComponents = await getComponents();

  // eslint-disable-next-line no-restricted-syntax, guard-for-in
  for (const index in localComponents) {
    console.log(chalk.bold.green(localComponents[index]));
  }

  if (localComponents.length > 0) {
    if (options.params.length >= 5) {
      const sDeletion = options.params[4];
      const confirmDeletion = sDeletion === 'Y' || sDeletion === 'y' || sDeletion === true || sDeletion === 'true';
      if (confirmDeletion) {
        // eslint-disable-next-line no-restricted-syntax, guard-for-in
        for (const index in localComponents) {
          const componentToDelete = localComponents[index];
          // console.log(chalk.bold.green("Deleting: " + componentToDelete));
          // eslint-disable-next-line no-await-in-loop
          await deleteLocalComponent(componentToDelete);
        }
      }
    } else {
      const answers = await inquirer.prompt([
        {
          name: 'confirmDeletion',
          type: 'confirm',
          message: 'Delete all local ?',
          default: false
        }
      ]);
      if (answers.confirmDeletion) {
        for (const component of localComponents) {
          // console.log(chalk.bold.green("Deleting: " + componentToDelete));
          // eslint-disable-next-line no-await-in-loop
          await deleteLocalComponent(component);
        }
      }
    }
  } else {
    console.log(chalk.bold.redBright(`No custom components in ${sourceOfComponents}`));
  }
};

export const deleteServerComponents = async (sourceOfComponents, answers) => {

  const defaultPegaServerConfig = await getPegaServerConfig();
  const isLaunchpad = defaultPegaServerConfig.serverType === 'launchpad';

  if (isLaunchpad) {
    const questions = await getLaunchPadFilterQuestions();
    const lpAnswers = await inquirer.prompt(questions);

    ({library, organization} = lpAnswers);
  }


  let spinner;
  let data;
  try {
    spinner = ora('Fetching components from server').start();
    data = await getComponentsFromServer(library, organization);
    spinner.stop();
  }
  catch (error) {
    spinner.stop();
    if (error.indexOf("ECONNREFUSED") >= 0) {
      console.log(`\n${chalk.bold.red('Error occurred in authentication. Please regenerate using authenticate')}`);
    }
    else {
      console.log(`${chalk.bold.red(error)}`);
    }

    // spinner.stop();
    process.exit(1);
  }


  // const serverComponents = isLaunchpad ? data : data.pxResults;
  let serverComponents;
  if (isLaunchpad) {
    serverComponents = data;
  } else {
    try {
      if (typeof data === 'object') {
        serverComponents = data.pxResults;
      } else {
        serverComponents = JSON.parse(data).pxResults;
      }
    } catch (ex) {
      /* empty */
    }
  }



  if (serverComponents && serverComponents?.length > 0) {
    if (isLaunchpad) {
      serverComponents.forEach((component) => {
        console.log(chalk.bold.green(component.name));
      });

      const confirmDeletionAnswers = await inquirer.prompt([
        {
          name: 'confirmDeletion',
          type: 'confirm',
          message: 'All custom components for the tenant would be deleted. Do you want to proceed ?',
          default: false
        }
      ]);

      if (confirmDeletionAnswers.confirmDeletion) {
        const componentsList = serverComponents.map((component) => `${component.name}~|~`);
        for (const componentToDelete of componentsList) {
          // eslint-disable-next-line no-await-in-loop
          try {
            await deleteLaunchpadServerComponent(componentToDelete);
          }
          catch (err) {
            console.log(chalk.bold.red(err.toString()));
            process.exit(1);
          }
        }
      }
    } else {
      const choicesArr = serverComponents.map(({ label, pyRuleSet, pyRuleSetVersion }) => {
        const name = `${standardizeStr(label, 45)} ${standardizeStr(pyRuleSet, 30)} ${standardizeStr(pyRuleSetVersion, 20)}`;

        const value = `${label}~|~${pyRuleSet}~|~${pyRuleSetVersion}`;
        const short = `\n Selected component : ${chalk.redBright(`${label} ${pyRuleSet} : ${pyRuleSetVersion}`)}`;

        return { name, value, short };
      });

      const selectedComp = await inquirer.prompt([
        {
          name: 'rulesetName',
          message: 'Enter ruleset name',
          default: defaultPegaServerConfig.rulesetName,
          validate: (value) => {
            if (value.trim()) {
              return true;
            }
            return 'Ruleset name cannot be empty';
          }
        },
        {
          name: 'rulesetVersion',
          message: 'Enter ruleset version',
          default: defaultPegaServerConfig.rulesetVersion,
          validate: (value) => {
            if (validateRulesetVersion(value)) {
              return true;
            }
            return 'Please provide compatible version e.g 01-01-01';
          }
        }
      ]);

      let bHasAtLeastOneComponent = false;
      for (const choice of choicesArr) {
        const componentToDelete = choice.value;
        const [name, rulesetName, rulesetVersion] = componentToDelete.split('~|~');
        if (rulesetName === selectedComp.rulesetName && rulesetVersion === selectedComp.rulesetVersion) {
          console.log(chalk.bold.green(name));
          bHasAtLeastOneComponent = true;
        }
      }

      if (!bHasAtLeastOneComponent) {
        console.log(chalk.bold.redBright(`No custom components in ${sourceOfComponents} that match ruleSet:${selectedComp.rulesetName}.`));
        process.exit();
      }

      const confirmDeletionAnswers = await inquirer.prompt([
        {
          name: 'confirmDeletion',
          type: 'confirm',
          message: 'Do you want to delete these components ?',
          default: false
        }
      ]);
      if (confirmDeletionAnswers.confirmDeletion) {
        for (const choice of choicesArr) {
          const componentToDelete = choice.value;
          // eslint-disable-next-line no-unused-vars
          const [name, rulesetName, rulesetVersion] = componentToDelete.split('~|~');
          if (rulesetName === selectedComp.rulesetName && rulesetVersion === selectedComp.rulesetVersion) {
            // eslint-disable-next-line no-await-in-loop

            try {
              await deleteInfinityServerComponent(componentToDelete);
            }
            catch (err) {
              console.log(chalk.bold.red(err.toString()));
              process.exit(1);
            }


          }
        }
      }
    }
  } else {
    console.log(chalk.bold.redBright(`No custom components in ${sourceOfComponents}`));
  }
};
