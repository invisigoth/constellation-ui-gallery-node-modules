import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useEffect, useRef, useState } from 'react';
import { Flex, getEdge, registerIcon, StyledStackedFieldValue, StyledLabel, StyledFieldName, useDirection, useChToPxConversionFactor, NoValue } from '@pega/cosmos-react-core';
import * as pencilIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/pencil.icon';
import * as moreIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/more.icon';
import { StyledHeaderSummary, StyledHeaderSummaryValue, StyledHeaderSummaryBlock } from '../CaseView.styles';
import { useCaseViewContext } from '../CaseView.context';
registerIcon(pencilIcon, moreIcon);
const Field = ({ item, primary, truncate }) => {
    const { name, value, simpleValue } = item;
    const displayValue = simpleValue ?? value ?? _jsx(NoValue, {});
    return (_jsxs(StyledStackedFieldValue, { children: [_jsx(StyledLabel, { as: StyledFieldName, children: name }), _jsx(StyledHeaderSummaryValue, { bold: primary, truncate: truncate, children: displayValue })] }));
};
const Summary = ({ siblingRef }) => {
    const { ltr } = useDirection();
    const { summaryFields } = useCaseViewContext();
    const chToPxConversionFactor = useChToPxConversionFactor();
    const containerRef = useRef(null);
    const listRef = useRef(null);
    const primaryItems = summaryFields?.primary ?? [];
    const secondaryItems = summaryFields?.secondary ?? [];
    const items = [...primaryItems, ...secondaryItems];
    const [displayCount, setDisplayCount] = useState(items.length);
    const [truncatedIndices, setTruncatedIndices] = useState(items.map((_, i) => i));
    const priorTrailingEdgeStack = useRef([]);
    const priorAvailableSpace = useRef(null);
    const evalItemAddition = ({ nextSiblingLeadingEdge }) => {
        const indicesToTruncate = truncatedIndices ? [...truncatedIndices] : [];
        let nextDisplayCount = displayCount;
        const reversedTrailingEdgeStack = [...priorTrailingEdgeStack.current].reverse();
        for (let i = 0; i < reversedTrailingEdgeStack.length; i += 1) {
            const priorEdge = reversedTrailingEdgeStack[i];
            const shouldRender = ltr
                ? priorEdge < nextSiblingLeadingEdge
                : priorEdge > nextSiblingLeadingEdge;
            if (shouldRender) {
                priorTrailingEdgeStack.current.pop();
                if (!indicesToTruncate.includes(nextDisplayCount)) {
                    indicesToTruncate.push(nextDisplayCount);
                }
                nextDisplayCount += 1;
            }
            else {
                break;
            }
        }
        return { indicesToTruncate, nextDisplayCount };
    };
    const evalTruncationReduction = ({ listChildren, availableSpace }) => {
        const indicesToTruncate = [];
        let hasAvailableSpace = availableSpace;
        listChildren.forEach((item, index) => {
            const valueEl = item.lastChild;
            const truncatedSpace = Math.floor(valueEl.scrollWidth - valueEl.offsetWidth);
            const shouldTruncate = truncatedSpace === 0 ? false : hasAvailableSpace - truncatedSpace <= 0;
            if (shouldTruncate) {
                if (!truncatedIndices?.includes(index)) {
                    hasAvailableSpace += truncatedSpace;
                }
                indicesToTruncate.push(index);
            }
            else if (truncatedIndices?.includes(index)) {
                hasAvailableSpace -= truncatedSpace;
            }
        });
        return { indicesToTruncate };
    };
    const evalTruncationIncrease = ({ listChildren, availableSpace }) => {
        const indicesToTruncate = [];
        const lastIndex = listChildren.length - 1;
        let hasAvailableSpace = availableSpace;
        [...listChildren].reverse().forEach((item, index) => {
            if (truncatedIndices?.includes(lastIndex - index)) {
                indicesToTruncate.push(lastIndex - index);
            }
            else if (hasAvailableSpace < 0) {
                const truncatedElMaxWidth = 20 * chToPxConversionFactor;
                const valueEl = item.lastChild;
                const spaceToTruncate = Math.max(Math.floor(valueEl.offsetWidth - truncatedElMaxWidth), 0);
                if (spaceToTruncate) {
                    indicesToTruncate.push(lastIndex - index);
                    hasAvailableSpace += spaceToTruncate;
                }
            }
        });
        return { indicesToTruncate, availableSpace: hasAvailableSpace };
    };
    const evalItemRemoval = ({ listChildren, availableSpace, nextSiblingLeadingEdge }) => {
        let nextDisplayCount = displayCount;
        let hasAvailableSpace = availableSpace;
        let lastChildIndex = listChildren.length - 1;
        do {
            const itemTrailingEdge = getEdge({
                el: listChildren[lastChildIndex],
                side: 'trailing',
                ltr
            });
            hasAvailableSpace = Math.floor(ltr ? nextSiblingLeadingEdge - itemTrailingEdge : itemTrailingEdge - nextSiblingLeadingEdge);
            if (hasAvailableSpace < 0) {
                priorTrailingEdgeStack.current = [...priorTrailingEdgeStack.current, itemTrailingEdge];
                nextDisplayCount -= 1;
                lastChildIndex -= 1;
            }
        } while (hasAvailableSpace < 0 && lastChildIndex > -1);
        return { displayCount: nextDisplayCount };
    };
    const evaluateSummaryDisplay = () => {
        const containerEl = containerRef.current;
        if (!containerEl)
            return;
        const listChildren = Array.from(listRef.current?.children ?? []);
        const lastSummaryItem = listChildren.length ? listChildren[listChildren.length - 1] : undefined;
        const nextSibling = siblingRef?.current ?? document.body;
        const nextSiblingLeadingEdge = getEdge({
            el: nextSibling,
            side: 'leading',
            ltr
        });
        const testEdge = lastSummaryItem
            ? getEdge({ el: lastSummaryItem, side: 'trailing', ltr })
            : getEdge({ el: containerEl, side: 'leading', ltr });
        let availableSpace = Math.floor(ltr ? nextSiblingLeadingEdge - testEdge : testEdge - nextSiblingLeadingEdge);
        if (availableSpace === priorAvailableSpace.current)
            return;
        priorAvailableSpace.current = availableSpace;
        let indicesToTruncate;
        let nextDisplayCount = displayCount;
        if (availableSpace >= 0) {
            if (displayCount !== items.length) {
                const additionsConfig = evalItemAddition({ nextSiblingLeadingEdge });
                indicesToTruncate = additionsConfig.indicesToTruncate;
                nextDisplayCount = additionsConfig.nextDisplayCount;
            }
            else if (truncatedIndices?.length) {
                const truncationConfig = evalTruncationReduction({
                    listChildren,
                    availableSpace
                });
                indicesToTruncate = truncationConfig.indicesToTruncate;
            }
        }
        else if (listChildren) {
            const truncationConfig = evalTruncationIncrease({
                listChildren,
                availableSpace
            });
            indicesToTruncate = truncationConfig.indicesToTruncate;
            availableSpace = truncationConfig.availableSpace;
            if (availableSpace < 0) {
                const removalConfig = evalItemRemoval({
                    listChildren,
                    availableSpace,
                    nextSiblingLeadingEdge
                });
                nextDisplayCount = removalConfig.displayCount;
            }
        }
        setDisplayCount(nextDisplayCount);
        if (indicesToTruncate) {
            setTruncatedIndices(indicesToTruncate);
        }
    };
    // Initial display evaluation
    useEffect(() => {
        evaluateSummaryDisplay();
    }, []);
    // Overflow resize observer
    useEffect(() => {
        const resizeObserver = new ResizeObserver(evaluateSummaryDisplay);
        if (containerRef.current) {
            resizeObserver.observe(containerRef.current, { box: 'border-box' });
        }
        return () => {
            resizeObserver.disconnect();
        };
    }, [evaluateSummaryDisplay]);
    return (_jsx(Flex, { as: StyledHeaderSummaryBlock, item: { grow: 1, shrink: 1 }, container: { pad: [0.5, 0], alignItems: 'center' }, ref: containerRef, hasItems: displayCount > 0, children: _jsx(Flex, { as: StyledHeaderSummary, container: { gap: 4 }, ref: listRef, children: items.slice(0, displayCount).map((item, index) => {
                return (_jsx(Field, { item: item, primary: !!primaryItems?.length && index < primaryItems.length, truncate: !!truncatedIndices?.includes(index) }, item.name));
            }) }) }));
};
export default Summary;
//# sourceMappingURL=Summary.js.map