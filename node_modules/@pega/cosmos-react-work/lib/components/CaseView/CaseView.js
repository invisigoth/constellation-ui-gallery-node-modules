import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-runtime";
import { useEffect, useMemo, useRef, useLayoutEffect, useState } from 'react';
import { Flex, Grid, Icon, registerIcon, TabPanel, useBreakpoint, useScrollStick, useElement, Card, Drawer, useI18n, useDirection, Tabs, useAfterInitialEffect, windowIsAvailable, focusHeadingOrContainer, useConfiguration, useTestIds, withTestIds } from '@pega/cosmos-react-core';
import * as moveRightSolidIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/move-right-solid.icon';
import * as moveLeftSolidIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/move-left-solid.icon';
import CaseSummary from './CaseSummary';
import UtilitiesSummary from './UtilitiesSummary';
import { StyledCaseDrawer, StyledCaseDrawerContent, StyledCaseView, StyledWorkArea, StyledPersistentUtility, StyledSummary, StyledSummaryTabContent, StyledUtilities, StyledExpandCollapseUtilitiesButton, StyledUtilitiesHeading } from './CaseView.styles';
import CaseViewContext from './CaseView.context';
import CaseSummaryFields from './CaseSummaryFields';
import { getCaseViewTestIds } from './CaseView.test-ids';
registerIcon(moveRightSolidIcon, moveLeftSolidIcon);
// This function is responsible for auto sizing table height in case tab panels.
const resizeTable = (tabPanelEl, workAreaEl) => {
    tabPanelEl.style.removeProperty('--content-height-in-view');
    // .rs-wrapper is currently the class used by the table component which needs to be targeted.
    const tables = Array.from(tabPanelEl.querySelectorAll('.rs-wrapper')).filter(table => table.getBoundingClientRect().width !== 0);
    // Only perform this logic when there is a single table in a tab's panel.
    if (tables.length !== 1)
        return;
    // This selector finds the table's root element as they are always wrapped in a Card.
    const table = tables[0].closest('article');
    if (!table)
        return;
    const tabPanelRect = tabPanelEl.getBoundingClientRect();
    const tableRect = table.getBoundingClientRect();
    const vpHeight = document.documentElement.clientHeight;
    const tableRectOffsetTop = tableRect.top + window.scrollY;
    const workAreaPaddingBlockEnd = 
    // px unit are required for proper CSS calc calculation.
    window.getComputedStyle(workAreaEl).getPropertyValue('padding-block-end') || '0px';
    // Accounts for content rendered after the table.
    const tableBottomToTabPanelBottom = tabPanelRect.bottom - tableRect.bottom;
    // Sets a CSS variable for available height based on screen size and view state.
    // Defines an available minimum height of ~600px.
    tabPanelEl.style.setProperty('--content-height-in-view', `max(calc(${vpHeight - tableRectOffsetTop - tableBottomToTabPanelBottom}px - ${workAreaPaddingBlockEnd}), 37.5rem)`);
};
const CaseView = ({ testId, 
// Case data mostly visually related to the case header
caseId, heading, subheading, caseLink, parentCases, icon, followed, onFollowedChange, onEdit, actions, promotedActions, 
// Summary content and state props
summaryFields, summaryExpanded: summaryExpandedProp = true, onToggleSummary, 
// Case tabs
tabs: { currentTabId, items: tabItemsProp, onClick: onTabClick }, 
// Workarea related content props
banners, stages, tasks, tabContent: tabContentProp = [], 
// Utilities content and state props
utilities, utilitiesSummaryItems, utilitiesExpanded: utilitiesExpandedProp = true, onToggleUtilities, 
// Etc...
persistentUtility, intelligentGuidance, isPreview = false, ...restProps }) => {
    const testIds = useTestIds(testId, getCaseViewTestIds);
    // General util hooks
    const t = useI18n();
    const direction = useDirection();
    const { loadedRef } = useConfiguration();
    // Element refs
    const caseViewRef = useRef(null);
    const summaryRef = useRef(null);
    // undefined used to allow ref to be mutable. Element set below in ref callback for scroll stick.
    const workAreaRef = useRef();
    const toggleButtonRef = useRef(null);
    const isToggleButtonFocused = useRef(false);
    // Tab content
    const [tabContentEl, setTabContentEl] = useElement(null);
    // Breakpoint booleans
    const smOrAbove = useBreakpoint('sm');
    const mdOrAbove = useBreakpoint('md', { breakpointRef: caseViewRef });
    const lgOrAbove = useBreakpoint('lg', { breakpointRef: caseViewRef });
    const xlOrAbove = useBreakpoint('xl', { breakpointRef: caseViewRef });
    // DOM ids
    const initialTabId = tabItemsProp[0]?.id;
    const summaryTabId = `summary-${caseId}`;
    const utilitiesTabId = `utilities-${caseId}`;
    const persistentUtilityTabId = `persistent-utility-${caseId}`;
    // Summary state handling
    let summaryExpanded = !isPreview && !!summaryExpandedProp;
    if (persistentUtility) {
        summaryExpanded = xlOrAbove;
    }
    // Focus heading on initial mount
    useEffect(() => {
        if (!caseViewRef.current)
            return;
        if (loadedRef.current) {
            focusHeadingOrContainer(caseViewRef.current, heading);
        }
        else {
            loadedRef.current = true;
        }
    }, [caseId]);
    // Utilities state handling
    // Used in coordination with a layoutEffect below to determine the utilities state on initial render.
    // Attempted with a ref but it did not work. Using state and enforcing a render in addition to the change render for lgOrAbove seems to fix...
    const [obeyUtilitiesExpandedProp, setObeyUtilitiesExpandedProp] = useState(lgOrAbove);
    // Allow the utilitiesExpandedProp to drive the utilities' state after the initial render
    useLayoutEffect(() => {
        if (lgOrAbove)
            setObeyUtilitiesExpandedProp(true);
    }, [lgOrAbove]);
    // Tracks whether a resize forced the onToggleUtilities to close the utilities when it's a drawer
    const utilitiesToggledByResize = useRef(false);
    // If the initial render is within the MD size, where the utility drawer renders, it must begin collapsed
    const utilitiesExpanded = obeyUtilitiesExpandedProp ? utilitiesExpandedProp : false;
    // Handles utilities state based on breakpoint changes.
    useAfterInitialEffect(() => {
        // If we change into the MD breakpoint range and the utilities state is expanded call the toggle prop to collapse it with controlled state
        if (mdOrAbove && !lgOrAbove && utilitiesExpandedProp) {
            onToggleUtilities?.();
            utilitiesToggledByResize.current = true;
        }
        if (lgOrAbove) {
            if (utilitiesToggledByResize.current && !utilitiesExpandedProp) {
                onToggleUtilities?.();
            }
            utilitiesToggledByResize.current = false;
        }
        // Purposely not listing utilitiesExpanded as a dependency as it is not a trigger and will be captured when BPs change
    }, [mdOrAbove, lgOrAbove]);
    // Handles focus of toggle button when toggled in drawer mode and when browser is resized
    useEffect(() => {
        if (isToggleButtonFocused.current) {
            toggleButtonRef.current?.focus();
        }
        if (!toggleButtonRef.current) {
            // Toggle button is not on DOM.
            isToggleButtonFocused.current = false;
        }
    }, [utilitiesExpanded, mdOrAbove, lgOrAbove]);
    // Prepare tabs
    const [tabItems, tabContent] = useMemo(() => {
        const summaryTab = { id: summaryTabId, name: t('summary') };
        const summaryTabContent = {
            id: summaryTabId,
            content: (_jsx(Card, { children: _jsx(StyledSummaryTabContent, { children: _jsx(CaseSummaryFields, { ...summaryFields }) }) }))
        };
        let items = tabItemsProp;
        let content = tabContentProp;
        if (mdOrAbove) {
            if (!summaryExpanded || (persistentUtility && !xlOrAbove)) {
                items = [summaryTab, ...tabItemsProp];
                content = [summaryTabContent, ...tabContentProp];
            }
            return [items, content];
        }
        const utilityTabsItems = [];
        const utilityTabsContent = [];
        if (utilities) {
            utilityTabsItems.push({ id: utilitiesTabId, name: t('utilities') });
            utilityTabsContent.push({
                id: utilitiesTabId,
                content: _jsx(Flex, { container: { direction: 'column', gap: 2 }, children: utilities })
            });
        }
        if (persistentUtility) {
            utilityTabsItems.push({ id: persistentUtilityTabId, name: persistentUtility.title });
            utilityTabsContent.push({ id: persistentUtilityTabId, content: persistentUtility?.content });
        }
        items = [summaryTab, ...tabItemsProp, ...utilityTabsItems];
        content = [summaryTabContent, ...tabContentProp, ...utilityTabsContent];
        return [items, content];
    }, [
        tabItemsProp,
        summaryTabId,
        mdOrAbove,
        summaryExpanded,
        persistentUtility,
        xlOrAbove,
        tabContentProp,
        utilities,
        utilitiesTabId,
        persistentUtilityTabId
    ]);
    // Grid layout props
    let caseViewGridContainer = {
        cols: 'minmax(0, 1fr)',
        colGap: 0,
        rows: 'minmax(0, max-content) auto',
        areas: `
      "summary"
      "work-area"
    `
    };
    const sharedGridProps = {
        colGap: 2,
        rows: caseViewGridContainer.rows
    };
    if (persistentUtility) {
        if (xlOrAbove) {
            caseViewGridContainer = {
                ...sharedGridProps,
                cols: 'minmax(0, max-content) minmax(0, 1fr) repeat(2, minmax(0, max-content))',
                areas: '"summary work-area persistentUtility utilities"'
            };
        }
        else if (mdOrAbove) {
            caseViewGridContainer = {
                ...sharedGridProps,
                cols: 'minmax(0, 1fr) repeat(2, minmax(0, max-content))',
                areas: `
          "summary summary summary"
          "work-area persistentUtility utilities"
        `
            };
        }
    }
    else if (summaryExpanded) {
        if (mdOrAbove) {
            caseViewGridContainer = {
                ...sharedGridProps,
                cols: 'minmax(0, max-content) minmax(0, 1fr) minmax(0, max-content)',
                areas: '"summary work-area utilities"'
            };
        }
    }
    else if (mdOrAbove) {
        caseViewGridContainer = {
            ...sharedGridProps,
            cols: 'minmax(0, 1fr) minmax(0, max-content)',
            areas: `
            "summary summary"
            "work-area utilities"
          `
        };
    }
    // Apply sticky columns
    const scrollStickOptions = useRef({
        elements: []
    });
    const stickOffset = useMemo(() => {
        if (windowIsAvailable && caseViewRef.current) {
            return parseFloat(window.getComputedStyle(caseViewRef.current).getPropertyValue('--appshell-offset'));
        }
        return 0;
    }, [caseViewRef.current]);
    useScrollStick(
    // isMediumOrAbove means side by side columns | | |
    mdOrAbove ? { ...scrollStickOptions.current, offset: stickOffset } : undefined);
    // Preview set summary tab active
    useEffect(() => {
        if (isPreview) {
            onTabClick(summaryTabId);
        }
    }, []);
    // Initial tab selection
    useEffect(() => {
        if (mdOrAbove &&
            summaryExpanded &&
            !persistentUtility &&
            (currentTabId === summaryTabId || currentTabId === utilitiesTabId)) {
            onTabClick(tabItemsProp[0]?.id);
        }
        // Toggle utilities tab selection
        if (mdOrAbove && [utilitiesTabId, persistentUtilityTabId].includes(currentTabId)) {
            onTabClick(initialTabId);
        }
    }, [mdOrAbove]);
    // Initial / summary tab selection
    useEffect(() => {
        if (!smOrAbove && currentTabId === initialTabId) {
            onTabClick(summaryTabId);
        }
        else if (smOrAbove && currentTabId === summaryTabId) {
            onTabClick(initialTabId);
        }
    }, [smOrAbove]);
    // Summary tab selection
    useEffect(() => {
        if (isPreview) {
            onTabClick(summaryTabId);
        }
    }, [isPreview]);
    // Initial tab selection
    useEffect(() => {
        if (summaryExpanded && currentTabId === summaryTabId) {
            onTabClick(initialTabId);
        }
    }, [summaryExpanded]);
    // Handles scrolling to tab content for newly clicked tab
    useEffect(() => {
        if (!tabContentEl)
            return;
        const scrollPos = window.scrollY;
        const windowHeight = document.documentElement.clientHeight;
        const bottomPos = scrollPos + windowHeight * 0.8;
        const tabContentPos = tabContentEl.offsetTop;
        if (tabContentPos > bottomPos) {
            const top = tabContentPos - windowHeight * 0.2;
            window.scrollTo({ top, behavior: 'smooth' });
        }
    }, [currentTabId]);
    // We need a css variable for the height of the case summary when it is collapsed into a header like layout
    useLayoutEffect(() => {
        if (!caseViewRef.current || !summaryRef.current)
            return;
        caseViewRef.current.style.setProperty('--summary-height', `${!summaryExpanded ? summaryRef.current.offsetHeight : 0}px`);
    }, [summaryExpanded]);
    // CaseView context value
    // Choosing not to memo for now due to extent of deps and how often they change. Optimize as needed.
    // eslint-disable-next-line react/jsx-no-constructed-context-values
    const ctxValue = {
        testIds,
        caseId,
        heading,
        subheading,
        caseLink,
        parentCases,
        icon,
        followed,
        onFollowedChange,
        actions,
        promotedActions,
        onEdit,
        summaryFields,
        tabs: {
            items: tabItems,
            onClick: onTabClick,
            currentTabId
        },
        stages,
        tasks,
        persistentUtility,
        intelligentGuidance,
        summaryExpanded,
        utilitiesExpanded,
        onToggleSummary,
        isPreview,
        aboveSM: smOrAbove,
        aboveMD: mdOrAbove,
        aboveLG: lgOrAbove,
        aboveXL: xlOrAbove
    };
    const currentTabPanelRef = useRef(null);
    // The following effects are dedicated to resizeTable handling.
    useLayoutEffect(() => {
        if (!currentTabPanelRef.current || !workAreaRef.current)
            return;
        const currentTabPanelEl = currentTabPanelRef.current;
        const workAreaEl = workAreaRef.current;
        resizeTable(currentTabPanelEl, workAreaEl);
        const onTabChange = () => {
            resizeTable(currentTabPanelEl, workAreaEl);
        };
        // TODO: optimize
        const mo = new MutationObserver(() => {
            resizeTable(currentTabPanelEl, workAreaEl);
        });
        mo.observe(currentTabPanelEl, { childList: true, subtree: true });
        currentTabPanelEl.addEventListener('cosmos-tab-changed', onTabChange);
        return () => {
            mo.disconnect();
            currentTabPanelEl.removeEventListener('cosmos-tab-changed', onTabChange);
        };
    });
    const [bannersStagesTasksEl, setBannersStagesTasksEl] = useElement(null);
    useEffect(() => {
        if (!bannersStagesTasksEl)
            return;
        const observer = new ResizeObserver(() => {
            if (!currentTabPanelRef.current || !workAreaRef.current)
                return;
            resizeTable(currentTabPanelRef.current, workAreaRef.current);
        });
        observer.observe(bannersStagesTasksEl);
        return () => {
            observer.disconnect();
        };
    }, [bannersStagesTasksEl]);
    useEffect(() => {
        const onResize = () => {
            if (!currentTabPanelRef.current || !workAreaRef.current)
                return;
            resizeTable(currentTabPanelRef.current, workAreaRef.current);
        };
        window.addEventListener('resize', onResize);
        return () => {
            window.removeEventListener('resize', onResize);
        };
    }, []);
    const utilitiesHeading = (_jsx(StyledUtilitiesHeading, { variant: 'h2', children: t('utilities') }));
    const utilitiesToggleButton = (_jsx(StyledExpandCollapseUtilitiesButton, { compact: true, icon: true, label: t(utilitiesExpanded ? 'collapse' : 'expand'), "aria-label": t(utilitiesExpanded ? 'collapse_utilities_panel' : 'expand_utilities_panel'), onClick: () => {
            if (!obeyUtilitiesExpandedProp && utilitiesExpandedProp) {
                setObeyUtilitiesExpandedProp(true);
            }
            else {
                onToggleUtilities?.();
            }
        }, onFocus: () => {
            isToggleButtonFocused.current = true;
        }, onBlur: () => {
            isToggleButtonFocused.current = false;
        }, ref: toggleButtonRef, children: _jsx(Icon, { name: 'arrow-micro-left' }) }));
    // Here we go...
    return (_jsxs(_Fragment, { children: [_jsx(CaseViewContext.Provider, { value: ctxValue, children: _jsxs(Grid, { "data-testid": testIds.root, ...restProps, as: StyledCaseView, ref: caseViewRef, container: caseViewGridContainer, item: { area: 'case-view' }, children: [_jsx(Grid, { as: StyledSummary, item: { area: 'summary' }, desktop: mdOrAbove && (!persistentUtility || xlOrAbove) && !summaryExpanded, isLargeOrAbove: lgOrAbove, ref: summaryRef, children: _jsx(CaseSummary, {}) }), _jsxs(Flex, { container: {
                                direction: 'column',
                                alignContent: 'start',
                                rowGap: 2
                            }, as: StyledWorkArea, persistentUtility: Boolean(persistentUtility), ref: (el) => {
                                workAreaRef.current = el;
                                if (el)
                                    scrollStickOptions.current?.elements.push(el);
                            }, children: [(banners || stages || tasks) && (_jsxs(Flex, { container: {
                                        direction: 'column',
                                        alignContent: 'start',
                                        rowGap: 2
                                    }, ref: setBannersStagesTasksEl, children: [banners && _jsx("div", { "data-testid": testIds.banners, children: banners }), stages && _jsx("div", { "data-testid": testIds.stages, children: stages }), tasks && _jsx("div", { "data-testid": testIds.tasks, children: tasks })] })), (!mdOrAbove || (persistentUtility && !xlOrAbove) || !summaryExpanded) && (_jsx(Tabs, { "data-testid": testIds.tabs, tabs: tabItems, onTabClick: onTabClick, currentTabId: currentTabId })), _jsx("div", { ref: setTabContentEl, children: tabContent?.map(({ id, content }) => (_jsx(TabPanel, { "data-testid": currentTabId === id ? testIds.tabContent : undefined, currentTabId: currentTabId, tabId: id, ref: currentTabId === id ? currentTabPanelRef : undefined, children: content }, id))) })] }), persistentUtility && mdOrAbove && (_jsx(Grid, { as: StyledPersistentUtility, item: { area: 'persistentUtility' }, "data-app-region": true, children: persistentUtility.content })), utilities && mdOrAbove && !lgOrAbove && utilitiesExpanded && (_jsx(Drawer, { as: StyledCaseDrawer, open: utilitiesExpanded, position: 'fixed', placement: direction.end, shadow: true, nullWhenClosed: true, hasPersistentUtility: !!persistentUtility, children: _jsxs(Flex, { as: StyledCaseDrawerContent, container: { direction: 'column', gap: 2 }, "data-app-region": true, children: [_jsxs(Flex, { container: { alignItems: 'center', justify: 'between' }, children: [utilitiesHeading, utilitiesToggleButton] }), utilities] }) })), utilities && mdOrAbove && (_jsxs(Grid, { "data-testid": testIds.utilities, ref: (el) => {
                                if (el)
                                    scrollStickOptions.current?.elements.push(el);
                            }, as: StyledUtilities, container: {
                                cols: 'minmax(0, 1fr)',
                                rowGap: 2
                            }, item: {
                                area: 'utilities'
                            }, "data-app-region": lgOrAbove || !utilitiesExpanded || undefined, "aria-label": t('utilities_label'), children: [_jsxs(Flex, { container: {
                                        alignItems: 'center',
                                        justify: utilitiesExpanded ? 'between' : 'center'
                                    }, children: [utilitiesHeading, !lgOrAbove && utilitiesExpanded ? null : utilitiesToggleButton] }), utilitiesExpanded && lgOrAbove && utilities, (!utilitiesExpanded || (mdOrAbove && !lgOrAbove)) && (_jsx(UtilitiesSummary, { items: utilitiesSummaryItems }))] }))] }) }), intelligentGuidance] }));
};
export default withTestIds(CaseView, getCaseViewTestIds);
//# sourceMappingURL=CaseView.js.map