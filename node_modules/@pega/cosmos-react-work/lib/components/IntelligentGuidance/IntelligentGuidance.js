import { jsx as _jsx, Fragment as _Fragment, jsxs as _jsxs } from "react/jsx-runtime";
import { forwardRef, useLayoutEffect, useRef, useState } from 'react';
import { Icon, useI18n, useAfterInitialEffect, Text, Tabs, CardHeader, TabPanel, Flex, Count, Actions } from '@pega/cosmos-react-core';
import { StyledIntelligentGuidanceList, StyledIntelligentGuidance, StyledNew, StyledBorderLine } from './IntelligentGuidance.styles';
const IntelligentGuidance = forwardRef(function IntelligentGuidance({ items, previousItems, heading, isCollapsed, onExpandCollapse, ...restProps }, ref) {
    const t = useI18n();
    const headerRef = useRef(null);
    const toggleButtonRef = useRef(null);
    const [currentTab, setCurrentTab] = useState('current');
    const listItems = (currentTab === 'current' ? items : previousItems ?? []).map(item => {
        return {
            id: item.id,
            visual: _jsx(Icon, { name: item.icon }),
            primary: (_jsxs(_Fragment, { children: [item.label, item.new && (_jsxs(_Fragment, { children: [_jsx(StyledNew, { children: t('new') }), _jsx(StyledBorderLine, {})] }))] })),
            secondary: _jsx(Text, { variant: 'secondary', children: item.type }),
            contextualLabel: item.label,
            actions: item.onDismiss
                ? [
                    {
                        text: t('dismiss'),
                        id: item.id,
                        icon: 'times',
                        onClick: (id, e) => {
                            e.stopPropagation();
                            item.onDismiss?.(id, e);
                        }
                    }
                ]
                : undefined,
            container: { colGap: 1 },
            role: 'button',
            tabIndex: 0,
            'aria-label': t('continue_label_a11y', [item.label]),
            onClick: item.onClick,
            onKeyDown: (e) => {
                if (e.key === 'Enter') {
                    item.onClick(e);
                }
            }
        };
    });
    const [headerHeight, setHeaderHeight] = useState(0);
    useLayoutEffect(() => {
        if (headerRef.current) {
            setHeaderHeight(headerRef.current?.offsetHeight || 0);
        }
    }, [headerRef.current]);
    // FIXME: This is a hack to get the Tooltip to reset its position when the list is toggled.
    useAfterInitialEffect(() => {
        if (toggleButtonRef.current && toggleButtonRef.current === document.activeElement) {
            toggleButtonRef.current.blur();
            setTimeout(() => {
                toggleButtonRef.current?.focus();
            }, 1000);
        }
    }, [isCollapsed]);
    const intelligentGuidanceList = (_jsx(StyledIntelligentGuidanceList, { items: listItems, noItemsText: t('no_recommendations') }));
    return (_jsxs(StyledIntelligentGuidance, { ...restProps, ref: ref, role: 'region', "aria-live": 'polite', "aria-relevant": 'all', isCollapsed: isCollapsed, hasItems: !!items.length, style: { '--headerHeight': `${headerHeight}px` }, children: [_jsxs(CardHeader, { ref: headerRef, children: [_jsxs(Flex, { container: { alignItems: 'center', gap: 1 }, children: [_jsx(Text, { variant: 'h2', children: heading }), _jsx(Count, { children: items.length + (previousItems?.length ?? 0) })] }), _jsx(Actions, { items: [
                            {
                                text: t(isCollapsed ? 'expand' : 'collapse'),
                                id: 'IntelligentGuidanceButton',
                                icon: 'caret-down',
                                'aria-label': isCollapsed
                                    ? t('expand_noun', [heading])
                                    : t('collapse_noun', [heading]),
                                onClick: onExpandCollapse,
                                ref: toggleButtonRef
                            }
                        ] })] }), previousItems ? (_jsxs(_Fragment, { children: [_jsx(Tabs, { tabs: [
                            {
                                id: 'current',
                                name: t('current'),
                                count: items.filter(item => item.new).length || undefined
                            },
                            {
                                id: 'previous',
                                name: t('previous'),
                                count: previousItems.filter(item => item.new).length || undefined
                            }
                        ], currentTabId: currentTab, onTabClick: setCurrentTab }), _jsx(TabPanel, { tabId: currentTab, children: intelligentGuidanceList })] })) : (intelligentGuidanceList)] }));
});
export default IntelligentGuidance;
//# sourceMappingURL=IntelligentGuidance.js.map