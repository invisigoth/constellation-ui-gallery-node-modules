import { jsx as _jsx, jsxs as _jsxs } from "react/jsx-runtime";
import { useState, useRef, useEffect, forwardRef, Fragment } from 'react';
import { remToPx } from 'polished';
import { Icon, Text, registerIcon, Flex, useI18n, Button, Modal, useBreakpoint, debounce, useModalManager, useConsolidatedRef, useUID, InfoDialog, useArrows, useAfterInitialEffect } from '@pega/cosmos-react-core';
import * as checkIcon from '@pega/cosmos-react-core/lib/components/Icon/icons/check.icon';
import StageGlimpse from './StageGlimpse';
import { StyledInnerStage, StyledStage, StyledStageGlimpse, StyledStages } from './Stages.styles';
registerIcon(checkIcon);
const Stages = forwardRef(function Stages({ current, stages, caseTitle, onLoadStage, ...restProps }, ref) {
    const t = useI18n();
    const stagesRef = useConsolidatedRef(ref);
    const stagesRefs = useRef([]);
    const [target, setTarget] = useState(null);
    const { create: createModal } = useModalManager();
    const modalMethods = useRef();
    const [showModal, setShowModal] = useState(false);
    const isSmallOrAbove = useBreakpoint('sm');
    const [compressedView, setCompressedView] = useState(false);
    const [minExpandedWidth, setMinExpandedWidth] = useState(0);
    useArrows(stagesRef, { selector: ':scope > button:not([aria-expanded])', dir: 'left-right' });
    const dialogId = useUID();
    useEffect(() => {
        if (stagesRef.current) {
            if (compressedView) {
                const resizeObserver = new ResizeObserver(debounce((entries) => {
                    if (entries[0].contentRect.width > minExpandedWidth) {
                        setCompressedView(false);
                    }
                }, 100));
                resizeObserver.observe(stagesRef.current);
                return () => resizeObserver.disconnect();
            }
            const intersectionObserver = new IntersectionObserver(entries => {
                if (!entries[0].isIntersecting) {
                    setCompressedView(true);
                    if (entries[0].rootBounds)
                        setMinExpandedWidth(entries[0].rootBounds.width);
                }
            }, {
                root: stagesRef.current,
                rootMargin: remToPx(0.0625),
                threshold: 1
            });
            if (stagesRef.current.lastElementChild) {
                intersectionObserver.observe(stagesRef.current.lastElementChild);
                return () => intersectionObserver.disconnect();
            }
        }
    }, [minExpandedWidth, compressedView, stages.length]);
    const stagesToLoad = onLoadStage
        ? stages.filter(stage => !Array.isArray(stage.steps)).map(stage => stage.id)
        : [];
    const openModal = () => {
        setShowModal(true);
        if (stagesToLoad.length > 0)
            onLoadStage?.(stagesToLoad);
        modalMethods.current = createModal(Modal, {
            heading: caseTitle
                ? t('stages_case_lifecycle', [caseTitle])
                : t('stages_default_case_lifecycle'),
            progress: stagesToLoad.length > 0,
            children: stages.map(stage => (_jsxs(Fragment, { children: [_jsx(Text, { variant: 'h2', children: stage.name }), _jsx(StageGlimpse, { stage: stage })] }, stage.id))),
            onBeforeClose: () => {
                setShowModal(false);
                target?.focus();
                setTarget(null);
                modalMethods.current = undefined;
            }
        });
    };
    useAfterInitialEffect(() => {
        modalMethods.current?.update({
            progress: stagesToLoad.length > 0,
            children: stages.map(stage => (_jsxs(Fragment, { children: [_jsx(Text, { variant: 'h2', children: stage.name }), _jsx(StageGlimpse, { stage: stage })] }, stage.id)))
        });
    }, [stagesToLoad.length]);
    return (_jsx(Flex, { ...restProps, container: true, as: StyledStages, ref: stagesRef, role: 'region', "aria-label": t('stages_label'), children: stages.map((stage, index) => {
            const isCurrent = stage.id === current;
            let stageStatusText = t(stage.completed ? 'completed' : 'not_started');
            if (isCurrent)
                stageStatusText = t('current');
            const hasToLoad = stagesToLoad.includes(stage.id);
            return (_jsxs(Fragment, { children: [_jsxs(Flex, { container: { justify: 'center', alignItems: 'center' }, as: StyledStage, item: {
                            grow: compressedView && !isCurrent ? 0 : 1,
                            shrink: compressedView && isCurrent ? 1 : 0
                        }, "aria-current": isCurrent ? 'step' : undefined, "aria-label": t('stages_stage_label', [stage.name, stageStatusText]), onClick: (e) => {
                            if (isSmallOrAbove) {
                                if (hasToLoad)
                                    onLoadStage?.([stage.id]);
                                setTarget(e.currentTarget);
                            }
                            else {
                                openModal();
                            }
                        }, ref: (el) => {
                            stagesRefs.current[index] = el;
                        }, "aria-expanded": target && isSmallOrAbove, "aria-controls": target ? dialogId : undefined, children: [stage.completed && _jsx(Icon, { name: 'check' }), (!compressedView || isCurrent || !stage.completed) && (_jsx(StyledInnerStage, { ellipsis: isCurrent && compressedView, children: !isCurrent && compressedView ? index + 1 : stage.name }))] }), target && stagesRefs.current[index] === target && isSmallOrAbove && !showModal && (_jsx(InfoDialog, { heading: stage.name, target: target, progress: hasToLoad ? t('loading') : undefined, onDismiss: () => {
                            setTarget(null);
                        }, placement: 'bottom-start', children: !hasToLoad && (_jsxs(StyledStageGlimpse, { children: [_jsx(StageGlimpse, { stage: stage }), _jsx(Button, { variant: 'secondary', onClick: openModal, children: t('stages_see_full_lifecycle') })] })) }))] }, stage.id));
        }) }));
});
export default Stages;
//# sourceMappingURL=Stages.js.map