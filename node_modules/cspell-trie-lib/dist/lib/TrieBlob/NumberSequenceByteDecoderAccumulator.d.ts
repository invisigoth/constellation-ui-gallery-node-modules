export declare enum SpecialCharIndex {
    Mask = 248,
    MaxCharIndex = 247,
    Index8bit = 249,
    Index14bit = 250,
    Index21bit = 251
}
export type EncodedSequence = [number] | [SpecialCharIndex.Index8bit, number] | [SpecialCharIndex.Index14bit, number, number] | [SpecialCharIndex.Index21bit, number, number, number];
export declare class NumberSequenceByteEncoderDecoder {
    static encode(n: number): EncodedSequence;
    static decode(encodedSequence: EncodedSequence): number;
    static encodeSequence(sequence: Iterable<number>): Iterable<number>;
    static decodeSequence(sequence: Iterable<number>): number[];
    static SpecialCharIndexMask: SpecialCharIndex.Mask;
    static MaxCharIndex: SpecialCharIndex.MaxCharIndex;
    /**
     * SpecialCharIndex8bit is used to indicate a node chain. Where the final character index is 248 + the index found in the next node.
     */
    static SpecialCharIndex8bit: SpecialCharIndex.Index8bit;
    static SpecialCharIndex16bit: SpecialCharIndex.Index14bit;
    static SpecialCharIndex24bit: SpecialCharIndex.Index21bit;
}
export declare class NumberSequenceByteDecoderAccumulator {
    private byteMode;
    private accumulation;
    protected constructor(byteMode?: number, accumulation?: number);
    decodeSequence(sequence: Iterable<number>): Iterable<number>;
    decode(idx: number): number | undefined;
    reset(): void;
    clone(): NumberSequenceByteDecoderAccumulator;
    isPending(): boolean;
    static create(): NumberSequenceByteDecoderAccumulator;
}
//# sourceMappingURL=NumberSequenceByteDecoderAccumulator.d.ts.map