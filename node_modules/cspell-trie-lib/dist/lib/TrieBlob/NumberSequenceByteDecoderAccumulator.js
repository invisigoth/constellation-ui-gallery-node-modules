import { assert } from '../utils/assert.js';
export var SpecialCharIndex;
(function (SpecialCharIndex) {
    SpecialCharIndex[SpecialCharIndex["Mask"] = 248] = "Mask";
    SpecialCharIndex[SpecialCharIndex["MaxCharIndex"] = 247] = "MaxCharIndex";
    SpecialCharIndex[SpecialCharIndex["Index8bit"] = 249] = "Index8bit";
    SpecialCharIndex[SpecialCharIndex["Index14bit"] = 250] = "Index14bit";
    SpecialCharIndex[SpecialCharIndex["Index21bit"] = 251] = "Index21bit";
})(SpecialCharIndex || (SpecialCharIndex = {}));
// eslint-disable-next-line unicorn/no-static-only-class
export class NumberSequenceByteEncoderDecoder {
    static encode(n) {
        if (n < this.SpecialCharIndexMask)
            return [n];
        if (n < this.SpecialCharIndexMask * 2) {
            return [SpecialCharIndex.Index8bit, n - this.SpecialCharIndexMask];
        }
        if (n < 1 << 14)
            return [SpecialCharIndex.Index14bit, n >>> 7, n & 0x7f];
        assert(n < 1 << 21);
        return [SpecialCharIndex.Index21bit, (n >>> 14) & 0x7f, (n >>> 7) & 0x7f, n & 0x7f];
    }
    static decode(encodedSequence) {
        const [a, b, c, d] = encodedSequence;
        switch (a) {
            case SpecialCharIndex.Index8bit: {
                // assert(encodedSequence.length === 2);
                return (b || 0) + this.SpecialCharIndexMask;
            }
            case SpecialCharIndex.Index14bit: {
                // assert(encodedSequence.length === 3);
                return ((b || 0) << 7) + (c || 0);
            }
            case SpecialCharIndex.Index21bit: {
                // assert(encodedSequence.length === 4);
                return ((b || 0) << 14) + ((c || 0) << 7) + (d || 0);
            }
            default: {
                // assert(a <= SpecialCharIndex.MaxCharIndex);
                return a;
            }
        }
    }
    static *encodeSequence(sequence) {
        for (const n of sequence) {
            const encoded = this.encode(n);
            yield* encoded;
        }
    }
    static decodeSequence(sequence) {
        const acc = NumberSequenceByteDecoderAccumulator.create();
        return [...acc.decodeSequence(sequence)];
    }
    static SpecialCharIndexMask = SpecialCharIndex.Mask;
    static MaxCharIndex = SpecialCharIndex.MaxCharIndex;
    /**
     * SpecialCharIndex8bit is used to indicate a node chain. Where the final character index is 248 + the index found in the next node.
     */
    static SpecialCharIndex8bit = SpecialCharIndex.Index8bit;
    static SpecialCharIndex16bit = SpecialCharIndex.Index14bit;
    static SpecialCharIndex24bit = SpecialCharIndex.Index21bit;
}
export class NumberSequenceByteDecoderAccumulator {
    byteMode;
    accumulation;
    constructor(byteMode = 0, accumulation = 0) {
        this.byteMode = byteMode;
        this.accumulation = accumulation;
    }
    *decodeSequence(sequence) {
        const accumulator = this.clone();
        for (const idx of sequence) {
            const r = accumulator.decode(idx);
            if (r !== undefined) {
                yield r;
            }
        }
    }
    decode(idx) {
        if (!this.byteMode) {
            if (idx < NumberSequenceByteEncoderDecoder.SpecialCharIndexMask) {
                const v = idx + this.accumulation;
                this.accumulation = 0;
                return v;
            }
            switch (idx) {
                case NumberSequenceByteEncoderDecoder.SpecialCharIndex8bit: {
                    this.accumulation += NumberSequenceByteEncoderDecoder.SpecialCharIndexMask;
                    break;
                }
                case NumberSequenceByteEncoderDecoder.SpecialCharIndex16bit: {
                    this.byteMode = 2;
                    break;
                }
                case NumberSequenceByteEncoderDecoder.SpecialCharIndex24bit: {
                    this.byteMode = 3;
                    break;
                }
                default: {
                    throw new Error('Invalid SpecialCharIndex');
                }
            }
            return undefined;
        }
        this.accumulation = (this.accumulation << 7) + idx;
        --this.byteMode;
        if (!this.byteMode) {
            const r = this.accumulation;
            this.accumulation = 0;
            return r;
        }
        return undefined;
    }
    reset() {
        this.byteMode = 0;
        this.accumulation = 0;
    }
    clone() {
        const n = new NumberSequenceByteDecoderAccumulator(this.byteMode, this.accumulation);
        return n;
    }
    isPending() {
        return !!(this.byteMode || this.accumulation);
    }
    static create() {
        return new NumberSequenceByteDecoderAccumulator();
    }
}
//# sourceMappingURL=NumberSequenceByteDecoderAccumulator.js.map